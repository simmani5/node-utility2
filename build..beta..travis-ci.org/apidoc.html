<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    overflow-wrap: break-word;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/kaizhu256/node-utility2"

    >utility2 (2020.5.31)</a>
</h1>
<h4>this zero-dependency package will provide high-level functions to to build, test, and deploy webapps</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2">module utility2</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Blob">
            function <span class="apidocSignatureSpan">utility2.</span>Blob
            <span class="apidocSignatureSpan">(list, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData">
            function <span class="apidocSignatureSpan">utility2.</span>FormData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module">
            function <span class="apidocSignatureSpan">utility2.</span>Module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildApidoc_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApidoc_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildApp_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApp_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildLib_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildLib_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildReadme_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildReadme_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_buildTest_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildTest_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._testCase_webpage_default">
            function <span class="apidocSignatureSpan">utility2.</span>_testCase_webpage_default
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.ajax">
            function <span class="apidocSignatureSpan">utility2.</span>ajax
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.ajaxProgressUpdate">
            function <span class="apidocSignatureSpan">utility2.</span>ajaxProgressUpdate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidocCreate">
            function <span class="apidocSignatureSpan">utility2.</span>apidocCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assert">
            function <span class="apidocSignatureSpan">utility2.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assertJsonEqual">
            function <span class="apidocSignatureSpan">utility2.</span>assertJsonEqual
            <span class="apidocSignatureSpan">(aa, bb, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assertJsonNotEqual">
            function <span class="apidocSignatureSpan">utility2.</span>assertJsonNotEqual
            <span class="apidocSignatureSpan">(aa, bb, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.base64FromBuffer">
            function <span class="apidocSignatureSpan">utility2.</span>base64FromBuffer
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.base64ToBuffer">
            function <span class="apidocSignatureSpan">utility2.</span>base64ToBuffer
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.base64ToUtf8">
            function <span class="apidocSignatureSpan">utility2.</span>base64ToUtf8
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.base64urlFromBuffer">
            function <span class="apidocSignatureSpan">utility2.</span>base64urlFromBuffer
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.blobRead">
            function <span class="apidocSignatureSpan">utility2.</span>blobRead
            <span class="apidocSignatureSpan">(blob, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.browserTest">
            function <span class="apidocSignatureSpan">utility2.</span>browserTest
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferConcat">
            function <span class="apidocSignatureSpan">utility2.</span>bufferConcat
            <span class="apidocSignatureSpan">(bufList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferIndexOfSubBuffer">
            function <span class="apidocSignatureSpan">utility2.</span>bufferIndexOfSubBuffer
            <span class="apidocSignatureSpan">(buf, subBff, fromIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferRandomBytes">
            function <span class="apidocSignatureSpan">utility2.</span>bufferRandomBytes
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferToUtf8">
            function <span class="apidocSignatureSpan">utility2.</span>bufferToUtf8
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.bufferValidateAndCoerce">
            function <span class="apidocSignatureSpan">utility2.</span>bufferValidateAndCoerce
            <span class="apidocSignatureSpan">(buf, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildApp">
            function <span class="apidocSignatureSpan">utility2.</span>buildApp
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildLib">
            function <span class="apidocSignatureSpan">utility2.</span>buildLib
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildReadme">
            function <span class="apidocSignatureSpan">utility2.</span>buildReadme
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.buildTest">
            function <span class="apidocSignatureSpan">utility2.</span>buildTest
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.childProcessSpawnWithTimeout">
            function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithTimeout
            <span class="apidocSignatureSpan">(command, args, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.childProcessSpawnWithUtility2">
            function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithUtility2
            <span class="apidocSignatureSpan">(script, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliRun">
            function <span class="apidocSignatureSpan">utility2.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.coalesce">
            function <span class="apidocSignatureSpan">utility2.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.corsBackendHostInject">
            function <span class="apidocSignatureSpan">utility2.</span>corsBackendHostInject
            <span class="apidocSignatureSpan">(url, backendHost, rgx, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.corsForwardProxyHostIfNeeded">
            function <span class="apidocSignatureSpan">utility2.</span>corsForwardProxyHostIfNeeded
            <span class="apidocSignatureSpan">(xhr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cryptoAesXxxCbcRawDecrypt">
            function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawDecrypt
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cryptoAesXxxCbcRawEncrypt">
            function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawEncrypt
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateGetWeekOfMonth">
            function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfMonth
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateGetWeekOfYear">
            function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfYear
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateUtcFromLocal">
            function <span class="apidocSignatureSpan">utility2.</span>dateUtcFromLocal
            <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.dateUtcToLocal">
            function <span class="apidocSignatureSpan">utility2.</span>dateUtcToLocal
            <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domFragmentRender">
            function <span class="apidocSignatureSpan">utility2.</span>domFragmentRender
            <span class="apidocSignatureSpan">(template, dict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domQuerySelectorAllTagName">
            function <span class="apidocSignatureSpan">utility2.</span>domQuerySelectorAllTagName
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domSelectOptionValue">
            function <span class="apidocSignatureSpan">utility2.</span>domSelectOptionValue
            <span class="apidocSignatureSpan">(elem)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.domStyleValidate">
            function <span class="apidocSignatureSpan">utility2.</span>domStyleValidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.emit">
            function <span class="apidocSignatureSpan">utility2.</span>emit
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.eventEmitterCreate">
            function <span class="apidocSignatureSpan">utility2.</span>eventEmitterCreate
            <span class="apidocSignatureSpan">(that = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.events">
            function <span class="apidocSignatureSpan">utility2.</span>events
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.fsReadFileOrDefaultSync">
            function <span class="apidocSignatureSpan">utility2.</span>fsReadFileOrDefaultSync
            <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(pathname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(pathname, data, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.gotoNext">
            function <span class="apidocSignatureSpan">utility2.</span>gotoNext
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.httpFetch">
            function <span class="apidocSignatureSpan">utility2.</span>httpFetch
            <span class="apidocSignatureSpan">(url, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.identity">
            function <span class="apidocSignatureSpan">utility2.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.isNullOrUndefined">
            function <span class="apidocSignatureSpan">utility2.</span>isNullOrUndefined
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter">
            function <span class="apidocSignatureSpan">utility2.</span>istanbul.Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require">
            function <span class="apidocSignatureSpan">utility2.</span>istanbul.require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulCoverageMerge">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageMerge
            <span class="apidocSignatureSpan">(coverage1 = {}, coverage2 = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulCoverageReportCreate">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageReportCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulInstrumentInPackage">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentInPackage
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbulInstrumentSync">
            function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentSync
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslintAndPrint">
            function <span class="apidocSignatureSpan">utility2.</span>jslintAndPrint
            <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslintAutofixLocalFunction">
            function <span class="apidocSignatureSpan">utility2.</span>jslintAutofixLocalFunction
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jsonCopy">
            function <span class="apidocSignatureSpan">utility2.</span>jsonCopy
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jsonStringifyOrdered">
            function <span class="apidocSignatureSpan">utility2.</span>jsonStringifyOrdered
            <span class="apidocSignatureSpan">(obj, replacer, space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listGetElementRandom">
            function <span class="apidocSignatureSpan">utility2.</span>listGetElementRandom
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listShuffle">
            function <span class="apidocSignatureSpan">utility2.</span>listShuffle
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerEmit">
            function <span class="apidocSignatureSpan">utility2.</span>listenerEmit
            <span class="apidocSignatureSpan">(type, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerOn">
            function <span class="apidocSignatureSpan">utility2.</span>listenerOn
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerOnce">
            function <span class="apidocSignatureSpan">utility2.</span>listenerOnce
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.listenerRemove">
            function <span class="apidocSignatureSpan">utility2.</span>listenerRemove
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.localStorageSetItemOrClear">
            function <span class="apidocSignatureSpan">utility2.</span>localStorageSetItemOrClear
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked">
            function <span class="apidocSignatureSpan">utility2.</span>marked
            <span class="apidocSignatureSpan">(e, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer">
            function <span class="apidocSignatureSpan">utility2.</span>marked.InlineLexer
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer">
            function <span class="apidocSignatureSpan">utility2.</span>marked.Lexer
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser">
            function <span class="apidocSignatureSpan">utility2.</span>marked.Parser
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer">
            function <span class="apidocSignatureSpan">utility2.</span>marked.Renderer
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareAssetsCached">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareAssetsCached
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareBodyRead">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareBodyRead
            <span class="apidocSignatureSpan">(req, ignore, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareError">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareError
            <span class="apidocSignatureSpan">(err, req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareFileServer">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareFileServer
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareForwardProxy">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareForwardProxy
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareInit">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareInit
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.middlewareJsonpStateInit">
            function <span class="apidocSignatureSpan">utility2.</span>middlewareJsonpStateInit
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.moduleDirname">
            function <span class="apidocSignatureSpan">utility2.</span>moduleDirname
            <span class="apidocSignatureSpan">(module, pathList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.nop">
            function <span class="apidocSignatureSpan">utility2.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.normalizeJwt">
            function <span class="apidocSignatureSpan">utility2.</span>normalizeJwt
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.normalizeJwtBase64Url">
            function <span class="apidocSignatureSpan">utility2.</span>normalizeJwtBase64Url
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.numberToRomanNumerals">
            function <span class="apidocSignatureSpan">utility2.</span>numberToRomanNumerals
            <span class="apidocSignatureSpan">(num)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.objectAssignRecurse">
            function <span class="apidocSignatureSpan">utility2.</span>objectAssignRecurse
            <span class="apidocSignatureSpan">(dict, overrides, depth, env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.on">
            function <span class="apidocSignatureSpan">utility2.</span>on
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onErrorDefault">
            function <span class="apidocSignatureSpan">utility2.</span>onErrorDefault
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onErrorThrow">
            function <span class="apidocSignatureSpan">utility2.</span>onErrorThrow
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onErrorWithStack">
            function <span class="apidocSignatureSpan">utility2.</span>onErrorWithStack
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onFileModifiedRestart">
            function <span class="apidocSignatureSpan">utility2.</span>onFileModifiedRestart
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onParallel">
            function <span class="apidocSignatureSpan">utility2.</span>onParallel
            <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.onParallelList">
            function <span class="apidocSignatureSpan">utility2.</span>onParallelList
            <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.once">
            function <span class="apidocSignatureSpan">utility2.</span>once
            <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.promisify">
            function <span class="apidocSignatureSpan">utility2.</span>promisify
            <span class="apidocSignatureSpan">(fnc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteerLaunch">
            function <span class="apidocSignatureSpan">utility2.</span>puppeteerLaunch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.removeEventListener">
            function <span class="apidocSignatureSpan">utility2.</span>removeEventListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.removeListener">
            function <span class="apidocSignatureSpan">utility2.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.replStart">
            function <span class="apidocSignatureSpan">utility2.</span>replStart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.requireReadme">
            function <span class="apidocSignatureSpan">utility2.</span>requireReadme
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverLocalReqHandler">
            function <span class="apidocSignatureSpan">utility2.</span>serverLocalReqHandler
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverLocalUrlTest">
            function <span class="apidocSignatureSpan">utility2.</span>serverLocalUrlTest
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondDefault">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondDefault
            <span class="apidocSignatureSpan">(req, res, statusCode, err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondEcho">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondEcho
            <span class="apidocSignatureSpan">(req, res)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondHeadSet">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondHeadSet
            <span class="apidocSignatureSpan">(ignore, res, statusCode, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.serverRespondTimeoutDefault">
            function <span class="apidocSignatureSpan">utility2.</span>serverRespondTimeoutDefault
            <span class="apidocSignatureSpan">(req, res, timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.setTimeoutOnError">
            function <span class="apidocSignatureSpan">utility2.</span>setTimeoutOnError
            <span class="apidocSignatureSpan">(onError, timeout, err, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stateInit">
            function <span class="apidocSignatureSpan">utility2.</span>stateInit
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stream">
            function <span class="apidocSignatureSpan">utility2.</span>stream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.streamCleanup">
            function <span class="apidocSignatureSpan">utility2.</span>streamCleanup
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringHtmlSafe">
            function <span class="apidocSignatureSpan">utility2.</span>stringHtmlSafe
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringLineCount">
            function <span class="apidocSignatureSpan">utility2.</span>stringLineCount
            <span class="apidocSignatureSpan">(str, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringMerge">
            function <span class="apidocSignatureSpan">utility2.</span>stringMerge
            <span class="apidocSignatureSpan">(str1, str2, rgx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringQuotedToAscii">
            function <span class="apidocSignatureSpan">utility2.</span>stringQuotedToAscii
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.stringRegexpEscape">
            function <span class="apidocSignatureSpan">utility2.</span>stringRegexpEscape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.templateRender">
            function <span class="apidocSignatureSpan">utility2.</span>templateRender
            <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.templateRenderMyApp">
            function <span class="apidocSignatureSpan">utility2.</span>templateRenderMyApp
            <span class="apidocSignatureSpan">(template)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testMock">
            function <span class="apidocSignatureSpan">utility2.</span>testMock
            <span class="apidocSignatureSpan">(mockList, onTestCase, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testReportCreate">
            function <span class="apidocSignatureSpan">utility2.</span>testReportCreate
            <span class="apidocSignatureSpan">(testReport)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testReportMerge">
            function <span class="apidocSignatureSpan">utility2.</span>testReportMerge
            <span class="apidocSignatureSpan">(testReport1, testReport2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testRunBrowser">
            function <span class="apidocSignatureSpan">utility2.</span>testRunBrowser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testRunDefault">
            function <span class="apidocSignatureSpan">utility2.</span>testRunDefault
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.testRunServer">
            function <span class="apidocSignatureSpan">utility2.</span>testRunServer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.throwError">
            function <span class="apidocSignatureSpan">utility2.</span>throwError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.timeElapsedPoll">
            function <span class="apidocSignatureSpan">utility2.</span>timeElapsedPoll
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.timeElapsedStart">
            function <span class="apidocSignatureSpan">utility2.</span>timeElapsedStart
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.tryCatchOnError">
            function <span class="apidocSignatureSpan">utility2.</span>tryCatchOnError
            <span class="apidocSignatureSpan">(fnc, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uiAnimateSlideAccordian">
            function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideAccordian
            <span class="apidocSignatureSpan">(elem, elemList, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uiAnimateSlideDown">
            function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideDown
            <span class="apidocSignatureSpan">(elem, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uiAnimateSlideUp">
            function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideUp
            <span class="apidocSignatureSpan">(elem, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.urlJoin">
            function <span class="apidocSignatureSpan">utility2.</span>urlJoin
            <span class="apidocSignatureSpan">(aa, bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.urlParse">
            function <span class="apidocSignatureSpan">utility2.</span>urlParse
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.uuid4Create">
            function <span class="apidocSignatureSpan">utility2.</span>uuid4Create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.</span>timeExit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.</span>timeoutDefault</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>utility2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>FormData.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>Module._extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>Module.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>_debugTryCatchError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>_http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>apidoc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>apidoc.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>assetsDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>cacheDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>errorDefault</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>github_crud</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>github_crud.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.Instrumenter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.escodegen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.esprima</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.esprima.Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.esprima.Position.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.estraverse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.estraverse.Controller.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul.process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint.CSSLint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint.CSSLint._Reporter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint.cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.InlineLexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.Lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>marked.Renderer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>middlewareList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>puppeteer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>puppeteer.puppeteerApi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpCharsetEncodeUri</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpCharsetEncodeUriComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpMatchUrl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpValidateEmail</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpValidatePhone</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>regexpValidateUuid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>taskOnTaskDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>modeTestCase</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>serverLocalHost</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringCharsetAscii</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringCharsetEncodeUri</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringCharsetEncodeUriComponent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.</span>stringHelloEmoji</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.FormData">module utility2.FormData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData.FormData">
            function <span class="apidocSignatureSpan">utility2.</span>FormData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.FormData.prototype">module utility2.FormData.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData.prototype.append">
            function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>append
            <span class="apidocSignatureSpan">(name, value, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.FormData.prototype.read">
            function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>read
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.Module">module utility2.Module</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.Module">
            function <span class="apidocSignatureSpan">utility2.</span>Module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.SourceMap">
            function <span class="apidocSignatureSpan">utility2.Module.</span>SourceMap
            <span class="apidocSignatureSpan">(payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._debug">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_debug
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._findPath">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_findPath
            <span class="apidocSignatureSpan">(request, paths, isMain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._initPaths">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_initPaths
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._load">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_load
            <span class="apidocSignatureSpan">(request, parent, isMain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._nodeModulePaths">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_nodeModulePaths
            <span class="apidocSignatureSpan">(from)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._preloadModules">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_preloadModules
            <span class="apidocSignatureSpan">(requests)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._resolveFilename">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveFilename
            <span class="apidocSignatureSpan">(request, parent, isMain, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module._resolveLookupPaths">
            function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveLookupPaths
            <span class="apidocSignatureSpan">(request, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.createRequire">
            function <span class="apidocSignatureSpan">utility2.Module.</span>createRequire
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.createRequireFromPath">
            function <span class="apidocSignatureSpan">utility2.Module.</span>createRequireFromPath
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.findSourceMap">
            function <span class="apidocSignatureSpan">utility2.Module.</span>findSourceMap
            <span class="apidocSignatureSpan">(uri, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.runMain">
            function <span class="apidocSignatureSpan">utility2.Module.</span>runMain
            <span class="apidocSignatureSpan">(main = process.argv[1])</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.syncBuiltinESMExports">
            function <span class="apidocSignatureSpan">utility2.Module.</span>syncBuiltinESMExports
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>_cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>_extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>_pathCache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>builtinModules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.Module.</span>globalPaths</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.Module._extensions">module utility2.Module._extensions</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.Module.prototype">module utility2.Module.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.prototype._compile">
            function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>_compile
            <span class="apidocSignatureSpan">(content, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.prototype.load">
            function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>load
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.Module.prototype.require">
            function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>require
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2._http">module utility2._http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._http.createServer">
            function <span class="apidocSignatureSpan">utility2._http.</span>createServer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2._http.request">
            function <span class="apidocSignatureSpan">utility2._http.</span>request
            <span class="apidocSignatureSpan">(xhr, onResponse)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2._http.</span>STATUS_CODES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.apidoc">module utility2.apidoc</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.apidoc.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.apidoc.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.apidocCreate">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.apidocModuleDictAdd">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocModuleDictAdd
            <span class="apidocSignatureSpan">(opt, moduleDict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.assert">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.cliRun">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.coalesce">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.events">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>events
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.fsReadFileOrDefaultSync">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsReadFileOrDefaultSync
            <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(pathname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(pathname, data, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.identity">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.moduleDirname">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>moduleDirname
            <span class="apidocSignatureSpan">(module, pathList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.nop">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.stream">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>stream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.stringHtmlSafe">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>stringHtmlSafe
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.templateRender">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>templateRender
            <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.tryCatchOnError">
            function <span class="apidocSignatureSpan">utility2.apidoc.</span>tryCatchOnError
            <span class="apidocSignatureSpan">(fnc, onError)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>apidoc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>_debugTryCatchError</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.apidoc.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.apidoc.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.apidoc.</span>templateApidocHtml</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.apidoc.cliDict">module utility2.apidoc.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.apidoc.cliDict._default">
            function <span class="apidocSignatureSpan">utility2.apidoc.cliDict.</span>_default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.cliDict">module utility2.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.browserTest">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.browserTest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentDelete">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentDelete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentGet">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentGet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentPut">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentPut
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentTouch">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentTouch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoCreate">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoCreate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoDelete">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoDelete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.start">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.cliDict.utility2.testReportCreate">
            function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.testReportCreate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.github_crud">module utility2.github_crud</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.github_crud.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.github_crud.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.ajax">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>ajax
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.assert">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliRun">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.coalesce">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.events">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>events
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.fsReadFileOrDefaultSync">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsReadFileOrDefaultSync
            <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(pathname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(pathname, data, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudAjax">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudAjax
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentDelete">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentDelete
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentGet">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentGet
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentPut">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPut
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentPutFile">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPutFile
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentTouch">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouch
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudContentTouchList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouchList
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreate">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreate
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreateList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreateList
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoDelete">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDelete
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.githubCrudRepoDeleteList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDeleteList
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.gotoNext">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>gotoNext
            <span class="apidocSignatureSpan">(opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.identity">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.nop">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onErrorDefault">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorDefault
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onErrorWithStack">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorWithStack
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onParallel">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallel
            <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.onParallelList">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallelList
            <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.stream">
            function <span class="apidocSignatureSpan">utility2.github_crud.</span>stream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>github_crud</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.github_crud.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.github_crud.</span>__dirname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.github_crud.cliDict">module utility2.github_crud.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.delete">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>delete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.get">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.put">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>put
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.repo_create">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.repo_delete">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_delete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.github_crud.cliDict.touch">
            function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul">module utility2.istanbul</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.__istanbul_module">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>__istanbul_module
            <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.assert">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliRun">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coalesce">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageMerge">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageMerge
            <span class="apidocSignatureSpan">(coverage1 = {}, coverage2 = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.coverageReportCreate">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageReportCreate
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.events">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>events
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.fsReadFileOrDefaultSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsReadFileOrDefaultSync
            <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(pathname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(pathname, data, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.identity">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.instrumentInPackage">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentInPackage
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.instrumentSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentSync
            <span class="apidocSignatureSpan">(code, file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.nop">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.stream">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>stream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.templateRender">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>templateRender
            <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>istanbul</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>__istanbul_path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>escodegen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>esprima</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>estraverse</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>esutils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.</span>__dirname</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.</span>templateCoverageBadgeSvg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.</span>templateCoverageReport</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.Instrumenter">module utility2.istanbul.Instrumenter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.Instrumenter">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.Instrumenter.prototype">module utility2.istanbul.Instrumenter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.arrowBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>arrowBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchIncrementExprAst">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchIncrementExprAst
            <span class="apidocSignatureSpan">(varName, branchIndex, down)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchLocationFor">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchLocationFor
            <span class="apidocSignatureSpan">(name, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchName">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchName
            <span class="apidocSignatureSpan">(type, startLine, pathLocations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.conditionalBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>conditionalBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.convertToBlock">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>convertToBlock
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverExport
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverFunction
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverMetaProperty">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverMetaProperty
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverStatement
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.endIgnore">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>endIgnore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.extractCurrentHint">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>extractCurrentHint
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.filterHints">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>filterHints
            <span class="apidocSignatureSpan">(comments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.findLeaves">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>findLeaves
            <span class="apidocSignatureSpan">(node, accumulator, parent, property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.fixColumnPositions">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>fixColumnPositions
            <span class="apidocSignatureSpan">(coverState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.functionName">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>functionName
            <span class="apidocSignatureSpan">(node, line, location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.getPreamble">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>getPreamble
            <span class="apidocSignatureSpan">(sourceCode, emitUseStrict)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrument">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrument
            <span class="apidocSignatureSpan">(code, filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentASTSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentASTSync
            <span class="apidocSignatureSpan">(program, filename, originalCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentSync">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentSync
            <span class="apidocSignatureSpan">(code, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.isUseStrictExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>isUseStrictExpression
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastFileCoverage">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastFileCoverage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastSourceMap">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastSourceMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.locationsForNodes">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>locationsForNodes
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.logicalExpressionBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>logicalExpressionBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.loopBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>loopBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddSkip">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddSkip
            <span class="apidocSignatureSpan">(branchLocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddType">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddType
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeSkipNode">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeSkipNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.paranoidHandlerCheck">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>paranoidHandlerCheck
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipInit">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipInit
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipLeft">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipLeft
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.splice">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>splice
            <span class="apidocSignatureSpan">(statements, node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.startIgnore">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>startIgnore
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.statementName">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>statementName
            <span class="apidocSignatureSpan">(location, initValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchBranchInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchBranchInjector
            <span class="apidocSignatureSpan">(node, walker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchCaseInjector">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchCaseInjector
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.withBlockConverter">
            function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>withBlockConverter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.cliDict">module utility2.istanbul.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.cover">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>cover
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.instrument">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>instrument
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.report">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>report
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.cliDict.test">
            function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>test
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.escodegen">module utility2.istanbul.escodegen</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>browser</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.escodegen.attachComments">
            function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.escodegen.generate">
            function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>generate
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>FORMAT_DEFAULTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>FORMAT_MINIFY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>Precedence</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.esprima">module utility2.istanbul.esprima</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Node">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Node
            <span class="apidocSignatureSpan">(parser, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Position">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.SourceLocation">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>SourceLocation
            <span class="apidocSignatureSpan">(p, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.TokContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokContext
            <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Token">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Token
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.TokenType">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokenType
            <span class="apidocSignatureSpan">(label, conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.getLineInfo">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>getLineInfo
            <span class="apidocSignatureSpan">(input, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierChar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierChar
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierStart">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierStart
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.isNewLine">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isNewLine
            <span class="apidocSignatureSpan">(code, ecma2019String)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.parse">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parse
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.parseExpressionAt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parseExpressionAt
            <span class="apidocSignatureSpan">(input, pos, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.tokenizer">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokenizer
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>defaultOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>keywordTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>lineBreak</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>lineBreakG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>nonASCIIwhitespace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokContexts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.esprima.Parser.prototype">module utility2.istanbul.esprima.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.adaptDirectivePrologue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>adaptDirectivePrologue
            <span class="apidocSignatureSpan">(statements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.afterTrailingComma">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>afterTrailingComma
            <span class="apidocSignatureSpan">(tokType, notNext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.braceIsBlock">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>braceIsBlock
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.buildBinary">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>buildBinary
            <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.canInsertSemicolon">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>canInsertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExport
            <span class="apidocSignatureSpan">(exports, name, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExpressionErrors">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExpressionErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLVal">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLVal
            <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLocalExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLocalExport
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkParams">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkParams
            <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternErrors">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternExport
            <span class="apidocSignatureSpan">(exports, pat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPropClash">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPropClash
            <span class="apidocSignatureSpan">(prop, propHash, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkUnreserved">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkUnreserved
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkVariableExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkVariableExport
            <span class="apidocSignatureSpan">(exports, decls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkYieldAwaitInDefaultParams">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkYieldAwaitInDefaultParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curPosition">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curPosition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentThisScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentThisScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentVarScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentVarScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.declareName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>declareName
            <span class="apidocSignatureSpan">(name, bindingType, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eat">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eat
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eatContextual">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eatContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.enterScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>enterScope
            <span class="apidocSignatureSpan">(flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.exitScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>exitScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expectContextual">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expectContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNode">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNodeAt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNodeAt
            <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishOp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishOp
            <span class="apidocSignatureSpan">(type, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishToken
            <span class="apidocSignatureSpan">(type, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.fullCharCodeAtPos">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>fullCharCodeAtPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getTokenFromCode">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getTokenFromCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inGeneratorContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inGeneratorContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inNonArrowFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inNonArrowFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initialContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initialContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.insertSemicolon">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>insertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.invalidStringToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>invalidStringToken
            <span class="apidocSignatureSpan">(position, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncProp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncProp
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isContextual">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isDirectiveCandidate">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isDirectiveCandidate
            <span class="apidocSignatureSpan">(statement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isLet">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isLet
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleAssignTarget">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleAssignTarget
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleParamList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleParamList
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.next">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.nextToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseArrowExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseArrowExpression
            <span class="apidocSignatureSpan">(node, params, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseAwait">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseAwait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingAtom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingList
            <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingListItem">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingListItem
            <span class="apidocSignatureSpan">(param)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBlock">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBlock
            <span class="apidocSignatureSpan">(createNewLexicalScope, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBreakContinueStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBreakContinueStatement
            <span class="apidocSignatureSpan">(node, keyword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClass">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClass
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassElement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassElement
            <span class="apidocSignatureSpan">(constructorAllowsSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassId">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassId
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassMethod">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassMethod
            <span class="apidocSignatureSpan">(method, isGenerator, isAsync, allowsDirectSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassSuper">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassSuper
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDebuggerStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDebuggerStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDoStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDoStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDynamicImport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDynamicImport
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseEmptyStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseEmptyStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExport
            <span class="apidocSignatureSpan">(node, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExportSpecifiers">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExportSpecifiers
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprAtom
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprList
            <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOp
            <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOps">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOps
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprSubscripts">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprSubscripts
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpression
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpressionStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpressionStatement
            <span class="apidocSignatureSpan">(node, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFor">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFor
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForIn">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForIn
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunction
            <span class="apidocSignatureSpan">(node, statement, allowExpressionBody, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionBody">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionBody
            <span class="apidocSignatureSpan">(node, isArrowFunction, isMethod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionParams">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionParams
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionStatement
            <span class="apidocSignatureSpan">(node, isAsync, declarationPosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIdent">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIdent
            <span class="apidocSignatureSpan">(liberal, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIfStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIfStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImport">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImport
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImportSpecifiers">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImportSpecifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLabeledStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLabeledStatement
            <span class="apidocSignatureSpan">(node, maybeName, expr, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLiteral">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLiteral
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeAssign">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeAssign
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeConditional">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeConditional
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeDefault">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeDefault
            <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeUnary">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeUnary
            <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMethod">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMethod
            <span class="apidocSignatureSpan">(isGenerator, isAsync, allowDirectSuper)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseNew">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseNew
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseObj">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseObj
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenAndDistinguishExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenAndDistinguishExpression
            <span class="apidocSignatureSpan">(canBeArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenArrowList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenArrowList
            <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenItem">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenItem
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseProperty">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseProperty
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyName
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyValue
            <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseRestBinding">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseRestBinding
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseReturnStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseReturnStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSpread">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSpread
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseStatement
            <span class="apidocSignatureSpan">(context, topLevel, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscript">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscript
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls, maybeAsyncArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscripts">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscripts
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSwitchStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSwitchStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplate">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplate
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplateElement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplateElement
            <span class="apidocSignatureSpan">(ref)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseThrowStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseThrowStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTopLevel">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTopLevel
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTryStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTryStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVar
            <span class="apidocSignatureSpan">(node, isFor, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarId">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarId
            <span class="apidocSignatureSpan">(decl, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarStatement
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWhileStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWhileStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWithStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWithStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseYield">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseYield
            <span class="apidocSignatureSpan">(noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raise">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raise
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raiseRecoverable">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raiseRecoverable
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readCodePoint">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readCodePoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readEscapedChar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readEscapedChar
            <span class="apidocSignatureSpan">(inTemplate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readHexChar">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readHexChar
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInt
            <span class="apidocSignatureSpan">(radix, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInvalidTemplateToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInvalidTemplateToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readNumber">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readNumber
            <span class="apidocSignatureSpan">(startsWithDot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRadixNumber">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRadixNumber
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRegexp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRegexp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readString">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readString
            <span class="apidocSignatureSpan">(quote)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readTmplToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readTmplToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_caret">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_caret
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_dot">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_eq_excl">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_eq_excl
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_lt_gt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_lt_gt
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_mult_modulo_exp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_mult_modulo_exp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_pipe_amp">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_pipe_amp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_plus_min">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_plus_min
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_slash">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_slash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord1">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_alternative">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_alternative
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_classRanges">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_classRanges
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_disjunction">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_disjunction
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAssertion">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAssertion
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtomEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtomEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBackReference">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBackReference
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBracedQuantifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBracedQuantifier
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCControlLetter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCapturingGroup">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCapturingGroup
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClass">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClass
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClassEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClassEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassControlLetter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlLetter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlLetter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalDigits">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalDigits
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedAtom">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedAtom
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedPatternCharacter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatFixedHexDigits">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatFixedHexDigits
            <span class="apidocSignatureSpan">(state, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatGroupName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatGroupName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexDigits">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexDigits
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexEscapeSequence">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatIdentityEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatIdentityEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatInvalidBracedQuantifier
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatKGroupName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatKGroupName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLegacyOctalEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLoneUnicodePropertyNameOrValue
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatOctalDigit">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatOctalDigit
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatPatternCharacters">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatPatternCharacters
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifier
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifierPrefix">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifierPrefix
            <span class="apidocSignatureSpan">(state, noError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierPart
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierStart
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpUnicodeEscapeSequence
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatReverseSolidusAtomEscape
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatSyntaxCharacter">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatSyntaxCharacter
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatTerm">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatTerm
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUncapturingGroup">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUncapturingGroup
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyName">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyName
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValue
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValueExpression
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatZero">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatZero
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_groupSpecifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_groupSpecifier
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_pattern">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_pattern
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameAndValue
            <span class="apidocSignatureSpan">(state, name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameOrValue
            <span class="apidocSignatureSpan">(state, nameOrValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.semicolon">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.shouldParseExportStatement">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>shouldParseExportStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipBlockComment">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipBlockComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipLineComment">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipLineComment
            <span class="apidocSignatureSpan">(startSkip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipSpace">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipSpace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNode">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNodeAt">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNodeAt
            <span class="apidocSignatureSpan">(pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.strictDirective">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>strictDirective
            <span class="apidocSignatureSpan">(start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignable">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignable
            <span class="apidocSignatureSpan">(node, isBinding, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignableList">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignableList
            <span class="apidocSignatureSpan">(exprList, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.treatFunctionsAsVarInScope">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>treatFunctionsAsVarInScope
            <span class="apidocSignatureSpan">(scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.tryReadTemplateToken">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>tryReadTemplateToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.unexpected">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>unexpected
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.updateContext">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>updateContext
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpFlags">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpFlags
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpPattern">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpPattern
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.esprima.Position.prototype">module utility2.istanbul.esprima.Position.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.esprima.Position.prototype.offset">
            function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Position.prototype.</span>offset
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.estraverse">module utility2.istanbul.estraverse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>Controller
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.attachComments">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>attachComments
            <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.cloneEnvironment">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>cloneEnvironment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.replace">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.traverse">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>Syntax</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>VisitorKeys</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>VisitorOption</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.estraverse.Controller.prototype">module utility2.istanbul.estraverse.Controller.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__execute">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__execute
            <span class="apidocSignatureSpan">(callback, element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__initialize">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__initialize
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.break">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>break
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.current">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>current
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.notify">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>notify
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.parents">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>parents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.path">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>path
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.remove">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>remove
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.replace">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>replace
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.skip">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>skip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.traverse">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>traverse
            <span class="apidocSignatureSpan">(root, visitor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.type">
            function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.process">module utility2.istanbul.process</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_exiting</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._debugEnd">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._debugProcess">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugProcess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._fatalException">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_fatalException
            <span class="apidocSignatureSpan">(er, fromPromise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._getActiveHandles">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveHandles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._getActiveRequests">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveRequests
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._kill">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_kill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._linkedBinding">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_linkedBinding
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._rawDebug">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_rawDebug
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._startProfilerIdleNotifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_startProfilerIdleNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._stopProfilerIdleNotifier">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_stopProfilerIdleNotifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process._tickCallback">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_tickCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.abort">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.assert">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.binding">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>binding
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.chdir">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>chdir
            <span class="apidocSignatureSpan">(directory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.cpuUsage">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cpuUsage
            <span class="apidocSignatureSpan">(prevValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.cwd">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cwd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.dlopen">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>dlopen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.emitWarning">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>emitWarning
            <span class="apidocSignatureSpan">(warning, type, code, ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.exit">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>exit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getegid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getegid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.geteuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>geteuid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getgid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getgroups">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgroups
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.getuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getuid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.hasUncaughtExceptionCaptureCallback">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hasUncaughtExceptionCaptureCallback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.hrtime">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hrtime
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.initgroups">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>initgroups
            <span class="apidocSignatureSpan">(user, extraGroup)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.kill">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>kill
            <span class="apidocSignatureSpan">(pid, sig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.memoryUsage">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>memoryUsage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.nextTick">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>nextTick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.openStdin">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>openStdin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.reallyExit">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>reallyExit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.resourceUsage">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>resourceUsage
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setUncaughtExceptionCaptureCallback">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setUncaughtExceptionCaptureCallback
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setegid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setegid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.seteuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>seteuid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setgid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setgroups">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgroups
            <span class="apidocSignatureSpan">(groups)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.setuid">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setuid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.umask">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>umask
            <span class="apidocSignatureSpan">(mask)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.process.uptime">
            function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>uptime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>debugPort</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>pid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">utility2.istanbul.process.</span>ppid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_preload_modules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>allowedNodeEnvironmentFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>argv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>execArgv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>features</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>mainModule</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>moduleLoadList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>release</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>stderr</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>stdin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>stdout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.process.</span>versions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>arch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>argv0</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>execPath</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>platform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>title</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.istanbul.process.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.istanbul.require">module utility2.istanbul.require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require.require">
            function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.istanbul.require.resolve">
            function <span class="apidocSignatureSpan">utility2.istanbul.require.</span>resolve
            <span class="apidocSignatureSpan">(request, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.require.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.require.</span>extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.istanbul.require.</span>main</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint">module utility2.jslint</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.jslint.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.jslint.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.assert">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.cliRun">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.coalesce">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.events">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>events
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.fsReadFileOrDefaultSync">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>fsReadFileOrDefaultSync
            <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(pathname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(pathname, data, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.identity">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintAndPrint">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrint
            <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintAndPrintDir">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrintDir
            <span class="apidocSignatureSpan">(dir, opt, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintAutofix">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAutofix
            <span class="apidocSignatureSpan">(code, file, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintGetColumnLine">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintGetColumnLine
            <span class="apidocSignatureSpan">(code, ii)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslintUtility2">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintUtility2
            <span class="apidocSignatureSpan">(code, ignore, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jslint_export">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jslint_export
            <span class="apidocSignatureSpan">( source = &quot;&quot;, option_object = empty()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.jsonStringifyOrdered">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>jsonStringifyOrdered
            <span class="apidocSignatureSpan">(obj, replacer, space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.nop">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.onErrorWithStack">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>onErrorWithStack
            <span class="apidocSignatureSpan">(onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.onParallel">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>onParallel
            <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.stream">
            function <span class="apidocSignatureSpan">utility2.jslint.</span>stream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>jslint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>CSSLint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>cliDict</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>jslintResult</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.jslint.</span>__dirname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint.CSSLint">module utility2.jslint.CSSLint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>_Reporter
            <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.addFormatter">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addFormatter
            <span class="apidocSignatureSpan">(formatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.addRule">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addRule
            <span class="apidocSignatureSpan">(rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.clearRules">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>clearRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.format">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>format
            <span class="apidocSignatureSpan">(results, filename, formatId, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.getFormatter">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getFormatter
            <span class="apidocSignatureSpan">(formatId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.getRules">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.getRuleset">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRuleset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.hasFormat">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>hasFormat
            <span class="apidocSignatureSpan">(formatId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint.verify">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>verify
            <span class="apidocSignatureSpan">(text, ruleset)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>Util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>_listeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint.CSSLint._Reporter.prototype">module utility2.jslint.CSSLint._Reporter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.constructor">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>constructor
            <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.error">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>error
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.info">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>info
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.report">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>report
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupError">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupError
            <span class="apidocSignatureSpan">(message, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupWarn">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupWarn
            <span class="apidocSignatureSpan">(message, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.stat">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>stat
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.warn">
            function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>warn
            <span class="apidocSignatureSpan">(message, line, col, rule)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.jslint.cliDict">module utility2.jslint.cliDict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.cliDict._default">
            function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>_default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.jslint.cliDict.dir">
            function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>dir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked">module utility2.marked</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.marked">
            function <span class="apidocSignatureSpan">utility2.</span>marked
            <span class="apidocSignatureSpan">(e, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.inlineLexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>inlineLexer
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.lexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>lexer
            <span class="apidocSignatureSpan">(e, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.options">
            function <span class="apidocSignatureSpan">utility2.marked.</span>options
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.parse">
            function <span class="apidocSignatureSpan">utility2.marked.</span>parse
            <span class="apidocSignatureSpan">(e, n, r)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.parser">
            function <span class="apidocSignatureSpan">utility2.marked.</span>parser
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.setOptions">
            function <span class="apidocSignatureSpan">utility2.marked.</span>setOptions
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.marked.</span>defaults</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.InlineLexer">module utility2.marked.InlineLexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.InlineLexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.output">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.</span>output
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.marked.InlineLexer.</span>rules</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.InlineLexer.prototype">module utility2.marked.InlineLexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.mangle">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>mangle
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.output">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>output
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.outputLink">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>outputLink
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.InlineLexer.prototype.smartypants">
            function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>smartypants
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Lexer">module utility2.marked.Lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.Lexer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.lex">
            function <span class="apidocSignatureSpan">utility2.marked.Lexer.</span>lex
            <span class="apidocSignatureSpan">(e, n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.marked.Lexer.</span>rules</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Lexer.prototype">module utility2.marked.Lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.prototype.lex">
            function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>lex
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Lexer.prototype.token">
            function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>token
            <span class="apidocSignatureSpan">(t, n, r)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Parser">module utility2.marked.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.Parser">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.parse">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.</span>parse
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Parser.prototype">module utility2.marked.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.next">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.parseText">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parseText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.peek">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>peek
            <span class="apidocSignatureSpan">( )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Parser.prototype.tok">
            function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>tok
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Renderer">module utility2.marked.Renderer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.Renderer">
            function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.marked.Renderer.prototype">module utility2.marked.Renderer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.blockquote">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>blockquote
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.br">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>br
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.code">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>code
            <span class="apidocSignatureSpan">( e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.codespan">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>codespan
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.del">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>del
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.em">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>em
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.heading">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>heading
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.hr">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>hr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.html">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>html
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.image">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>image
            <span class="apidocSignatureSpan">(e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.link">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>link
            <span class="apidocSignatureSpan">( e, t, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.list">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>list
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.listitem">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>listitem
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.paragraph">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>paragraph
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.strong">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>strong
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.table">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>table
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.tablecell">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablecell
            <span class="apidocSignatureSpan">(e, t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.tablerow">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablerow
            <span class="apidocSignatureSpan">( e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.marked.Renderer.prototype.text">
            function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>text
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.puppeteer">module utility2.puppeteer</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.puppeteer.</span>isBrowser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">utility2.puppeteer.</span>isWebWorker</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.assert">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assert
            <span class="apidocSignatureSpan">(...args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.assertOrThrow">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assertOrThrow
            <span class="apidocSignatureSpan">(passed, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.cliRun">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>cliRun
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.coalesce">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>coalesce
            <span class="apidocSignatureSpan">(...argList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.events">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>events
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.fsReadFileOrDefaultSync">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsReadFileOrDefaultSync
            <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.fsRmrfSync">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsRmrfSync
            <span class="apidocSignatureSpan">(pathname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.fsWriteFileWithMkdirpSync">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsWriteFileWithMkdirpSync
            <span class="apidocSignatureSpan">(pathname, data, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.identity">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>identity
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.nop">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>nop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.objectAssignDefault">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>objectAssignDefault
            <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerLaunch">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>puppeteerLaunch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.stream">
            function <span class="apidocSignatureSpan">utility2.puppeteer.</span>stream
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.</span>puppeteer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>_puppeteer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>child_process</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>cluster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>dgram</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>dns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>https</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>local</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>net</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>os</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>puppeteerApi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>querystring</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>readline</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>repl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>string_decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>timers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>tls</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>tty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>vm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.</span>zlib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">utility2.puppeteer.</span>__dirname</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.utility2.puppeteer.puppeteerApi">module utility2.puppeteer.puppeteerApi</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Accessibility">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Accessibility
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Browser">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Browser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.BrowserContext">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>BrowserContext
            <span class="apidocSignatureSpan">(connection, browser, contextId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.CDPSession">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>CDPSession
            <span class="apidocSignatureSpan">(connection, targetType, sessionId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ConsoleMessage">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ConsoleMessage
            <span class="apidocSignatureSpan">(type, text, args, location = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Coverage">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Coverage
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Dialog">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Dialog
            <span class="apidocSignatureSpan">(string|undefined)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ElementHandle">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ElementHandle
            <span class="apidocSignatureSpan">(context, client, remoteObject, page, frameManager)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ExecutionContext">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ExecutionContext
            <span class="apidocSignatureSpan">(client, contextPayload, world)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.FileChooser">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>FileChooser
            <span class="apidocSignatureSpan">(client, event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Frame">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Frame
            <span class="apidocSignatureSpan">(frameManager, client, parentFrame, frameId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.JSHandle">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>JSHandle
            <span class="apidocSignatureSpan">(context, client, remoteObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Keyboard">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Keyboard
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Mouse">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Mouse
            <span class="apidocSignatureSpan">(client, keyboard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Page">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Page
            <span class="apidocSignatureSpan">(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Puppeteer">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Puppeteer
            <span class="apidocSignatureSpan">(projectRoot, preferredRevision, isPuppeteerCore)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Request">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Request
            <span class="apidocSignatureSpan">(client, frame, interceptionId, allowInterception, event, redirectChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Response">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Response
            <span class="apidocSignatureSpan">(client, request, responsePayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.SecurityDetails">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>SecurityDetails
            <span class="apidocSignatureSpan">(securityPayload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Target">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Target
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.TimeoutError">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>TimeoutError
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Touchscreen">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Touchscreen
            <span class="apidocSignatureSpan">(client, keyboard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Tracing">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Tracing
            <span class="apidocSignatureSpan">(client)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Worker">
            function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Worker
            <span class="apidocSignatureSpan">(string, !Array&lt;!JSHandle&gt;, Protocol.Runtime.StackTrace=)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>BrowserFetcher</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2" id="apidoc.module.utility2">module utility2</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.Blob" id="apidoc.elem.utility2.Blob">
        function <span class="apidocSignatureSpan">utility2.</span>Blob
        <span class="apidocSignatureSpan">(list, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Blob = function (list, opt) {
<span class="apidocCodeCommentSpan">    /*
     * this function will emulate in node, browser&apos;s Blob class
     * https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob
     */
</span>    this.buf = local.bufferConcat(list.map(function (elem) {
        if (
            typeof elem === &quot;string&quot;
            || Object.prototype.toString.call(elem) === &quot;[object Uint8Array]&quot;
        ) {
            return elem;
        }
        // emulate in node, browser-behavior - auto-stringify arbitrary data
        return String(elem);
    }));
    this.type = (opt &amp;&amp; opt.type) || &quot;&quot;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// run shared js-env code - function
(function () {
local.testCase_FormData_default = function (opt, onError) {
/*
* this function will test FormData&apos;s default handling-behavior
*/
   opt = {};
   opt.blob1 = new local.<span class="apidocCodeKeywordSpan">Blob</span>([
       &quot;aa&quot;, &quot;bb&quot;, local.stringHelloEmoji, 0
   ]);
   opt.blob2 = new local.Blob([
       &quot;aa&quot;, &quot;bb&quot;, local.stringHelloEmoji, 0
   ], {
       type: &quot;text/plain; charset=utf-8&quot;
   });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.FormData" id="apidoc.elem.utility2.FormData">
        function <span class="apidocSignatureSpan">utility2.</span>FormData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FormData = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a serverLocal-compatible FormData instance
 * The FormData(form) constructor must run these steps:
 * 1. Let fd be a new FormData object.
 * 2. If form is given, set fd&apos;s entries to the result
 *    of constructing the form data set for form. (not implemented)
 * 3. Return fd.
 * https://xhr.spec.whatwg.org/#dom-formdata
 */
</span>    this.entryList = [];
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
})[0];
// init default
local.objectSetDefault(opt, {
    inForm: (
        that._consumes0 === &quot;multipart/form-data&quot;
        ? new local.<span class="apidocCodeKeywordSpan">FormData</span>()
        : &quot;&quot;
    ),
    inHeader: {},
    inPath: that._path.replace((
        /#.*?$/
    ), &quot;&quot;),
    inQuery: &quot;&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module" id="apidoc.elem.utility2.Module">
        function <span class="apidocSignatureSpan">utility2.</span>Module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// init example.js
tmp = local.path.resolve(&quot;example.js&quot;);
// jslint code
local.jslintAndPrint(code, tmp);
// instrument code
code = local.istanbulInstrumentInPackage(code, tmp);
// init module.exports
module = new local.<span class="apidocCodeKeywordSpan">Module</span>(tmp);
require.cache[tmp] = module;
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
    globalThis.utility2_moduleExports
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildApidoc_default" id="apidoc.elem.utility2._testCase_buildApidoc_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApidoc_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildApidoc_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildApidoc&apos;s default handling-behavior
 */
</span>    let require2;
    require2 = function (file) {
    /*
     * this function will require &lt;file&gt; in sandbox-env
     */
        let exports;
        let mockDict;
        let mockList;
        mockList = [
            [
                globalThis, {
                    setImmediate: local.nop,
                    setInterval: local.nop,
                    setTimeout: local.nop
                }
            ]
        ];
        [
            [
                local, &quot;child_process&quot;
            ], [
                local, &quot;cluster&quot;
            ], [
                local, &quot;http&quot;
            ], [
                local, &quot;https&quot;
            ], [
                local, &quot;net&quot;
            ], [
                local, &quot;repl&quot;
            ], [
                local.events, &quot;prototype&quot;
            ], [
                globalThis, &quot;process&quot;
            ], [
                local.stream, &quot;prototype&quot;
            ], [
                process, &quot;stdin&quot;
            ]
        ].forEach(function (elem, tmp) {
            tmp = elem[0][elem[1]];
            mockDict = {};
            Object.keys(tmp).forEach(function (key) {
                if (typeof tmp[key] === &quot;function&quot; &amp;&amp; !(
                    /^(?:fs\.Read|fs\.read|process\.binding|process\.dlopen)/
                ).test(elem[1] + &quot;.&quot; + key)) {
                    mockDict[key] = function () {
                        return;
                    };
                }
            });
            mockList.push([
                tmp, mockDict
            ]);
        });
        local.testMock(mockList, function (onError) {
            local.tryCatchOnError(function () {
                exports = require(file);
            }, local.onErrorDefault);
            onError();
        }, local.onErrorThrow);
        return exports;
    };
    if (
        local.isBrowser
        || local.env.npm_config_mode_coverage
        || local.env.npm_config_mode_test_case
        !== &quot;testCase_buildApidoc_default&quot;
    ) {
        onError(undefined, opt);
        return;
    }
    // save apidoc.html
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/apidoc.html&quot;,
        local.apidocCreate(local.objectAssignDefault(opt, {
            blacklistDict: local,
            require: require2
        })),
        &quot;wrote file apidoc - {{pathname}}&quot;
    );
    onError();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   onError(undefined, opt);
};

local.testCase_buildApidoc_default = function (opt, onError) {
/*
* this function will test buildApidoc&apos;s default handling-behavior
*/
   local.<span class="apidocCodeKeywordSpan">_testCase_buildApidoc_default</span>({
       blacklistDict: {}
   }, onError, opt);
};

local.testCase_buildApp_default = function (opt, onError) {
/*
* this function will test buildApp&apos;s default handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildApp_default" id="apidoc.elem.utility2._testCase_buildApp_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildApp_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildApp_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildApp&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    globalThis.local.testCase_buildReadme_default(opt, local.onErrorThrow);
    globalThis.local.testCase_buildLib_default(opt, local.onErrorThrow);
    globalThis.local.testCase_buildTest_default(opt, local.onErrorThrow);
    local.buildApp(opt, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            testCase_buildReadme_default: local.nop,
            testCase_buildLib_default: local.nop,
            testCase_buildTest_default: local.nop
        }
    ]
], function (onError) {
    local._testCase_buildApidoc_default({}, local.nop);
    local.<span class="apidocCodeKeywordSpan">_testCase_buildApp_default</span>({}, local.nop);
    local._testCase_buildLib_default({}, local.nop);
    local._testCase_buildReadme_default({}, local.nop);
    local._testCase_buildTest_default({}, local.nop);
    local._testCase_webpage_default({}, local.nop);
    local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
    local._testCase_webpage_default({}, local.nop);
    onError(undefined, opt);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildLib_default" id="apidoc.elem.utility2._testCase_buildLib_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildLib_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildLib_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildLib&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildLib({}, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            testCase_buildLib_default: local.nop,
            testCase_buildTest_default: local.nop
        }
    ]
], function (onError) {
    local._testCase_buildApidoc_default({}, local.nop);
    local._testCase_buildApp_default({}, local.nop);
    local.<span class="apidocCodeKeywordSpan">_testCase_buildLib_default</span>({}, local.nop);
    local._testCase_buildReadme_default({}, local.nop);
    local._testCase_buildTest_default({}, local.nop);
    local._testCase_webpage_default({}, local.nop);
    local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
    local._testCase_webpage_default({}, local.nop);
    onError(undefined, opt);
}, onError);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildReadme_default" id="apidoc.elem.utility2._testCase_buildReadme_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildReadme_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildReadme_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildReadme&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildReadme({}, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
                testCase_buildTest_default: local.nop
            }
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default({}, local.nop);
        local._testCase_buildApp_default({}, local.nop);
        local._testCase_buildLib_default({}, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_buildReadme_default</span>({}, local.nop);
        local._testCase_buildTest_default({}, local.nop);
        local._testCase_webpage_default({}, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default({}, local.nop);
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_buildTest_default" id="apidoc.elem.utility2._testCase_buildTest_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_buildTest_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_buildTest_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test buildTest&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    return local.buildTest({}, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            }
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default({}, local.nop);
        local._testCase_buildApp_default({}, local.nop);
        local._testCase_buildLib_default({}, local.nop);
        local._testCase_buildReadme_default({}, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_buildTest_default</span>({}, local.nop);
        local._testCase_webpage_default({}, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default({}, local.nop);
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._testCase_webpage_default" id="apidoc.elem.utility2._testCase_webpage_default">
        function <span class="apidocSignatureSpan">utility2.</span>_testCase_webpage_default
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_testCase_webpage_default = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will test webpage&apos;s default handling-behavior
 */
</span>    if (local.isBrowser) {
        onError(undefined, opt);
        return;
    }
    local.domStyleValidate();
    local.browserTest({
        fileScreenshot: (
            local.env.npm_config_dir_build
            + &quot;/screenshot.&quot; + local.env.MODE_BUILD + &quot;.browser.%2F.png&quot;
        ),
        url: (
            local.serverLocalHost
            + &quot;/?modeTest=1&amp;timeoutDefault=&quot; + local.timeoutDefault
            + &quot;&amp;modeTestCase=&quot; + local.modeTestCase.replace((
                /_?testCase_webpage_default/
            ), &quot;&quot;)
        )
    }, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        ]
    ], function (onError) {
        local._testCase_buildApidoc_default({}, local.nop);
        local._testCase_buildApp_default({}, local.nop);
        local._testCase_buildLib_default({}, local.nop);
        local._testCase_buildReadme_default({}, local.nop);
        local._testCase_buildTest_default({}, local.nop);
        local.<span class="apidocCodeKeywordSpan">_testCase_webpage_default</span>({}, local.nop);
        local.assetsDict[&quot;/&quot;] = &quot;&lt;script src=\&quot;assets.test.js\&quot;&gt;&lt;/script&gt;&quot;;
        local._testCase_webpage_default({}, local.nop);
        onError(undefined, opt);
    }, onError);
};

local.testCase_childProcessSpawnWithTimeout_default = function (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.ajax" id="apidoc.elem.utility2.ajax">
        function <span class="apidocSignatureSpan">utility2.</span>ajax
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send an ajax-req
 * with given &lt;opt&gt;.url and callback &lt;onError&gt;
 * with err and timeout handling
 * example use:
    local.ajax({
        data: &quot;hello world&quot;,
        header: {&quot;x-header-hello&quot;: &quot;world&quot;},
        method: &quot;POST&quot;,
        url: &quot;/index.html&quot;
    }, function (err, xhr) {
        console.log(xhr.statusCode);
        console.log(xhr.responseText);
    });
 */
</span>    let ajaxProgressUpdate;
    let bufferValidateAndCoerce;
    let isDone;
    let local2;
    let onError2;
    let onEvent;
    let stack;
    let streamCleanup;
    let timeout;
    let tmp;
    let xhr;
    let xhrInit;
    // init local2
    local2 = opt.local2 || local.utility2 || {};
    // init function
    ajaxProgressUpdate = local2.ajaxProgressUpdate || function () {
        return;
    };
    bufferValidateAndCoerce = local2.bufferValidateAndCoerce || function (
        buf,
        mode
    ) {
    /*
     * this function will validate and coerce/convert
     * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
     */
        // coerce ArrayBuffer to Buffer
        if (Object.prototype.toString.call(buf) === &quot;[object ArrayBuffer]&quot;) {
            buf = new Uint8Array(buf);
        }
        // convert Buffer to utf8
        if (mode === &quot;string&quot; &amp;&amp; typeof buf !== &quot;string&quot;) {
            buf = String(buf);
        }
        return buf;
    };
    onEvent = function (evt) {
    /*
     * this function will handle events
     */
        if (Object.prototype.toString.call(evt) === &quot;[object Error]&quot;) {
            xhr.err = xhr.err || evt;
            xhr.onEvent({
                type: &quot;error&quot;
            });
            return;
        }
        // init statusCode
        xhr.statusCode = (xhr.statusCode || xhr.status) | 0;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
        case &quot;load&quot;:
            if (isDone) {
                return;
            }
            isDone = true;
            // decrement cnt
            ajaxProgressUpdate.cnt = Math.max(
                ajaxProgressUpdate.cnt - 1,
                0
            );
            ajaxProgressUpdate();
            // handle abort or err event
            switch (!xhr.err &amp;&amp; evt.type) {
            case &quot;abort&quot;:
            case &quot;error&quot;:
                xhr.err = new Error(&quot;ajax - event &quot; + evt.type);
                break;
            case &quot;load&quot;:
                if (xhr.statusCode &gt;= 400) {
                    xhr.err = new Error(
                        &quot;ajax - statusCode &quot; + xhr.statusCode
                    );
                }
                break;
            }
            // debug statusCode / method / url
            if (xhr.err) {
                xhr.statusCode = xhr.statusCode || 500;
                xhr.err.statusCode = xhr.statusCode;
                tmp = (
                    (
                        local.isBrowser
                        ? &quot;browser&quot;
                        : &quot;node&quot;
                    )
                    + &quot; - &quot; + xhr.statusCode + &quot; &quot; + xhr.method + &quot; &quot; + xhr.url
                    + &quot;\n&quot;
                );
                xhr.err.message = tmp + xhr.err.message;
                xhr.err.stack = tmp + xhr.err.stack;
            }
            // update resHeaders
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
            if (xhr.getAllResponseHeaders) {
                xhr.getAllResponseHeaders().replace((
                    /(.*?):\u0020*(.*?)\r\n/g
                ), function (ignore, key, val) {
                    xhr.resHeaders[key.toLowerCase()] = val;
                });
            }
            // debug ajaxResponse
            xhr.resContentLength = (...</pre></li>
    <li>example use<pre class="apidocCodePre">...
/* validateLineSortedReset */
local.ajax = function (opt, onError) {
/*
* this function will send an ajax-req
* with given &lt;opt&gt;.url and callback &lt;onError&gt;
* with err and timeout handling
* example use:
   local.<span class="apidocCodeKeywordSpan">ajax</span>({
       data: &quot;hello world&quot;,
       header: {&quot;x-header-hello&quot;: &quot;world&quot;},
       method: &quot;POST&quot;,
       url: &quot;/index.html&quot;
   }, function (err, xhr) {
       console.log(xhr.statusCode);
       console.log(xhr.responseText);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.ajaxProgressUpdate" id="apidoc.elem.utility2.ajaxProgressUpdate">
        function <span class="apidocSignatureSpan">utility2.</span>ajaxProgressUpdate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajaxProgressUpdate = function () {
    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    ) {
        return;
    }
    // test-run
    globalThis.utility2_modeTest += 1;
}
// visual notification - testRun
local.<span class="apidocCodeKeywordSpan">ajaxProgressUpdate</span>();
// mock console.error
consoleError = console.error;
isCoverage = (
    typeof globalThis.__coverage__ === &quot;object&quot; &amp;&amp; globalThis.__coverage__
    &amp;&amp; Object.keys(globalThis.__coverage__).length
);
console.error = function (...argList) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidocCreate" id="apidoc.elem.utility2.apidocCreate">
        function <span class="apidocSignatureSpan">utility2.</span>apidocCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apidocCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create the apidoc from &lt;opt&gt;.dir
 */
</span>    let elemCreate;
    let module;
    let moduleMain;
    let readExample;
    let tmp;
    let toString;
    let trimStart;
    elemCreate = function (module, prefix, key) {
    /*
     * this function will create the apidoc-elem in given &lt;module&gt;
     */
        let elem;
        if (opt.modeNoApidoc) {
            return elem;
        }
        elem = {};
        elem.moduleName = prefix.split(&quot;.&quot;);
        // handle case where module is a function
        if (elem.moduleName.slice(-1)[0] === key) {
            elem.moduleName.pop();
        }
        elem.moduleName = elem.moduleName.join(&quot;.&quot;);
        elem.id = encodeURIComponent(&quot;apidoc.elem.&quot; + prefix + &quot;.&quot; + key);
        elem.typeof = typeof module[key];
        elem.name = (
            elem.typeof + &quot; &lt;span class=\&quot;apidocSignatureSpan\&quot;&gt;&quot;
            + elem.moduleName + &quot;.&lt;/span&gt;&quot; + key
        );
        // handle case where module is a function
        elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
        if (elem.typeof !== &quot;function&quot;) {
            return elem;
        }
        // init source
        elem.source = local.stringHtmlSafe(
            trimStart(toString(module[key])) || &quot;n/a&quot;
        ).replace((
            /\([\S\s]*?\)/
        ), function (match0) {
            // init signature
            elem.signature = match0.replace((
                /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
            ), &quot;&quot;).replace((
                /,/g
            ), &quot;, &quot;).replace((
                /\s+/g
            ), &quot; &quot;);
            return elem.signature;
        }).replace((
            /(\u0020*?\/\*[\S\s]*?\*\/\n)/
        ), &quot;&lt;span class=\&quot;apidocCodeCommentSpan\&quot;&gt;$1&lt;/span&gt;&quot;).replace((
            /^function\u0020\(/
        ), key + &quot; = function (&quot;);
        // init example
        opt.exampleList.some(function (example) {
            example.replace(
                new RegExp(&quot;((?:\n.*?){8}\\.)(&quot; + key + &quot;)(\\((?:.*?\n){8})&quot;),
                function (ignore, match1, match2, match3) {
                    elem.example = &quot;...&quot; + trimStart(
                        local.stringHtmlSafe(match1)
                        + &quot;&lt;span class=\&quot;apidocCodeKeywordSpan\&quot;&gt;&quot;
                        + local.stringHtmlSafe(match2)
                        + &quot;&lt;/span&gt;&quot;
                        + local.stringHtmlSafe(match3)
                    ).trimEnd() + &quot;\n...&quot;;
                    return &quot;&quot;;
                }
            );
            return elem.example;
        });
        elem.example = elem.example || &quot;n/a&quot;;
        return elem;
    };
    readExample = function (file) {
    /*
     * this function will read the example from given file
     */
        let result;
        local.tryCatchOnError(function () {
            file = local.path.resolve(opt.dir, file);
            console.error(&quot;apidocCreate - readExample &quot; + file);
            result = &quot;&quot;;
            result = local.identity(
                &quot;\n\n\n\n\n\n\n\n&quot;
                // bug-workaround - truncate example to manageable size
                + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
                + &quot;\n\n\n\n\n\n\n\n&quot;
            ).replace((
                /\r\n*/g
            ), &quot;\n&quot;);
        }, console.error);
        return result;
    };
    toString = function (value) {
    /*
     * this function will try to return the string form of the value
     */
        let result;
        local.tryCatchOnError(function () {
            result = &quot;&quot;;
            result = String(value);
        }, console.error);
        return result;
    };
    trimStart = function (str) {
    /*...</pre></li>
    <li>example use<pre class="apidocCodePre">...

local.cliDict._default = function () {
/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
    // jslint files
    process.stdout.write(local.<span class="apidocCodeKeywordSpan">apidocCreate</span>({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assert" id="apidoc.elem.utility2.assert">
        function <span class="apidocSignatureSpan">utility2.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assertJsonEqual" id="apidoc.elem.utility2.assertJsonEqual">
        function <span class="apidocSignatureSpan">utility2.</span>assertJsonEqual
        <span class="apidocSignatureSpan">(aa, bb, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertJsonEqual = function (aa, bb, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will assert jsonStringifyOrdered(&lt;aa&gt;) === JSON.stringify(&lt;bb&gt;)
 */
</span>    aa = local.jsonStringifyOrdered(aa);
    bb = JSON.stringify(bb);
    local.assertOrThrow(aa === bb, message || [
        aa, bb
    ]);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    // test http GET handling-behavior
    local.ajax({
        url: &quot;assets.hello.txt&quot;
    }, opt.gotoNext);
    break;
case 2:
    // validate responseText
    local.<span class="apidocCodeKeywordSpan">assertJsonEqual</span>(data.responseText, local.stringHelloEmoji);
    // test http GET 304 cache handling-behavior
    local.ajax({
        headers: {
            &quot;If-Modified-Since&quot;: (
                new Date(Date.now() + 0xffff).toUTCString()
            )
        },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assertJsonNotEqual" id="apidoc.elem.utility2.assertJsonNotEqual">
        function <span class="apidocSignatureSpan">utility2.</span>assertJsonNotEqual
        <span class="apidocSignatureSpan">(aa, bb, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertJsonNotEqual = function (aa, bb, message) {
<span class="apidocCodeCommentSpan">/*
 * this function will assert jsonStringifyOrdered(&lt;aa&gt;) !== JSON.stringify(&lt;bb&gt;)
 */
</span>    aa = local.jsonStringifyOrdered(aa);
    bb = JSON.stringify(bb);
    local.assertOrThrow(aa !== bb, [
        aa
    ], message || aa);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;&quot;, 0, false, null, undefined
        ].forEach(function (bb, jj) {
            if (ii === jj) {
                // test assertJsonEqual&apos;s handling-behavior
                local.assertJsonEqual(aa, bb);
            } else {
                // test assertJsonNotEqual&apos;s handling-behavior
                local.<span class="apidocCodeKeywordSpan">assertJsonNotEqual</span>(aa, bb);
            }
        });
    });
    onError(undefined, opt);
};

local.testCase_base64Xxx_default = function (opt, onError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.assertOrThrow" id="apidoc.elem.utility2.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;msg&gt; if &lt;passed&gt; is falsy
 */
</span>    if (passed) {
        return;
    }
    throw (
        (
            msg
            &amp;&amp; typeof msg.message === &quot;string&quot;
            &amp;&amp; typeof msg.stack === &quot;string&quot;
        )
        // if msg is err, then leave as is
        ? msg
        : new Error(
            typeof msg === &quot;string&quot;
            // if msg is a string, then leave as is
            ? msg
            // else JSON.stringify msg
            : JSON.stringify(msg, undefined, 4)
        )
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(str).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.base64FromBuffer" id="apidoc.elem.utility2.base64FromBuffer">
        function <span class="apidocSignatureSpan">utility2.</span>base64FromBuffer
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64FromBuffer = function (buf) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert Uint8Array &lt;buf&gt; to base64 str
 */
</span>    let ii;
    let mod3;
    let str;
    let uint24;
    let uint6ToB64;
    // convert utf8 to Uint8Array
    if (typeof buf === &quot;string&quot;) {
        buf = new TextEncoder().encode(buf);
    }
    buf = buf || [];
    str = &quot;&quot;;
    uint24 = 0;
    uint6ToB64 = function (uint6) {
        return (
            uint6 &lt; 26
            ? uint6 + 65
            : uint6 &lt; 52
            ? uint6 + 71
            : uint6 &lt; 62
            ? uint6 - 4
            : uint6 === 62
            ? 43
            : 47
        );
    };
    ii = 0;
    while (ii &lt; buf.length) {
        mod3 = ii % 3;
        uint24 |= buf[ii] &lt;&lt; (16 &gt;&gt;&gt; mod3 &amp; 24);
        if (mod3 === 2 || buf.length - ii === 1) {
            str += String.fromCharCode(
                uint6ToB64(uint24 &gt;&gt;&gt; 18 &amp; 63),
                uint6ToB64(uint24 &gt;&gt;&gt; 12 &amp; 63),
                uint6ToB64(uint24 &gt;&gt;&gt; 6 &amp; 63),
                uint6ToB64(uint24 &amp; 63)
            );
            uint24 = 0;
        }
        ii += 1;
    }
    return str.replace((
        /A(?=A$|$)/gm
    ), &quot;&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    ? &quot;abcd1234&quot;
    : Number(
        (1 + Math.random()) * 0x10000000000000
    ).toString(36).slice(1)
);
switch (schemaP.format) {
case &quot;byte&quot;:
    value = local.<span class="apidocCodeKeywordSpan">base64FromBuffer</span>(value);
    break;
case &quot;date&quot;:
case &quot;date-time&quot;:
    value = new Date().toISOString();
    break;
case &quot;email&quot;:
    value = value + &quot;@example.com&quot;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.base64ToBuffer" id="apidoc.elem.utility2.base64ToBuffer">
        function <span class="apidocSignatureSpan">utility2.</span>base64ToBuffer
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64ToBuffer = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert base64 &lt;str&gt; to Uint8Array
 * https://gist.github.com/wang-bin/7332335
 */
</span>    let buf;
    let byte;
    let chr;
    let ii;
    let jj;
    let map64;
    let mod4;
    str = str || &quot;&quot;;
    buf = new Uint8Array(str.length); // 3/4
    byte = 0;
    jj = 0;
    map64 = (
        !(str.indexOf(&quot;-&quot;) &lt; 0 &amp;&amp; str.indexOf(&quot;_&quot;) &lt; 0)
        // base64url
        ? &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;
        // base64
        : &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;
    );
    mod4 = 0;
    ii = 0;
    while (ii &lt; str.length) {
        chr = map64.indexOf(str[ii]);
        if (chr !== -1) {
            mod4 %= 4;
            if (mod4 === 0) {
                byte = chr;
            } else {
                byte = byte * 64 + chr;
                buf[jj] = 255 &amp; (byte &gt;&gt; ((-2 * (mod4 + 1)) &amp; 6));
                jj += 1;
            }
            mod4 += 1;
        }
        ii += 1;
    }
    // optimization - create resized-view of buf
    return buf.subarray(0, jj);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (!data) {
        local.serverRespondDefault(req, res, 404);
        return;
    }
    local.serverRespondHeadSet(req, res, null, {
        &quot;Content-Type&quot;: data.fileContentType
    });
    res.end(local.<span class="apidocCodeKeywordSpan">base64ToBuffer</span>(data.fileBlob));
    break;
case &quot;userLogout&quot;:
    opt.gotoNext();
    break;
default:
    opt.gotoNext(null, data, meta);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.base64ToUtf8" id="apidoc.elem.utility2.base64ToUtf8">
        function <span class="apidocSignatureSpan">utility2.</span>base64ToUtf8
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64ToUtf8 = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert base64 &lt;str&gt; to utf8 str
 */
</span>    return local.bufferValidateAndCoerce(local.base64ToBuffer(str), &quot;string&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
opt = {};
opt.base64 = local.base64FromBuffer(
    local.stringCharsetAscii + local.stringHelloEmoji
);
// test null-case handling-behavior
local.assertJsonEqual(local.base64FromBuffer(), &quot;&quot;);
local.assertJsonEqual(local.bufferToUtf8(local.base64ToBuffer()), &quot;&quot;);
local.assertJsonEqual(local.<span class="apidocCodeKeywordSpan">base64ToUtf8</span>(), &quot;&quot;);
local.assertJsonEqual(local.base64FromBuffer(local.base64ToBuffer()), &quot;&quot;);
local.assertJsonEqual(local.base64FromBuffer(local.base64ToUtf8()), &quot;&quot;);
// test identity handling-behavior
local.assertJsonEqual(
    local.base64FromBuffer(local.base64ToBuffer(opt.base64)),
    opt.base64
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.base64urlFromBuffer" id="apidoc.elem.utility2.base64urlFromBuffer">
        function <span class="apidocSignatureSpan">utility2.</span>base64urlFromBuffer
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base64urlFromBuffer = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert base64url &lt;str&gt; to Uint8Array
 */
</span>    return local.base64FromBuffer(str).replace((
        /\+/g
    ), &quot;-&quot;).replace((
        /\//g
    ), &quot;_&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.blobRead" id="apidoc.elem.utility2.blobRead">
        function <span class="apidocSignatureSpan">utility2.</span>blobRead
        <span class="apidocSignatureSpan">(blob, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blobRead = function (blob, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will read from &lt;blob&gt;
 */
</span>    let isDone;
    let reader;
    if (blob &amp;&amp; blob.constructor &amp;&amp; blob.constructor === local.FormData) {
        blob.read(onError);
        return;
    }
    if (!local.isBrowser) {
        onError(undefined, local.bufferValidateAndCoerce(blob.buf));
        return;
    }
    reader = new FileReader();
    reader.onabort = function (evt) {
        if (isDone) {
            return;
        }
        isDone = true;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
            onError(new Error(&quot;blobRead - &quot; + evt.type));
            break;
        case &quot;load&quot;:
            onError(
                undefined,
                Object.prototype.toString.call(reader.result)
                === &quot;[object ArrayBuffer]&quot;
                // convert ArrayBuffer to Uint8Array
                ? new Uint8Array(reader.result)
                : reader.result
            );
            break;
        }
    };
    reader.onerror = reader.onabort;
    reader.onload = reader.onabort;
    reader.readAsArrayBuffer(blob);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
switch ((xhr.data &amp;&amp; xhr.data.constructor) || true) {
// Blob
// https://developer.mozilla.org/en-US/docs/Web/API/Blob
case local2.Blob:
// FormData
// https://developer.mozilla.org/en-US/docs/Web/API/FormData
case local2.FormData:
    local2.<span class="apidocCodeKeywordSpan">blobRead</span>(xhr.data, function (err, data) {
        if (err) {
            xhr.onEvent(err);
            return;
        }
        // send data
        xhr.send(data);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.browserTest" id="apidoc.elem.utility2.browserTest">
        function <span class="apidocSignatureSpan">utility2.</span>browserTest
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">browserTest = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will spawn google-puppeteer-process to test &lt;opt&gt;.url
 */
</span>    let browser;
    let fileScreenshot;
    let isDone;
    let onParallel;
    let page;
    let testId;
    let testName;
    let timerTimeout;
    // init utility2_testReport
    globalThis.utility2_testReport = globalThis.utility2_testReport || {
        coverage: globalThis.__coverage__,
        testPlatformList: [
            {
                name: (
                    local.isBrowser
                    ? (
                        &quot;browser - &quot;
                        + location.pathname + &quot; - &quot; + navigator.userAgent
                    )
                    : &quot;node - &quot; + process.platform + &quot; &quot; + process.version
                ) + &quot; - &quot; + new Date().toISOString(),
                testCaseList: []
            }
        ]
    };
    if (opt.modeTestReportCreate) {
        return;
    }
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        // node - init
        case 1:
            onParallel = local.onParallel(opt.gotoNext);
            onParallel.cnt += 1;
            isDone = 0;
            testId = Math.random().toString(16);
            testName = local.env.MODE_BUILD + &quot;.browser.&quot; + encodeURIComponent(
                new local.url.URL(opt.url).pathname.replace(
                    &quot;/build..&quot;
                    + local.env.CI_BRANCH
                    + &quot;..&quot; + local.env.CI_HOST,
                    &quot;/build&quot;
                )
            );
            fileScreenshot = (
                local.env.npm_config_dir_build + &quot;/screenshot.&quot;
                + testName
                + &quot;.png&quot;
            );
            opt.url = opt.url.replace(
                &quot;{{timeExit}}&quot;,
                Date.now() + local.timeoutDefault
            );
            // init timerTimeout
            timerTimeout = setTimeout(
                opt.gotoNext,
                local.timeoutDefault,
                new Error(
                    &quot;timeout - &quot; + local.timeoutDefault + &quot; ms - &quot;
                    + testName
                )
            );
            // create puppeteer browser
            local.puppeteerLaunch({
                args: [
                    &quot;--headless&quot;,
                    &quot;--incognito&quot;,
                    &quot;--no-sandbox&quot;,
                    &quot;--remote-debugging-port=0&quot;
                ],
                dumpio: !opt.modeSilent,
                executablePath: local.env.CHROME_BIN,
                ignoreDefaultArgs: true
            }).then(opt.gotoNextData);
            break;
        case 2:
            browser = data;
            browser.newPage().then(opt.gotoNextData);
            break;
        case 3:
            page = data;
            page.goto(opt.url).then(opt.gotoNextData);
            break;
        case 4:
            onParallel.cnt += 1;
            setTimeout(function () {
                page.screenshot({
                    path: fileScreenshot
                }).then(function () {
                    console.error(
                        &quot;\nbrowserTest - created screenshot file &quot;
                        + fileScreenshot
                        + &quot;\n&quot;
                    );
                    onParallel();
                });
            }, 100);
            page.on(&quot;metrics&quot;, function (metric) {
                if (isDone &gt;= 1 || metric.title !== testId) {
                    return;
                }
                isDone = 1;
                opt.gotoNext();
            });
            page.evaluate(function (testId) {
                window.utility2_testId = testId;
                if (!window.utility2_modeTest) {
                    console.timeStamp(window.utility2_testId);
                }
            }, testId);
            break;
        case 5:
            page.ev...</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict = {};

local.cliDict[&quot;utility2.browserTest&quot;] = function () {
/*
* &lt;urlList&gt; &lt;mode&gt;
* will browser-test in parallel, comma-separated &lt;urlList&gt; with given &lt;mode&gt;
*/
   local.<span class="apidocCodeKeywordSpan">browserTest</span>({
       url: process.argv[3]
   }, local.onErrorDefault);
};

local.cliDict[&quot;utility2.githubCrudContentDelete&quot;] = function () {
/*
* &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferConcat" id="apidoc.elem.utility2.bufferConcat">
        function <span class="apidocSignatureSpan">utility2.</span>bufferConcat
        <span class="apidocSignatureSpan">(bufList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferConcat = function (bufList) {
<span class="apidocCodeCommentSpan">/*
 * this function will emulate in browser, node&apos;s Buffer.concat
 */
</span>    let byteLength;
    let ii;
    let isString;
    let jj;
    let result;
    isString = true;
    result = [
        &quot;&quot;
    ];
    byteLength = 0;
    bufList.forEach(function (buf) {
        if (buf !== 0 &amp;&amp; !(buf &amp;&amp; buf.length)) {
            return;
        }
        // optimization - concat string
        if (isString &amp;&amp; typeof buf === &quot;string&quot;) {
            result[0] += buf;
            return;
        }
        isString = null;
        buf = local.bufferValidateAndCoerce(buf);
        byteLength += buf.byteLength;
        result.push(buf);
    });
    // optimization - return string
    if (isString) {
        return result[0];
    }
    result[0] = local.bufferValidateAndCoerce(result[0]);
    byteLength += result[0].byteLength;
    bufList = result;
    result = local.bufferValidateAndCoerce(new Uint8Array(byteLength));
    ii = 0;
    bufList.forEach(function (buf) {
        jj = 0;
        while (jj &lt; buf.byteLength) {
            result[ii] = buf[jj];
            ii += 1;
            jj += 1;
        }
    });
    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
]);
// init boundary
ii = 0;
jj = local.bufferIndexOfSubBuffer(req.bodyRaw, crlf, ii);
if (jj &lt;= 0) {
    break;
}
boundary = local.<span class="apidocCodeKeywordSpan">bufferConcat</span>([
    crlf, req.bodyRaw.slice(ii, jj)
]);
ii = jj + 2;
while (true) {
    jj = local.bufferIndexOfSubBuffer(
        req.bodyRaw,
        boundary,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferIndexOfSubBuffer" id="apidoc.elem.utility2.bufferIndexOfSubBuffer">
        function <span class="apidocSignatureSpan">utility2.</span>bufferIndexOfSubBuffer
        <span class="apidocSignatureSpan">(buf, subBff, fromIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferIndexOfSubBuffer = function (buf, subBff, fromIndex) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;buf&gt; from &lt;fromIndex&gt; for position of &lt;subBff&gt;
 */
</span>    let ii;
    let jj;
    let kk;
    if (!subBff.length) {
        return 0;
    }
    ii = fromIndex || 0;
    while (ii &lt; buf.length) {
        kk = ii;
        jj = 0;
        while (jj &lt; subBff.length) {
            if (subBff[jj] !== buf[kk]) {
                break;
            }
            kk += 1;
            jj += 1;
        }
        if (jj === subBff.length) {
            return kk - jj;
        }
        ii += 1;
    }
    return -1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
req.swgg.bodyParsed = {};
req.swgg.bodyMeta = {};
crlf = new Uint8Array([
    0x0d, 0x0a
]);
// init boundary
ii = 0;
jj = local.<span class="apidocCodeKeywordSpan">bufferIndexOfSubBuffer</span>(req.bodyRaw, crlf, ii);
if (jj &lt;= 0) {
    break;
}
boundary = local.bufferConcat([
    crlf, req.bodyRaw.slice(ii, jj)
]);
ii = jj + 2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferRandomBytes" id="apidoc.elem.utility2.bufferRandomBytes">
        function <span class="apidocSignatureSpan">utility2.</span>bufferRandomBytes
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferRandomBytes = function (length) {
<span class="apidocCodeCommentSpan">/*
 * this function will return a Buffer with given &lt;length&gt;,
 * filled with cryptographically-strong random-values
 */
</span>    return (
        (
            typeof window === &quot;object&quot;
            &amp;&amp; window.crypto
            &amp;&amp; typeof window.crypto.getRandomValues === &quot;function&quot;
        )
        ? window.crypto.getRandomValues(new Uint8Array(length))
        : require(&quot;crypto&quot;).randomBytes(length)
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferToUtf8" id="apidoc.elem.utility2.bufferToUtf8">
        function <span class="apidocSignatureSpan">utility2.</span>bufferToUtf8
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferToUtf8 = function (buf) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert Uint8Array &lt;buf&gt; to utf8
 */
</span>    return local.bufferValidateAndCoerce(buf, &quot;string&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
let name;
// if req is already parsed, then goto next
if (!req.swgg.operation || !local.isNullOrUndefined(req.swgg.bodyParsed)) {
    next();
    return;
}
headerParse = function () {
    local.<span class="apidocCodeKeywordSpan">bufferToUtf8</span>(req.bodyRaw.slice(ii, ii + 1024)).replace((
        /^content-disposition:\u0020?form-data;(.+?)\r\n(?:content-type:\u0020?(.*?)$)?/im
    ), function (ignore, match1, match2) {
        data = {
            contentType: match2,
            name: &quot;&quot;
        };
        match1.replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.bufferValidateAndCoerce" id="apidoc.elem.utility2.bufferValidateAndCoerce">
        function <span class="apidocSignatureSpan">utility2.</span>bufferValidateAndCoerce
        <span class="apidocSignatureSpan">(buf, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferValidateAndCoerce = function (buf, mode) {
<span class="apidocCodeCommentSpan">/*
 * this function will validate and coerce/convert
 * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
 */
</span>    // validate not 0
    if (buf !== 0) {
        buf = buf || &quot;&quot;;
    }
    if (typeof buf === &quot;string&quot; &amp;&amp; mode === &quot;string&quot;) {
        return buf;
    }
    // convert utf8 to Uint8Array
    if (typeof buf === &quot;string&quot;) {
        buf = new TextEncoder().encode(buf);
    // validate instanceof Uint8Array
    } else if (Object.prototype.toString.call(buf) !== &quot;[object Uint8Array]&quot;) {
        throw new Error(
            &quot;bufferValidateAndCoerce - value is not instanceof &quot;
            + &quot;ArrayBuffer, String, or Uint8Array&quot;
        );
    }
    // convert Uint8Array to utf8
    if (mode === &quot;string&quot;) {
        return new TextDecoder().decode(buf);
    }
    // coerce Uint8Array to Buffer
    if (globalThis.Buffer &amp;&amp; Buffer.isBuffer &amp;&amp; !Buffer.isBuffer(buf)) {
        Object.setPrototypeOf(buf, Buffer.prototype);
    }
    return buf;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   return buf.subarray(0, jj);
};

local.base64ToUtf8 = function (str) {
/*
* this function will convert base64 &lt;str&gt; to utf8 str
*/
   return local.<span class="apidocCodeKeywordSpan">bufferValidateAndCoerce</span>(local.base64ToBuffer(str), &quot;string&quot;);
};

local.base64urlFromBuffer = function (str) {
/*
* this function will convert base64url &lt;str&gt; to Uint8Array
*/
   return local.base64FromBuffer(str).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildApp" id="apidoc.elem.utility2.buildApp">
        function <span class="apidocSignatureSpan">utility2.</span>buildApp
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildApp = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build app with given &lt;opt&gt;
 */
</span>    opt = local.objectAssignDefault(opt, {
        assetsList: []
    });
    // build assets
    local.fsRmrfSync(&quot;tmp/build/app&quot;);
    local.onParallelList({
        list: [
            {
                file: &quot;/LICENSE&quot;,
                url: &quot;/LICENSE&quot;
            }, {
                file: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.html&quot;,
                url: &quot;/index.html&quot;
            }, {
                file: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
                url: &quot;/assets.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;
            }, {
                file: &quot;/assets.app.js&quot;,
                url: &quot;/assets.app.js&quot;
            }, {
                file: &quot;/assets.example.html&quot;,
                url: &quot;/assets.example.html&quot;
            }, {
                file: &quot;/assets.example.js&quot;,
                url: &quot;/assets.example.js&quot;
            }, {
                file: &quot;/assets.test.js&quot;,
                url: &quot;/assets.test.js&quot;
            }, {
                file: &quot;/assets.utility2.html&quot;,
                url: &quot;/assets.utility2.html&quot;
            }, {
                file: &quot;/assets.utility2.rollup.js&quot;,
                url: &quot;/assets.utility2.rollup.js&quot;
            }, {
                file: &quot;/index.html&quot;,
                url: &quot;/index.html&quot;
            }, {
                file: &quot;/index.rollup.html&quot;,
                url: &quot;/index.rollup.html&quot;
            }, {
                file: &quot;/jsonp.utility2.stateInit&quot;,
                url: (
                    &quot;/jsonp.utility2.stateInit&quot;
                    + &quot;?callback=window.utility2.stateInit&quot;
                )
            }
        ].concat(opt.assetsList)
    }, async function (opt2, onParallel) {
        let xhr;
        opt2 = opt2.elem;
        onParallel.cnt += 1;
        xhr = await local.httpFetch(local.serverLocalHost + opt2.url, {
            responseType: &quot;raw&quot;
        });
        // jslint file
        local.jslintAndPrint(xhr.data.toString(), opt2.file, {
            conditional: true,
            coverage: local.env.npm_config_mode_coverage
        });
        // handle err
        local.assertOrThrow(
            !local.jslint.jslintResult.errMsg,
            local.jslint.jslintResult.errMsg
        );
        local.fsWriteFileWithMkdirpSync(
            &quot;tmp/build/app&quot; + opt2.file,
            xhr.data,
            &quot;wrote file - app - {{pathname}}&quot;
        );
        onParallel();
    }, function (err) {
        // handle err
        local.assertOrThrow(!err, err);
        // test standalone assets.app.js
        local.fsWriteFileWithMkdirpSync(
            &quot;tmp/buildApp/assets.app.js&quot;,
            local.assetsDict[&quot;/assets.app.js&quot;],
            &quot;wrote file - assets.app.js - {{pathname}}&quot;
        );
        local.childProcessSpawnWithTimeout(&quot;node&quot;, [
            &quot;assets.app.js&quot;
        ], {
            cwd: &quot;tmp/buildApp&quot;,
            env: {
                PATH: local.env.PATH,
                PORT: (Math.random() * 0x10000) | 0x8000,
                npm_config_timeout_exit: 5000
            },
            stdio: [
                &quot;ignore&quot;, &quot;ignore&quot;, 2
            ]
        }).on(&quot;error&quot;, onError).on(&quot;exit&quot;, function (exitCode) {
            // validate exitCode
            local.assertOrThrow(!exitCode, exitCode);
            onError();
        });
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   globalThis.local.testCase_buildReadme_default(opt, local.onErrorThrow);
   globalThis.local.testCase_buildLib_default(opt, local.onErrorThrow);
   globalThis.local.testCase_buildTest_default(opt, local.onErrorThrow);
   local.<span class="apidocCodeKeywordSpan">buildApp</span>(opt, onError);
};

local._testCase_buildLib_default = function (opt, onError) {
/*
* this function will test buildLib&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildLib" id="apidoc.elem.utility2.buildLib">
        function <span class="apidocSignatureSpan">utility2.</span>buildLib
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildLib = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build lib with given &lt;opt&gt;
 */
</span>    let result;
    local.objectAssignDefault(opt, {
        customize: local.nop,
        dataFrom: local.fs.readFileSync(
            &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
            &quot;utf8&quot;
        ),
        dataTo: local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.my_app.template.js&quot;]
        )
    });
    // search-and-replace - customize dataTo
    [
        // customize top-level comment-description
        (
            /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
        ),
        // customize code after /* validateLineSortedReset */
        (
            /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
        )
    ].forEach(function (rgx) {
        opt.dataTo = local.stringMerge(opt.dataTo, opt.dataFrom, rgx);
    });
    // customize assets.utility2.rollup.js
    if (
        local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
    ) {
        opt.dataTo = opt.dataTo.replace(
            &quot;    // || globalThis.utility2_rollup_old&quot;,
            &quot;    || globalThis.utility2_rollup_old&quot;
        ).replace(
            &quot;    // || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;,
            &quot;    || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;
        );
    }
    // save lib
    result = opt.dataTo;
    if (!local.env.npm_config_mode_coverage) {
        local.fsWriteFileWithMkdirpSync(
            &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
            result,
            &quot;wrote file - lib - {{pathname}}&quot;
        );
    }
    opt.customize(opt);
    onError();
    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
/*
* this function will test buildLib&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildLib</span>({}, onError);
};

local._testCase_buildReadme_default = function (opt, onError) {
/*
* this function will test buildReadme&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildReadme" id="apidoc.elem.utility2.buildReadme">
        function <span class="apidocSignatureSpan">utility2.</span>buildReadme
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildReadme = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build readme with given &lt;opt&gt; my-app-lite template
 */
</span>    let result;
    local.objectAssignDefault(opt, {
        customize: local.nop,
        // reset toc
        dataFrom: local.fs.readFileSync(
            &quot;README.md&quot;,
            &quot;utf8&quot;
        ).replace((
            /\n#\u0020table\u0020of\u0020contents$[\S\s]*?\n\n\n\n/m
        ), &quot;\n# table of contents\n\n\n\n&quot;),
        packageJsonRgx: (
            /\n#\u0020package.json\n```json\n([\S\s]*?)\n```\n/
        )
    });
    // render dataTo
    opt.dataTo = local.templateRenderMyApp(
        local.assetsDict[&quot;/assets.readme.template.md&quot;]
    );
    // init package.json
    opt.dataFrom.replace(opt.packageJsonRgx, function (match0, match1) {
        // remove null from package.json
        opt.packageJson = JSON.parse(match1.replace((
            /\u0020{4}&quot;.*?&quot;:\u0020null,?$/gm
        ), &quot;&quot;));
        opt.packageJson.description = opt.dataFrom.split(&quot;\n&quot;)[1];
        local.objectAssignDefault(opt.packageJson, {
            nameLib: JSON.parse(
                local.fs.readFileSync(&quot;package.json&quot;, &quot;utf8&quot;)
            ).nameLib
        });
        opt.packageJson = local.objectAssignDefault(opt.packageJson, {
            nameLib: opt.packageJson.name.replace((
                /\W/g
            ), &quot;_&quot;),
            nameOriginal: opt.packageJson.name
        });
        opt.packageJson = local.objectAssignDefault(
            opt.packageJson,
            JSON.parse(local.templateRenderMyApp(opt.packageJsonRgx.exec(
                local.assetsDict[&quot;/assets.readme.template.md&quot;]
            )[1])),
            2
        );
        // avoid npm-installing that
        delete opt.packageJson.devDependencies[opt.packageJson.name];
        // reset scripts
        opt.packageJson.scripts = {
            &quot;build-ci&quot;: &quot;./npm_scripts.sh&quot;,
            env: &quot;env&quot;,
            eval: &quot;./npm_scripts.sh&quot;,
            &quot;heroku-postbuild&quot;: &quot;./npm_scripts.sh&quot;,
            postinstall: &quot;./npm_scripts.sh&quot;,
            start: &quot;./npm_scripts.sh&quot;,
            test: &quot;./npm_scripts.sh&quot;,
            utility2: &quot;./npm_scripts.sh&quot;
        };
        // save package.json
        local.fsWriteFileWithMkdirpSync(
            &quot;package.json&quot;,
            local.jsonStringifyOrdered(opt.packageJson, undefined, 4) + &quot;\n&quot;,
            &quot;wrote file - package.json - {{pathname}}&quot;
        );
        // re-render dataTo
        opt.dataTo = local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.readme.template.md&quot;]
        );
        opt.dataTo = opt.dataTo.replace(
            opt.packageJsonRgx,
            match0.replace(
                match1,
                local.jsonStringifyOrdered(opt.packageJson, undefined, 4)
            )
        );
    });
    // search-and-replace - customize dataTo
    [
        // customize name and description
        (
            /.*?\n.*?\n/
        ),
        // customize cdn-download
        (
            /\n#\u0020cdn\u0020download\n[\S\s]*?\n\n\n\n/
        ),
        // customize live-web-demo
        (
            /\n#\u0020live\u0020web\u0020demo\n[\S\s]*?\n\n\n\n/
        ),
        // customize changelog
        (
            /\n####\u0020changelog\u0020[\S\s]*?\n\n\n\n/
        ),
        // customize example.js - shared js\u002denv code - init-before
        (
            /\nglobalThis\.local\u0020=\u0020local;\n[^`]*?\n\/\/\u0020run\u0020browser\u0020js\u002denv\u0020code\u0020-\u0020init
-test\n/
        ),
        // customize example.js - html-body
        (
            /\n&lt;!--\u0020custom-html-start\u0020--&gt;\\n\\\n[^`]*?\n&lt;!--\u0020custom-html-end\u0020--&gt;\\n\\\n/
        ),
        // customize build_ci - shBuildCiAfter
        (
            /\nshBuildCiAfter\u0020\(\)\u0...</pre></li>
    <li>example use<pre class="apidocCodePre">...
/*
* this function will test buildReadme&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildReadme</span>({}, onError);
};

local._testCase_buildTest_default = function (opt, onError) {
/*
* this function will test buildTest&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.buildTest" id="apidoc.elem.utility2.buildTest">
        function <span class="apidocSignatureSpan">utility2.</span>buildTest
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTest = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will build test with given &lt;opt&gt;
 */
</span>    let result;
    local.objectAssignDefault(opt, {
        customize: local.nop,
        dataFrom: local.fs.readFileSync(&quot;test.js&quot;, &quot;utf8&quot;),
        dataTo: local.templateRenderMyApp(
            local.assetsDict[&quot;/assets.test.template.js&quot;]
        )
    });
    // search-and-replace - customize dataTo
    [
        // customize shared js\u002denv code - function
        (
            /\n\}\(\)\);\n\n\n\n\/\/\u0020run\u0020shared\u0020js\u002denv\u0020code\u0020-\u0020function\n[\S\s]*?$/
        )
    ].forEach(function (rgx) {
        opt.dataTo = local.stringMerge(opt.dataTo, opt.dataFrom, rgx);
    });
    // customize require(&quot;utility2&quot;)
    [
        &quot;./assets.utility2.rollup.js&quot;,
        &quot;./lib.utility2.js&quot;
    ].forEach(function (file) {
        if (local.fs.existsSync(file)) {
            opt.dataTo = opt.dataTo.replace(
                &quot;require(\&quot;utility2\&quot;)&quot;,
                &quot;require(\&quot;&quot; + file + &quot;\&quot;)&quot;
            );
        }
    });
    opt.customize(opt);
    // save test.js
    result = opt.dataTo;
    local.fsWriteFileWithMkdirpSync(
        &quot;test.js&quot;,
        result,
        &quot;wrote file - test - {{pathname}}&quot;
    );
    onError();
    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
/*
* this function will test buildTest&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   return local.<span class="apidocCodeKeywordSpan">buildTest</span>({}, onError);
};

local._testCase_webpage_default = function (opt, onError) {
/*
* this function will test webpage&apos;s default handling-behavior
*/
   if (local.isBrowser) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.childProcessSpawnWithTimeout" id="apidoc.elem.utility2.childProcessSpawnWithTimeout">
        function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithTimeout
        <span class="apidocSignatureSpan">(command, args, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childProcessSpawnWithTimeout = function (command, args, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run like child_process.spawn,
 * but with auto-timeout after timeout milliseconds
 * example use:
    let child = local.childProcessSpawnWithTimeout(
        &quot;/bin/sh&quot;,
        [&quot;-c&quot;, &quot;echo hello world&quot;],
        {stdio: [&quot;ignore&quot;, 1, 2], timeout: 5000}
    );
    child.on(&quot;error&quot;, console.error);
    child.on(&quot;exit&quot;, function (exitCode) {
        console.error(&quot;exitCode &quot; + exitCode);
    });
 */
</span>    let child;
    let child_process;
    let timerTimeout;
    child_process = require(&quot;child_process&quot;);
    // spawn child
    child = child_process.spawn(command, args, opt).on(&quot;exit&quot;, function () {
        // cleanup timerTimeout
        try {
            process.kill(timerTimeout.pid);
        } catch (ignore) {}
    });
    // init timerTimeout
    timerTimeout = child_process.spawn(
        // convert timeout to integer seconds with 2 second delay
        &quot;sleep &quot;
        + Math.floor(
            0.001 * (Number(opt &amp;&amp; opt.timeout) || local.timeoutDefault)
            + 2
        )
        + &quot;; kill -9 &quot; + child.pid + &quot; 2&gt;/dev/null&quot;,
        {
            shell: true,
            stdio: &quot;ignore&quot;
        }
    );
    return child;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.assertOrThrow(!err, err);
// test standalone assets.app.js
local.fsWriteFileWithMkdirpSync(
    &quot;tmp/buildApp/assets.app.js&quot;,
    local.assetsDict[&quot;/assets.app.js&quot;],
    &quot;wrote file - assets.app.js - {{pathname}}&quot;
);
local.<span class="apidocCodeKeywordSpan">childProcessSpawnWithTimeout</span>(&quot;node&quot;, [
    &quot;assets.app.js&quot;
], {
    cwd: &quot;tmp/buildApp&quot;,
    env: {
        PATH: local.env.PATH,
        PORT: (Math.random() * 0x10000) | 0x8000,
        npm_config_timeout_exit: 5000
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.childProcessSpawnWithUtility2" id="apidoc.elem.utility2.childProcessSpawnWithUtility2">
        function <span class="apidocSignatureSpan">utility2.</span>childProcessSpawnWithUtility2
        <span class="apidocSignatureSpan">(script, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childProcessSpawnWithUtility2 = function (script, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run child_process.spawn, with lib.utility2.sh sourced
 */
</span>    require(&quot;child_process&quot;).spawn(
        &quot;. &quot; + (process.env.npm_config_dir_utility2 || __dirname)
        + &quot;/lib.utility2.sh; &quot; + script,
        {
            shell: true,
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        }
    ).on(&quot;exit&quot;, function (exitCode) {
        onError(exitCode &amp;&amp; Object.assign(new Error(), {
            exitCode
        }));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        // test __dirname handling-behavior
        [
            process.env, {
                npm_config_dir_utility2: &quot;&quot;
            }
        ]
    ], function (onError) {
        local.local.<span class="apidocCodeKeywordSpan">childProcessSpawnWithUtility2</span>(&quot;undefined&quot;, function (err
) {
            // handle err
            local.assertOrThrow(err, err);
        });
        onError(undefined, opt);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliRun" id="apidoc.elem.utility2.cliRun">
        function <span class="apidocSignatureSpan">utility2.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let str;
        let strDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            str = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(str);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(str).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        str = &quot;&quot;;
        str += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        str += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file
                + &quot;  &quo...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.coalesce" id="apidoc.elem.utility2.coalesce">
        function <span class="apidocSignatureSpan">utility2.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(str);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.corsBackendHostInject" id="apidoc.elem.utility2.corsBackendHostInject">
        function <span class="apidocSignatureSpan">utility2.</span>corsBackendHostInject
        <span class="apidocSignatureSpan">(url, backendHost, rgx, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">corsBackendHostInject = function (url, backendHost, rgx, location) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;location&gt;.host is a github site,
 * inject &lt;backendHost&gt; into &lt;url&gt; with given &lt;rgx&gt;
 */
</span>    location = (
        location
        || (typeof window === &quot;object&quot; &amp;&amp; window &amp;&amp; window.location)
    );
    if (!(backendHost &amp;&amp; location &amp;&amp; (
        /\bgithub.io$/
    ).test(location.host))) {
        return url;
    }
    // init github-branch
    location.pathname.replace((
        /\/build\.\.(alpha|beta|master)\.\.travis-ci\.org\//
    ), function (ignore, match1) {
        backendHost = backendHost.replace(&quot;-alpha.&quot;, &quot;-&quot; + match1 + &quot;.&quot;);
    });
    return url.replace(rgx || (
        /.*?($)/m
    ), backendHost + &quot;$1&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.testCase_corsBackendHostInject_default = function (opt, onError) {
/*
* this function will corsBackendHostInject&apos;s default handling-behavior
*/
   // test null-case handling-behavior
   local.assertJsonEqual(local.<span class="apidocCodeKeywordSpan">corsBackendHostInject</span>(), undefined);
   // test override-all handling-behavior
   local.assertJsonEqual(local.corsBackendHostInject(
       &quot;cc.com&quot;,
       &quot;aa-alpha.bb.com&quot;,
       null,
       {
           host: &quot;github.io&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.corsForwardProxyHostIfNeeded" id="apidoc.elem.utility2.corsForwardProxyHostIfNeeded">
        function <span class="apidocSignatureSpan">utility2.</span>corsForwardProxyHostIfNeeded
        <span class="apidocSignatureSpan">(xhr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">corsForwardProxyHostIfNeeded = function (xhr) {
<span class="apidocCodeCommentSpan">/*
 * this function will return xhr.corsForwardProxyHost, if needed
 */
</span>    return (
        local.isBrowser
        &amp;&amp; local.env.npm_package_nameLib
        &amp;&amp; (
            /^https?:\/\//
        ).test(xhr.url)
        &amp;&amp; xhr.url.indexOf(xhr.location.protocol + &quot;//&quot; + xhr.location.host)
        !== 0
        &amp;&amp; (
            /\.github\.io$/
        ).test(xhr.location.host)
        &amp;&amp; xhr.corsForwardProxyHost !== &quot;disabled&quot;
        &amp;&amp; (xhr.corsForwardProxyHost || &quot;https://h1-proxy1.herokuapp.com&quot;)
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload
if (xhr.upload &amp;&amp; xhr.upload.addEventListener) {
    xhr.upload.addEventListener(&quot;progress&quot;, ajaxProgressUpdate);
}
// open url - corsForwardProxyHost
if (
    local2.corsForwardProxyHostIfNeeded
    &amp;&amp; local2.<span class="apidocCodeKeywordSpan">corsForwardProxyHostIfNeeded</span>(xhr)
) {
    xhr.open(xhr.method, local2.corsForwardProxyHostIfNeeded(xhr));
    xhr.setRequestHeader(
        &quot;forward-proxy-headers&quot;,
        JSON.stringify(xhr.headers)
    );
    xhr.setRequestHeader(&quot;forward-proxy-url&quot;, xhr.url);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cryptoAesXxxCbcRawDecrypt" id="apidoc.elem.utility2.cryptoAesXxxCbcRawDecrypt">
        function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawDecrypt
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cryptoAesXxxCbcRawDecrypt = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will aes-xxx-cbc decrypt with given &lt;opt&gt;
 * example use:
    data = new Uint8Array([1,2,3]);
    key = &apos;0123456789abcdef0123456789abcdef&apos;;
    mode = undefined;
    local.cryptoAesXxxCbcRawEncrypt({
        data,
        key,
        mode
    }, function (err, data) {
        console.assert(!err, err);
        local.cryptoAesXxxCbcRawDecrypt({
            data,
            key,
            mode
        }, console.log);
    });
 */
</span>    let cipher;
    let crypto;
    let data;
    let ii;
    let iv;
    let key;
    // init key
    key = new Uint8Array(0.5 * opt.key.length);
    ii = 0;
    while (ii &lt; key.byteLength) {
        key[ii] = parseInt(opt.key.slice(2 * ii, 2 * ii + 2), 16);
        ii += 2;
    }
    data = opt.data;
    // base64
    if (opt.mode === &quot;base64&quot;) {
        data = local.base64ToBuffer(data);
    }
    // normalize data
    if (Object.prototype.toString.call(data) !== &quot;[object Uint8Array]&quot;) {
        data = new Uint8Array(data);
    }
    // init iv
    iv = data.subarray(0, 16);
    // optimization - create resized-view of data
    data = data.subarray(16);
    crypto = globalThis.crypto;
    if (!local.isBrowser) {
        setTimeout(function () {
            crypto = require(&quot;crypto&quot;);
            cipher = crypto.createDecipheriv(
                &quot;aes-&quot; + (8 * key.byteLength) + &quot;-cbc&quot;,
                key,
                iv
            );
            onError(undefined, Buffer.concat([
                cipher.update(data), cipher.final()
            ]));
        });
        return;
    }
    crypto.subtle.importKey(&quot;raw&quot;, key, {
        name: &quot;AES-CBC&quot;
    }, false, [
        &quot;decrypt&quot;
    ]).then(function (key) {
        crypto.subtle.decrypt({
            iv,
            name: &quot;AES-CBC&quot;
        }, key, data).then(function (data) {
            onError(undefined, new Uint8Array(data));
        }).catch(onError);
    }).catch(onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.assert(!err, err);
       local.<span class="apidocCodeKeywordSpan">cryptoAesXxxCbcRawDecrypt</span>({
           data,
           key,
           mode
       }, console.log);
   });
*/
   let cipher;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cryptoAesXxxCbcRawEncrypt" id="apidoc.elem.utility2.cryptoAesXxxCbcRawEncrypt">
        function <span class="apidocSignatureSpan">utility2.</span>cryptoAesXxxCbcRawEncrypt
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cryptoAesXxxCbcRawEncrypt = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will aes-xxx-cbc encrypt with given &lt;opt&gt;
 * example use:
    data = new Uint8Array([1,2,3]);
    key = &apos;0123456789abcdef0123456789abcdef&apos;;
    mode = undefined;
    local.cryptoAesXxxCbcRawEncrypt({
        data,
        key,
        mode
    }, function (err, data) {
        console.assert(!err, err);
        local.cryptoAesXxxCbcRawDecrypt({
            data,
            key,
            mode
        }, console.log);
    });
 */
</span>    let cipher;
    let crypto;
    let data;
    let ii;
    let iv;
    let key;
    // init key
    key = new Uint8Array(0.5 * opt.key.length);
    ii = 0;
    while (ii &lt; key.byteLength) {
        key[ii] = parseInt(opt.key.slice(2 * ii, 2 * ii + 2), 16);
        ii += 2;
    }
    data = opt.data;
    // init iv
    iv = new Uint8Array((((data.byteLength) &gt;&gt; 4) &lt;&lt; 4) + 32);
    crypto = globalThis.crypto;
    if (!local.isBrowser) {
        setTimeout(function () {
            crypto = require(&quot;crypto&quot;);
            // init iv
            iv.set(crypto.randomBytes(16));
            cipher = crypto.createCipheriv(
                &quot;aes-&quot; + (8 * key.byteLength) + &quot;-cbc&quot;,
                key,
                iv.subarray(0, 16)
            );
            data = cipher.update(data);
            iv.set(data, 16);
            iv.set(cipher.final(), 16 + data.byteLength);
            if (opt.mode === &quot;base64&quot;) {
                iv = local.base64FromBuffer(iv);
                iv += &quot;\n&quot;;
            }
            onError(undefined, iv);
        });
        return;
    }
    // init iv
    iv.set(crypto.getRandomValues(new Uint8Array(16)));
    crypto.subtle.importKey(&quot;raw&quot;, key, {
        name: &quot;AES-CBC&quot;
    }, false, [
        &quot;encrypt&quot;
    ]).then(function (key) {
        crypto.subtle.encrypt({
            iv: iv.subarray(0, 16),
            name: &quot;AES-CBC&quot;
        }, key, data).then(function (data) {
            iv.set(new Uint8Array(data), 16);
            // base64
            if (opt.mode === &quot;base64&quot;) {
                iv = local.base64FromBuffer(iv);
                iv += &quot;\n&quot;;
            }
            onError(undefined, iv);
        }).catch(onError);
    }).catch(onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cryptoAesXxxCbcRawDecrypt = function (opt, onError) {
/*
* this function will aes-xxx-cbc decrypt with given &lt;opt&gt;
* example use:
   data = new Uint8Array([1,2,3]);
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.<span class="apidocCodeKeywordSpan">cryptoAesXxxCbcRawEncrypt</span>({
       data,
       key,
       mode
   }, function (err, data) {
       console.assert(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateGetWeekOfMonth" id="apidoc.elem.utility2.dateGetWeekOfMonth">
        function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfMonth
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateGetWeekOfMonth = function (date) {
<span class="apidocCodeCommentSpan">/*
 * this function will return sunday-based week-of-month from &lt;date&gt;
 */
</span>    date = new Date(date.slice(0, 10) + &quot;T00:00:00Z&quot;);
    return Math.ceil((date.getUTCDate() + new Date(
        date.getUTCFullYear(),
        date.getUTCMonth(),
        1
    ).getUTCDay()) / 7) - 1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateGetWeekOfYear" id="apidoc.elem.utility2.dateGetWeekOfYear">
        function <span class="apidocSignatureSpan">utility2.</span>dateGetWeekOfYear
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateGetWeekOfYear = function (date) {
<span class="apidocCodeCommentSpan">/*
 * this function will return ISO week-of-year from &lt;date&gt;
 *
 * Based on information at:
 *
 *    http://www.merlyn.demon.co.uk/weekcalc.htm#WNR
 *
 * Algorithm is to find nearest thursday, it&apos;s year
 * is the year of the week number. Then get weeks
 * between that date and the first day of that year.
 *
 * Note that dates in one year can be weeks of previous
 * or next year, overlap is up to 3 days.
 *
 * e.g. 2014/12/29 is Monday in week  1 of 2015
 *      2012/1/1   is Sunday in week 52 of 2011
 *
 * https://stackoverflow.com/questions/6117814/get-week-of-year-in-javascript-like-in-php
 */
</span>    date = new Date(date.slice(0, 10) + &quot;T00:00:00Z&quot;);
    // Set to nearest Thursday: current date + 4 - current day number
    // Make Sunday&apos;s day number 7
    date.setUTCDate(date.getUTCDate() + 4 - (date.getUTCDay() || 7));
    // Calculate full weeks to nearest Thursday
    return Math.ceil((((
        date
        // Get first day of year
        - new Date(Date.UTC(date.getUTCFullYear(), 0, 1))
    ) / 86400000) + 1) / 7);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateUtcFromLocal" id="apidoc.elem.utility2.dateUtcFromLocal">
        function <span class="apidocSignatureSpan">utility2.</span>dateUtcFromLocal
        <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateUtcFromLocal = function (date, timezoneOffset) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert local-&lt;date&gt; to utc-date
 */
</span>    if (!date) {
        return &quot;&quot;;
    }
    local.assertOrThrow((
        /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+?)?$/
    ).test(date), &quot;invalid local-date &quot; + date);
    if (!timezoneOffset) {
        return new Date(date).toISOString();
    }
    return new Date(
        new Date(date + &quot;Z&quot;).getTime() + timezoneOffset * 60000
    ).toISOString();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.dateUtcToLocal" id="apidoc.elem.utility2.dateUtcToLocal">
        function <span class="apidocSignatureSpan">utility2.</span>dateUtcToLocal
        <span class="apidocSignatureSpan">(date, timezoneOffset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateUtcToLocal = function (date, timezoneOffset) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert utc-&lt;date&gt; to local-date
 */
</span>    if (!date) {
        return &quot;&quot;;
    }
    local.assertOrThrow((
        /^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+?)?Z$/
    ).test(date), &quot;invalid utc-date &quot; + date);
    timezoneOffset = timezoneOffset || new Date(date).getTimezoneOffset();
    return new Date(
        new Date(date).getTime() - timezoneOffset * 60000
    ).toISOString();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domFragmentRender" id="apidoc.elem.utility2.domFragmentRender">
        function <span class="apidocSignatureSpan">utility2.</span>domFragmentRender
        <span class="apidocSignatureSpan">(template, dict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domFragmentRender = function (template, dict) {
<span class="apidocCodeCommentSpan">/*
 * this function will return dom-elem rendered from &lt;template&gt;
 */
</span>    let tmp;
    tmp = document.createElement(&quot;template&quot;);
    tmp.innerHTML = local.templateRender(template, dict);
    return tmp.content;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
});
// init uiFragment
swaggerJson.uiFragment = document.createDocumentFragment();
// init resourceDict
Object.keys(swaggerJson.resourceDict).sort().forEach(function (key) {
    // templateRender resource
    swaggerJson.uiFragment.appendChild(
        local.<span class="apidocCodeKeywordSpan">domFragmentRender</span>(
            local.templateUiResource,
            swaggerJson.resourceDict[key]
        )
    );
});
Object.keys(swaggerJson.operationDict).sort(function (aa, bb) {
    aa = swaggerJson.operationDict[aa];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domQuerySelectorAllTagName" id="apidoc.elem.utility2.domQuerySelectorAllTagName">
        function <span class="apidocSignatureSpan">utility2.</span>domQuerySelectorAllTagName
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domQuerySelectorAllTagName = function (selector) {
<span class="apidocCodeCommentSpan">/*
 * this function will return all tagName that match &lt;selector&gt;
 */
</span>    let set;
    set = new Set();
    document.querySelectorAll(selector).forEach(function (elem) {
        set.add(elem.tagName);
    });
    return Array.from(set).sort();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domSelectOptionValue" id="apidoc.elem.utility2.domSelectOptionValue">
        function <span class="apidocSignatureSpan">utility2.</span>domSelectOptionValue
        <span class="apidocSignatureSpan">(elem)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domSelectOptionValue = function (elem) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;elem&gt;.options[&lt;elem&gt;.selectedIndex].value
 */
</span>    if (typeof elem === &quot;string&quot;) {
        elem = document.querySelector(elem);
    }
    elem = elem &amp;&amp; elem.options[elem.selectedIndex];
    return (elem &amp;&amp; elem.value) || &quot;&quot;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.domStyleValidate" id="apidoc.elem.utility2.domStyleValidate">
        function <span class="apidocSignatureSpan">utility2.</span>domStyleValidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domStyleValidate = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will validate &lt;style&gt; tags
 */
</span>    let rgx;
    let tmp;
    try {
        document.querySelector(&quot;#undefined&quot;);
    } catch (ignore) {
        return;
    }
    rgx = (
        /^0\u0020(?:(body\u0020&gt;\u0020)?(?:\.testReportDiv\u0020.+|\.x-istanbul\u0020.+|\.button|\.colorError|\.readonly|\.textarea
|\.uiAnimateSlide|a|body|code|div|input|pre|textarea)(?:,|\u0020\{))|^[1-9]\d*?\u0020#/m
    );
    tmp = [];
    Array.from(
        document.querySelectorAll(&quot;style&quot;)
    ).map(function (elem, ii) {
        elem.innerHTML.replace((
            /\/\*[\S\s]*?\*\/|;|\}/g
        ), &quot;\n&quot;).replace((
            /^([^\n\u0020@].*?)[,{:].*?$/gm
        ), function (match0, match1) {
            try {
                ii = document.querySelectorAll(match1).length;
            } catch (errCaught) {
                console.error(errCaught);
            }
            if (!(ii &gt; 1)) {
                tmp.push(ii + &quot; &quot; + match0);
            }
        });
    });
    tmp.filter(function (elem) {
        return !rgx.test(elem);
    }).sort().reverse().forEach(function (elem, ii, list) {
        console.error(
            &quot;domStyleValidateUnmatched &quot; + (list.length - ii) + &quot;. &quot; + elem
        );
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
/*
* this function will test webpage&apos;s default handling-behavior
*/
   if (local.isBrowser) {
       onError(undefined, opt);
       return;
   }
   local.<span class="apidocCodeKeywordSpan">domStyleValidate</span>();
   local.browserTest({
       fileScreenshot: (
           local.env.npm_config_dir_build
           + &quot;/screenshot.&quot; + local.env.MODE_BUILD + &quot;.browser.%2F.png&quot;
       ),
       url: (
           local.serverLocalHost
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.emit" id="apidoc.elem.utility2.emit">
        function <span class="apidocSignatureSpan">utility2.</span>emit
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function (type, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will emit evt &lt;type&gt; with &lt;msg&gt;
 */
</span>    Array.from(dict[type] || []).forEach(function (listener) {
        listener(msg);
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  data = concat(fragments, messageLength);
} else if (this._binaryType === &apos;arraybuffer&apos;) {
  data = toArrayBuffer(concat(fragments, messageLength));
} else {
  data = fragments;
}

this.<span class="apidocCodeKeywordSpan">emit</span>(&apos;message&apos;, data);
      } else {
const buf = concat(fragments, messageLength);

if (!isValidUTF8(buf)) {
  this._loop = false;
  return error(Error, &apos;invalid UTF-8 sequence&apos;, true, 1007);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.eventEmitterCreate" id="apidoc.elem.utility2.eventEmitterCreate">
        function <span class="apidocSignatureSpan">utility2.</span>eventEmitterCreate
        <span class="apidocSignatureSpan">(that = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eventEmitterCreate = function (that = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a simple, node-like event-emitter with &lt;that&gt;,
 * with methods emit, on, once, removeListener
 */
</span>    let dict;
    let emit;
    let on;
    let once;
    let remove;
    emit = function (type, msg) {
    /*
     * this function will emit evt &lt;type&gt; with &lt;msg&gt;
     */
        Array.from(dict[type] || []).forEach(function (listener) {
            listener(msg);
        });
    };
    on = function (type, listener, opt = {}) {
    /*
     * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
     */
        let isDone;
        if (typeof listener === &quot;function&quot;) {
            dict[type] = dict[type] || [];
            dict[type].push(
                opt.once
                ? function listener2(msg) {
                    remove(type, listener2);
                    if (!isDone) {
                        isDone = true;
                        listener(msg);
                    }
                }
                : listener
            );
        }
        return that;
    };
    once = function (type, listener, opt = {}) {
    /*
     * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
     */
        opt.once = true;
        return on(type, listener, opt);
    };
    remove = function (type, listener) {
    /*
     * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
     */
        let ii;
        let list;
        list = dict[type] || [];
        ii = list.length;
        while (ii &gt; 0) {
            ii -= 1;
            if (list[ii] === listener) {
                list.splice(ii, 1);
            }
        }
        return that;
    };
    dict = {};
    that.emit = that.emit || emit;
    that.listenerEmit = that.listenerEmit || emit;
    that.on = that.on || on;
    that.once = that.once || once;
    that.removeListener = that.removeListener || remove;
    that.removeEventListener = that.removeEventListener || remove;
    that.listenerOn = that.listenerOn || on;
    that.listenerOnce = that.listenerOnce || once;
    that.listenerRemove = that.listenerRemove || remove;
    return that;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   that.removeEventListener = that.removeEventListener || remove;
   that.listenerOn = that.listenerOn || on;
   that.listenerOnce = that.listenerOnce || once;
   that.listenerRemove = that.listenerRemove || remove;
   return that;
};

local.<span class="apidocCodeKeywordSpan">eventEmitterCreate</span>(local);

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.onErrorWithStack(function (err, data, meta) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.events" id="apidoc.elem.utility2.events">
        function <span class="apidocSignatureSpan">utility2.</span>events
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.fsReadFileOrDefaultSync" id="apidoc.elem.utility2.fsReadFileOrDefaultSync">
        function <span class="apidocSignatureSpan">utility2.</span>fsReadFileOrDefaultSync
        <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrDefaultSync = function (pathname, type, dflt) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync-read &lt;pathname&gt; with given &lt;type&gt; and &lt;dflt&gt;
 */
</span>    let fs;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;ignore&quot;, &quot;ignore&quot;, 2
        ]
    });
}
if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
    // init assets index.html
    local.assetsDict[&quot;/index.html&quot;] = (
        local.<span class="apidocCodeKeywordSpan">fsReadFileOrDefaultSync</span>(&quot;index.html&quot;, &quot;utf8&quot;, &quot
;&quot;)
        || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
    );
    local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
    local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
        __filename,
        &quot;utf8&quot;
    ).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.fsRmrfSync" id="apidoc.elem.utility2.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(pathname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (pathname) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;pathname&gt;
 */
</span>    let child_process;
    // do nothing if module does not exist
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    if (process.platform !== &quot;win32&quot;) {
        child_process.spawnSync(&quot;rm&quot;, [
            &quot;-rf&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        });
        return;
    }
    try {
        child_process.spawnSync(&quot;rd&quot;, [
            &quot;/s&quot;, &quot;/q&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, &quot;ignore&quot;
            ]
        });
    } catch (ignore) {}
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(pathname, data, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (pathname, data, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;pathname&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    let success;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
        success = true;
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require(&quot;path&quot;).dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    || local.env.npm_config_mode_test_case
    !== &quot;testCase_buildApidoc_default&quot;
) {
    onError(undefined, opt);
    return;
}
// save apidoc.html
local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
    &quot;tmp/build/apidoc.html&quot;,
    local.apidocCreate(local.objectAssignDefault(opt, {
        blacklistDict: local,
        require: require2
    })),
    &quot;wrote file apidoc - {{pathname}}&quot;
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.gotoNext" id="apidoc.elem.utility2.gotoNext">
        function <span class="apidocSignatureSpan">utility2.</span>gotoNext
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gotoNext = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
 * and append current-stack to any err
 */
</span>    opt.gotoNext = local.onErrorWithStack(function (err, data, meta) {
        try {
            opt.gotoState += (
                (err &amp;&amp; !opt.modeErrorIgnore)
                ? 1000
                : 1
            );
            if (opt.modeDebug) {
                console.error(&quot;gotoNext - &quot; + JSON.stringify({
                    gotoState: opt.gotoState,
                    errorMessage: err &amp;&amp; err.message
                }));
                if (err &amp;&amp; err.stack) {
                    console.error(err.stack);
                }
            }
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.gotoNext(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.<span class="apidocCodeKeywordSpan">gotoNext</span>(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
};

local.onErrorDefault = function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.httpFetch" id="apidoc.elem.utility2.httpFetch">
        function <span class="apidocSignatureSpan">utility2.</span>httpFetch
        <span class="apidocSignatureSpan">(url, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">httpFetch = function (url, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will fetch &lt;url&gt; with given &lt;opt&gt;
 * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
 * https://developer.mozilla.org/en-US/docs/Web/API/Response
 */
</span>    let buf;
    let cleanup;
    let controller;
    let debug;
    let errStack;
    let httpFetchProgressUpdate;
    let isBrowser;
    let isDebugged;
    let isDone;
    let nop;
    let reject2;
    let reject;
    let request;
    let resolve2;
    let resolve;
    let response;
    let timeStart;
    let timeout;
    let timerTimeout;
    // init function
    cleanup = function () {
        if (isDone) {
            return true;
        }
        isDone = true;
        // cleanup timerTimeout
        clearTimeout(timerTimeout);
        // decrement httpFetchProgressUpdate.cnt
        httpFetchProgressUpdate.cnt = Math.max(
            httpFetchProgressUpdate.cnt - 1,
            0
        );
        httpFetchProgressUpdate();
    };
    debug = function () {
        if (isDebugged) {
            return;
        }
        isDebugged = true;
        console.error(&quot;serverLog - &quot; + JSON.stringify({
            time: new Date(timeStart).toISOString(),
            type: &quot;httpFetchResponse&quot;,
            method: opt.method,
            url,
            status: opt.status,
            timeElapsed: Date.now() - timeStart,
            // extra
            responseContentLength: buf.byteLength
        }) + &quot;\n&quot;);
    };
    nop = function () {
        return;
    };
    reject2 = function (err) {
        if (cleanup()) {
            return;
        }
        debug();
        // append errStack
        if (errStack) {
            err.stack += &quot;\n&quot; + errStack;
        }
        Object.assign(err, opt);
        reject(err);
    };
    resolve2 = async function (response) {
        try {
            if (isBrowser) {
                Array.from(response.headers).forEach(function ([
                    key, val
                ]) {
                    opt.responseHeaders[key.toLowerCase()] = val;
                });
                opt.status = response.status;
                opt.ok = response.ok;
                buf = new Uint8Array(
                    await response.arrayBuffer()
                );
            } else {
                // init responseproperties specified in
                // https://fetch.spec.whatwg.org/#response-class
                opt.responseHeaders = response.headers;
                opt.status = response.statusCode;
                opt.ok = 200 &lt;= opt.status &amp;&amp; opt.status &lt;= 299;
            }
            switch (opt.responseType) {
            case &quot;json&quot;:
                opt.data = JSON.parse(new TextDecoder().decode(buf));
                break;
            case &quot;raw&quot;:
                opt.data = buf;
                break;
            default:
                opt.data = new TextDecoder().decode(buf);
            }
            if (opt.modeDebug) {
                debug();
            }
            if (!opt.ok) {
                reject2(new Error(&quot;httpFetch - status &quot; + opt.status));
                return;
            }
        } catch (err) {
            reject2(err);
            return;
        }
        cleanup();
        resolve(opt);
    };
    // init httpFetchProgressUpdate
    httpFetchProgressUpdate = globalThis.httpFetchProgressUpdate || nop;
    httpFetchProgressUpdate.cnt |= 0;
    httpFetchProgressUpdate.cnt += 1;
    httpFetchProgressUpdate();
    // init opt
    opt = opt || {};
    opt.abort = function (err) {
        controller.abort();
        request.destroy();
        response.destroy();
        reject2(err || new Error(&quot;httpFetch - abort&quot;));
    };
    opt.method = opt.method || &quot;GET&quot;;
    opt.responseHeaders = {};
    opt.status = 400;
    // init var
    buf = new Uint8Array(0);
    controller = {
        abort: nop,
        destroy: nop
    };
    isBrowser = (
        typeof globalThi...</pre></li>
    <li>example use<pre class="apidocCodePre">...
            )
        }
    ].concat(opt.assetsList)
}, async function (opt2, onParallel) {
    let xhr;
    opt2 = opt2.elem;
    onParallel.cnt += 1;
    xhr = await local.<span class="apidocCodeKeywordSpan">httpFetch</span>(local.serverLocalHost + opt2.url, {
        responseType: &quot;raw&quot;
    });
    // jslint file
    local.jslintAndPrint(xhr.data.toString(), opt2.file, {
        conditional: true,
        coverage: local.env.npm_config_mode_coverage
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.identity" id="apidoc.elem.utility2.identity">
        function <span class="apidocSignatureSpan">utility2.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.isNullOrUndefined" id="apidoc.elem.utility2.isNullOrUndefined">
        function <span class="apidocSignatureSpan">utility2.</span>isNullOrUndefined
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNullOrUndefined = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will test if val is null or undefined
 */
</span>    return val === null || val === undefined;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        ? &quot;arraybuffer&quot;
        : &quot;&quot;
    )
});
// init paramDict
that.parameters.forEach(function (schemaP) {
    tmp = opt.paramDict[schemaP.name];
    if (local.<span class="apidocCodeKeywordSpan">isNullOrUndefined</span>(tmp)) {
        return;
    }
    // serialize array
    if (Array.isArray(tmp) &amp;&amp; schemaP.in !== &quot;body&quot;) {
        switch (
            schemaP.collectionFormat || schemaP[&quot;x-swgg-collectionFormat&quot;]
        ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter" id="apidoc.elem.utility2.istanbul.Instrumenter">
        function <span class="apidocSignatureSpan">utility2.</span>istanbul.Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require" id="apidoc.elem.utility2.istanbul.require">
        function <span class="apidocSignatureSpan">utility2.</span>istanbul.require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulCoverageMerge" id="apidoc.elem.utility2.istanbulCoverageMerge">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageMerge
        <span class="apidocSignatureSpan">(coverage1 = {}, coverage2 = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulCoverageMerge = function (coverage1 = {}, coverage2 = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace-merge &lt;coverage2&gt; into &lt;coverage1&gt;
 */
</span>    let dict1;
    let dict2;
    Object.keys(coverage2).forEach(function (file) {
        // if coverage1[file] is undefined, then override it
        if (!coverage1[file]) {
            coverage1[file] = coverage2[file];
            return;
        }
        // merge coverage2 into coverage1
        [
            &quot;b&quot;, &quot;f&quot;, &quot;s&quot;
        ].forEach(function (key) {
            dict1 = coverage1[file][key];
            dict2 = coverage2[file][key];
            switch (key) {
            // increment coverage for branch lines
            case &quot;b&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict2[key].forEach(function (cnt, ii) {
                        dict1[key][ii] += cnt;
                    });
                });
                break;
            // increment coverage for function and statement lines
            case &quot;f&quot;:
            case &quot;s&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict1[key] += dict2[key];
                });
                break;
            }
        });
    });
    return coverage1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        case 6:
data = JSON.parse(data);
// merge browser-screenshot
data.testPlatformList[0].screenshot = fileScreenshot.replace((
    /.*\//
), &quot;&quot;);
// merge browser-coverage
local.<span class="apidocCodeKeywordSpan">istanbulCoverageMerge</span>(globalThis.__coverage__, data.coverage);
// merge browser-test-report
local.testReportMerge(globalThis.utility2_testReport, data);
// save test-report.json
onParallel.cnt += 1;
local.fs.writeFile(
    local.path.resolve(
        local.env.npm_config_dir_build + &quot;/test-report.json&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulCoverageReportCreate" id="apidoc.elem.utility2.istanbulCoverageReportCreate">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulCoverageReportCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulCoverageReportCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
    // 1. merge previous &lt;dirCoverage&gt;/coverage.json into &lt;opt&gt;.coverage
    // 2. convert &lt;opt&gt;.coverage to &lt;summaryDict&gt;
    // 3. convert &lt;summaryDict&gt; to &lt;nodeRoot&gt;
    // 4. convert &lt;nodeRoot&gt; to text-report &lt;dirCoverage&gt;/coverage.txt
    // 5. convert &lt;nodeRoot&gt; to html-report &lt;dirCoverage&gt;/\*
    // 6. return coverage-report in html-format as single document
 */
</span>    let coverageInclude;
    let dirCoverage;
    let filePrefix;
    let filesUnderRoot;
    let htmlAll;
    let nodeChildAdd;
    let nodeCreate;
    let nodeDict;
    let nodeNormalize;
    let nodeRoot;
    let summaryDict;
    let tmp;
    let tmpChildren;
    if (!(opt &amp;&amp; opt.coverage)) {
        return &quot;&quot;;
    }
    // init function
    nodeChildAdd = function (node, child) {
    /*
     * this function will add &lt;child&gt; to &lt;node&gt;
     */
        node.children.push(child);
        child.parent = node;
    };
    nodeCreate = function (pathname) {
    /*
     * this function will create a tree-node
     */
        return {
            children: [],
            pathname,
            metrics: {
                branches: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                functions: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                lines: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                statements: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                }
            },
            name: pathname
        };
    };
    nodeNormalize = function (node, level, filePrefix, parent) {
    /*
     * this function will recursively normalize &lt;node&gt; and its children
     */
        let metric;
        // init name
        if (node.name.indexOf(filePrefix) === 0) {
            node.name = node.name.slice(filePrefix.length);
        }
        if (node.name[0] === path.sep) {
            node.name = node.name.slice(1);
        }
        // init relativeName
        node.relativeName = (
            parent
            ? (
                parent.name !== &quot;__root__/&quot;
                ? node.name.slice(parent.name.length)
                : node.name
            )
            : node.name.slice(filePrefix.length)
        );
        // init nameOrAllFiles
        node.nameOrAllFiles = node.name || &quot;All files&quot;;
        // init relativeNameOrAllFiles
        node.relativeNameOrAllFiles = node.relativeName || &quot;All files&quot;;
        // init href
        node.href = node.relativeName.split(path.sep).join(&quot;/&quot;) + (
            node.isFile
            ? &quot;.html&quot;
            : &quot;index.html&quot;
        );
        // recurse
        node.children.forEach(function (child) {
            nodeNormalize(child, level + 1, filePrefix, node);
        });
        // sort children by name
        node.children.sort(function (aa, bb) {
            return (
                aa.name &gt; bb.name
                ? 1
                : -1
            );
        });
        // init metrics
        if (!node.isFile) {
            node.children.forEach(function (child) {
                [
                    &quot;lines&quot;, &quot;statements&quot;, &quot;branches&quot;, &quot;functions&quot;
                ].forEach(function (key) {
                    metric = node.metrics[key];
                    metric.total += child.metrics[key].total;
                    metric.covered += child.metrics[key].covered;
                    metric.skipped += child.metrics[key].skipped;...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulInstrumentInPackage" id="apidoc.elem.utility2.istanbulInstrumentInPackage">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentInPackage
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulInstrumentInPackage = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will instrument &lt;code&gt;
 * if macro /\* istanbul instrument in package $npm_package_nameLib *\/
 * exists in &lt;code&gt;
 */
</span>    return (
        (
            process.env.npm_config_mode_coverage
            &amp;&amp; code.indexOf(&quot;/* istanbul ignore all */\n&quot;) &lt; 0 &amp;&amp; (
                process.env.npm_config_mode_coverage === &quot;all&quot;
                || process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_package_nameLib + &quot; */\n&quot;
                ) &gt;= 0
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_config_mode_coverage + &quot; */\n&quot;
                ) &gt;= 0
            )
        )
        ? local.instrumentSync(code, file)
        : code
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    &quot;globalThis.utility2_moduleExports&quot;
);
// init example.js
tmp = local.path.resolve(&quot;example.js&quot;);
// jslint code
local.jslintAndPrint(code, tmp);
// instrument code
code = local.<span class="apidocCodeKeywordSpan">istanbulInstrumentInPackage</span>(code, tmp);
// init module.exports
module = new local.Module(tmp);
require.cache[tmp] = module;
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbulInstrumentSync" id="apidoc.elem.utility2.istanbulInstrumentSync">
        function <span class="apidocSignatureSpan">utility2.</span>istanbulInstrumentSync
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">istanbulInstrumentSync = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will
    // 1. normalize &lt;file&gt;
    // 2. save &lt;code&gt; to __coverageInclude__[&lt;file&gt;] for future html-report
    // 3. return instrumented-code
 */
</span>    // 1. normalize &lt;file&gt;
    file = path.resolve(file);
    // 2. save &lt;code&gt; to __coverageInclude__[&lt;file&gt;] for future html-report
    globalThis.__coverageInclude__[file] = 1;
    // 3. return instrumented-code
    return new local.Instrumenter({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslintAndPrint" id="apidoc.elem.utility2.jslintAndPrint">
        function <span class="apidocSignatureSpan">utility2.</span>jslintAndPrint
        <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAndPrint = function (code = &quot;&quot;, file = &quot;undefined&quot;, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint/csslint &lt;code&gt; and print any errors to stderr
 */
</span>    let ii;
    let tmp;
    if (!(opt &amp;&amp; opt.gotoState)) {
        local.jslintResult = {
            gotoState: 0
        };
    }
    opt = Object.assign(local.jslintResult, opt);
    opt.gotoState += 1;
    switch (opt.gotoState) {
    // jslint - init
    case 1:
        // cleanup
        opt.errList = [];
        opt.errMsg = &quot;&quot;;
        // preserve lineno
        if (opt.iiStart) {
            opt.lineOffset |= 0;
            ii = 0;
            while (true) {
                ii = code.indexOf(&quot;\n&quot;, ii);
                if (ii === 0 || ii &gt; opt.iiStart) {
                    break;
                }
                ii += 1;
                opt.lineOffset += 1;
            }
            code = code.slice(opt.iiStart, opt.iiEnd || code.length);
        }
        switch (opt.fileType0) {
        // de-embed-js - &apos;\\n\\\n...\\n\\\n&apos;
        case &quot;.\\n\\&quot;:
            // rgx - remove \\n\\
            code = code.replace((
                /\\n\\$|\\(.)/gm
            ), function (ignore, match1) {
                return match1 || &quot;&quot;;
            });
            break;
        // de-embed-js - &apos;\n...\n&apos;
        case &quot;.sh&quot;:
            // rgx - convert &apos;&quot;&apos;&quot;&apos; to &apos;
            code = code.replace((
                /&apos;&quot;&apos;&quot;&apos;/g
            ), &quot;&apos;&quot;);
            break;
        }
        // init
        opt = Object.assign(opt, {
            &quot;.css&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.html&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.js&quot;: (
                /^\/\*jslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.json&quot;: (
                /^\s*?(?:\[|\{)/
            ),
            &quot;.md&quot;: (
                /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.sh&quot;: (
                /(^#\u0020jslint\u0020utility2:true$)/m
            ),
            code0: code,
            fileType: (
                /\.\w+?$|$/m
            ).exec(file)[0]
        });
        // jslint - .json
        if (opt.fileType === &quot;.js&quot; &amp;&amp; opt[&quot;.json&quot;].test(code)) {
            opt.fileType = &quot;.json&quot;;
        }
        try {
            opt.conditionalPassed = opt[opt.fileType].exec(code);
        } catch (ignore) {}
        opt.utility2 = (
            opt.conditionalPassed &amp;&amp; opt.conditionalPassed[1]
        ) || opt.autofix;
        if (
            opt.conditional
            &amp;&amp; (!opt.conditionalPassed || opt.coverage)
        ) {
            break;
        }
        opt.gotoState = 10;
        break;
    // jslint - autofix
    case 11:
        code = local.jslintAutofix(code, file, opt);
        local.jslintResult = opt;
        break;
    // jslint - csslint and jslint
    case 12:
        // restore lineOffset
        code = &quot;\n&quot;.repeat(opt.lineOffset | 0) + code;
        switch (opt.fileType) {
        case &quot;.css&quot;:
            // csslint
            Object.assign(opt, local.CSSLint.verify(code));
            // init errList
            opt.errList = opt.messages.map(function (err) {
                err.column = err.col;
                err.message = (
                    err.type + &quot; - &quot; + err.rule.id + &quot; - &quot; + err.message
                    + &quot;\n    &quot; + err.rule.desc
                );
                return err;
            });
            break;
        case &quot;.html&quot;:
        case &quot;.md&quot;:
        case &quot;.sh&quot;:
            break;
        default:
            // jslint - .js...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return;
    }
    // read file
    local.fs.readFile(opt.file, &quot;utf8&quot;, opt.gotoNext);
    break;
case 2:
    // jslint
    local.jslint.<span class="apidocCodeKeywordSpan">jslintAndPrint</span>(data, opt.file);
    local.assertOrThrow(
        !local.jslint.jslintResult.errMsg,
        local.jslint.jslintResult.errMsg.replace((
            /\u001b\[\d*m/g
        ), &quot;&quot;)
    );
    // validate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslintAutofixLocalFunction" id="apidoc.elem.utility2.jslintAutofixLocalFunction">
        function <span class="apidocSignatureSpan">utility2.</span>jslintAutofixLocalFunction
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAutofixLocalFunction = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint-autofix local-function
 */
</span>    let code2;
    let dictFnc;
    let dictProp;
    let tmp;
    if (local.isBrowser) {
        return code;
    }
    file = local.path.resolve(file).replace(process.cwd() + local.path.sep, &quot;&quot;);
    switch (file) {
    case &quot;README.md&quot;:
    case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.js&quot;:
    case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.sh&quot;:
    case &quot;lib.apidoc.js&quot;:
    case &quot;lib.github_crud.js&quot;:
    case &quot;lib.istanbul.js&quot;:
    case &quot;lib.jslint.js&quot;:
    case &quot;lib.marked.js&quot;:
    case &quot;lib.puppeteer.js&quot;:
    case &quot;npm_scripts.sh&quot;:
    case &quot;test.js&quot;:
        break;
    default:
        return code;
    }
    // autofix - assets.utility2.header.js
    code = code.replace((
        /\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020start\n[\S\s]*?\n\/\/\u0020assets.utility2\.header\.js\u0020-\u0020end\n/
    ), &quot;\n&quot; + local.assetsDict[&quot;/assets.utility2.header.js&quot;]);
    // autofix - assets.my_app.template.js
    code = local.stringMerge(
        code,
        local.assetsDict[&quot;/assets.my_app.template.js&quot;].replace((
            /my_app/g
        ), file.split(&quot;.&quot;)[1]),
        file !== &quot;README.md&quot; &amp;&amp; local.identity(
            /\n\/\*\u0020istanbul\u0020instrument\u0020in\u0020package\u0020[\S\s]*?\n\/\*\u0020validateLineSortedReset\u0020\*\/\n/
        )
    );
    // customize local for assets.utility2.rollup.js
    if (
        file === &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.js&quot;
        &amp;&amp; local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
    ) {
        code = code.replace(
            &quot;    // || globalThis.utility2_rollup_old&quot;,
            &quot;    || globalThis.utility2_rollup_old&quot;
        ).replace(
            &quot;    // || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;,
            &quot;    || require(\&quot;./assets.utility2.rollup.js\&quot;)&quot;
        );
    }
    // init functionAllDict and functionBaseDict
    [
        [
            &quot;utility2&quot;
        ], [
            &quot;utility2&quot;, &quot;apidoc&quot;, &quot;github_crud&quot;
        ]
    ].forEach(function (dictList, ii) {
        tmp = (
            ii
            ? &quot;functionAllDict&quot;
            : &quot;functionBaseDict&quot;
        );
        if (local[tmp]) {
            return;
        }
        local[tmp] = {};
        dictList.forEach(function (dict) {
            dict = local[dict];
            Object.keys(dict).forEach(function (key) {
                if (
                    !(
                        /^[A-Z_]|^testCase_/m
                    ).test(key)
                    &amp;&amp; typeof dict[key] === &quot;function&quot;
                ) {
                    local[tmp][key] = local[tmp][key] || String(dict[key]);
                }
            });
        });
        Object.keys(local[tmp]).forEach(function (key) {
            if (process.binding(&quot;natives&quot;)[key]) {
                local[tmp][key] = undefined;
            }
        });
    });
    // autofix - local-function
    dictFnc = {};
    dictProp = {};
    code = code.replace((
        /^local\.(.*?)\u0020=\u0020(function\u0020\([\S\s]*?\n\});\n+/gm
    ), function (match0, key, match2, match3) {
        // local-function - duplicate
        if (dictFnc[key]) {
            return &quot;&quot;;
        }
        // local-function - normalize
        dictFnc[key] = true;
        match3 = local.functionAllDict[key] || &quot;&quot;;
        // make shell-safe
        // https://unix.stackexchange.com/questions/57794/shell-escape-characters-for-sh-c
        if (file.slice(-3) === &quot;.sh&quot;) {
            match3 = match3.replace((
                /&apos;/g
            ), &quot;&apos;\&quot;&apos;\&quot;&ap...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jsonCopy" id="apidoc.elem.utility2.jsonCopy">
        function <span class="apidocSignatureSpan">utility2.</span>jsonCopy
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsonCopy = function (obj) {
<span class="apidocCodeCommentSpan">/*
 * this function will deep-copy obj
 */
</span>    return (
        obj === undefined
        ? undefined
        : JSON.parse(JSON.stringify(obj))
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}
// try to validate paramDict
opt.err = local.swaggerValidateDataParameters({
    // normalize paramDict
    data: local.normalizeSwaggerParamDict({
        modeNoDefault: opt.modeNoDefault,
        operation: that,
        paramDict: local.<span class="apidocCodeKeywordSpan">jsonCopy</span>(opt.paramDict)
    }).paramDict,
    dataReadonlyRemove: opt.paramDict,
    prefix: [
        &quot;operation&quot;, that._methodPath
    ],
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jsonStringifyOrdered" id="apidoc.elem.utility2.jsonStringifyOrdered">
        function <span class="apidocSignatureSpan">utility2.</span>jsonStringifyOrdered
        <span class="apidocSignatureSpan">(obj, replacer, space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsonStringifyOrdered = function (obj, replacer, space) {
<span class="apidocCodeCommentSpan">/*
 * this function will JSON.stringify &lt;obj&gt;,
 * with object-keys sorted and circular-references removed
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Syntax
 */
</span>    let circularSet;
    let stringify;
    let tmp;
    stringify = function (obj) {
    /*
     * this function will recursively JSON.stringify obj,
     * with object-keys sorted and circular-references removed
     */
        // if obj is not an object or function,
        // then JSON.stringify as normal
        if (!(
            obj
            &amp;&amp; typeof obj === &quot;object&quot;
            &amp;&amp; typeof obj.toJSON !== &quot;function&quot;
        )) {
            return JSON.stringify(obj);
        }
        // ignore circular-reference
        if (circularSet.has(obj)) {
            return;
        }
        circularSet.add(obj);
        // if obj is an array, then recurse items
        if (Array.isArray(obj)) {
            tmp = &quot;[&quot; + obj.map(function (obj) {
                // recurse
                tmp = stringify(obj);
                return (
                    typeof tmp === &quot;string&quot;
                    ? tmp
                    : &quot;null&quot;
                );
            }).join(&quot;,&quot;) + &quot;]&quot;;
            circularSet.delete(obj);
            return tmp;
        }
        // if obj is not an array,
        // then recurse its items with object-keys sorted
        tmp = &quot;{&quot; + Object.keys(obj).sort().map(function (key) {
            // recurse
            tmp = stringify(obj[key]);
            if (typeof tmp === &quot;string&quot;) {
                return JSON.stringify(key) + &quot;:&quot; + tmp;
            }
        }).filter(function (obj) {
            return typeof obj === &quot;string&quot;;
        }).join(&quot;,&quot;) + &quot;}&quot;;
        circularSet.delete(obj);
        return tmp;
    };
    circularSet = new Set();
    return JSON.stringify((
        (typeof obj === &quot;object&quot; &amp;&amp; obj)
        // recurse
        ? JSON.parse(stringify(obj))
        : obj
    ), replacer, space);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
&lt;!-- swgg-script-extra-end --&gt;\n\
&lt;/body&gt;\n\
&lt;/html&gt;\n\
&apos;);
/* jslint ignore:end */
local.assetsDict[
&quot;/assets.swgg.swagger.schema.json&quot;
] = local.<span class="apidocCodeKeywordSpan">jsonStringifyOrdered</span>(
local.objectAssignRecurse(
    JSON.parse(local.assetsDict[&quot;/assets.swgg.json-schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    JSON.parse(local.assetsDict[&quot;/assets.swgg.schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listGetElementRandom" id="apidoc.elem.utility2.listGetElementRandom">
        function <span class="apidocSignatureSpan">utility2.</span>listGetElementRandom
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listGetElementRandom = function (list) {
<span class="apidocCodeCommentSpan">/*
 * this function will return random elem from &lt;list&gt;
 */
</span>    return list[Math.floor(Math.random() * list.length)];
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return local.jsonCopy(schemaP.default);
}
// init enum-value
if (schemaP.enum) {
    value = (
        opt.modeNotRandom
        ? schemaP.enum[0]
        : local.<span class="apidocCodeKeywordSpan">listGetElementRandom</span>(schemaP.enum)
    );
    return (
        local.schemaPType(schemaP) === &quot;array&quot;
        ? [
            value
        ]
        : value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listShuffle" id="apidoc.elem.utility2.listShuffle">
        function <span class="apidocSignatureSpan">utility2.</span>listShuffle
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listShuffle = function (list) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace shuffle &lt;list&gt; using fisher-yates algorithm
 * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
 */
</span>    let ii;
    let random;
    let swap;
    ii = list.length;
    while (ii &gt; 1) {
        ii -= 1;
        random = Math.floor(Math.random() * (ii + 1));
        swap = list[ii];
        list[ii] = list[random];
        list[random] = swap;
    }
    return list;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
opt = {};
// init list
opt.list = &quot;[0,1]&quot;;
// shuffle list 100 times
opt.ii = 0;
while (opt.ii &lt; 100) {
    opt.listShuffled = JSON.stringify(
        local.<span class="apidocCodeKeywordSpan">listShuffle</span>(JSON.parse(opt.list))
    );
    // validate shuffled list
    local.assertJsonEqual(opt.listShuffled.length, opt.list.length);
    opt.changed = opt.changed || opt.listShuffled !== opt.list;
    opt.ii += 1;
}
// validate list changed at least once during shuffle
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerEmit" id="apidoc.elem.utility2.listenerEmit">
        function <span class="apidocSignatureSpan">utility2.</span>listenerEmit
        <span class="apidocSignatureSpan">(type, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerEmit = function (type, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will emit evt &lt;type&gt; with &lt;msg&gt;
 */
</span>    Array.from(dict[type] || []).forEach(function (listener) {
        listener(msg);
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerOn" id="apidoc.elem.utility2.listenerOn">
        function <span class="apidocSignatureSpan">utility2.</span>listenerOn
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerOn = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let isDone;
    if (typeof listener === &quot;function&quot;) {
        dict[type] = dict[type] || [];
        dict[type].push(
            opt.once
            ? function listener2(msg) {
                remove(type, listener2);
                if (!isDone) {
                    isDone = true;
                    listener(msg);
                }
            }
            : listener
        );
    }
    return that;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerOnce" id="apidoc.elem.utility2.listenerOnce">
        function <span class="apidocSignatureSpan">utility2.</span>listenerOnce
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerOnce = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
 */
</span>    opt.once = true;
    return on(type, listener, opt);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.listenerRemove" id="apidoc.elem.utility2.listenerRemove">
        function <span class="apidocSignatureSpan">utility2.</span>listenerRemove
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listenerRemove = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.localStorageSetItemOrClear" id="apidoc.elem.utility2.localStorageSetItemOrClear">
        function <span class="apidocSignatureSpan">utility2.</span>localStorageSetItemOrClear
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">localStorageSetItemOrClear = function (key, value) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to set &lt;key&gt;/&lt;value&gt; pair to localStorage,
 * or else call localStorage.clear()
 */
</span>    try {
        localStorage.setItem(key, value);
    } catch (ignore) {
        localStorage.clear();
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    );
    local.apiKeyValue = localStorage.getItem(local.apiKeyKey) || &quot;&quot;;
// save apiKeyValue
} else {
    local.apiKeyValue = document.querySelector(
        &quot;#swggApiKeyInput1&quot;
    ).value;
    local.<span class="apidocCodeKeywordSpan">localStorageSetItemOrClear</span>(
        local.apiKeyKey,
        local.apiKeyValue
    );
}
// if keyup-evt is not return-key, then return
if (
    (opt.type === &quot;keyup&quot; &amp;&amp; opt.code !== &quot;Enter&quot;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked" id="apidoc.elem.utility2.marked">
        function <span class="apidocSignatureSpan">utility2.</span>marked
        <span class="apidocSignatureSpan">(e, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c
(e, n, r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
)+&quot;&lt;/pre&gt;&quot;;throw h}}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer" id="apidoc.elem.utility2.marked.InlineLexer">
        function <span class="apidocSignatureSpan">utility2.</span>marked.InlineLexer
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function r(e, t){this.options=t||c.defaults,this.links=
e,this.rules=n.normal,this.renderer=this.options.renderer||new i,this.renderer.options=
this.options;if(!this.links)throw new Error(&quot;Tokens array requires a `links` property.&quot;
);this.options.gfm?this.options.breaks?this.rules=n.breaks:this.rules=n.gfm:this
.options.pedantic&amp;&amp;(this.rules=n.pedantic)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer" id="apidoc.elem.utility2.marked.Lexer">
        function <span class="apidocSignatureSpan">utility2.</span>marked.Lexer
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function t(t){this.tokens=[],this.tokens.links={},this.options=t||c.
defaults,this.rules=e.normal,this.options.gfm&amp;&amp;(this.options.tables?this.rules=e
.tables:this.rules=e.gfm)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser" id="apidoc.elem.utility2.marked.Parser">
        function <span class="apidocSignatureSpan">utility2.</span>marked.Parser
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function s
(e){this.tokens=[],this.token=null,this.options=e||c.defaults,this.options.renderer=
this.options.renderer||new i,this.renderer=this.options.renderer,this.renderer.options=
this.options}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer" id="apidoc.elem.utility2.marked.Renderer">
        function <span class="apidocSignatureSpan">utility2.</span>marked.Renderer
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function i(e){this.options=e||{}}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareAssetsCached" id="apidoc.elem.utility2.middlewareAssetsCached">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareAssetsCached
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareAssetsCached = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to serve cached-assets
 */
</span>    if (!local.assetsDict.hasOwnProperty(req.urlParsed.pathname)) {
        next();
        return;
    }
    // do not cache if headers already sent or url has &apos;?&apos; search indicator
    if (!(res.headersSent || req.url.indexOf(&quot;?&quot;) &gt;= 0)) {
        // init serverResponseHeaderLastModified
        local.serverResponseHeaderLastModified = (
            local.serverResponseHeaderLastModified
            // resolve to 1000 ms
            || new Date(new Date().toUTCString())
        );
        // respond with 304 If-Modified-Since serverResponseHeaderLastModified
        if (
            new Date(req.headers[&quot;if-modified-since&quot;])
            &gt;= local.serverResponseHeaderLastModified
        ) {
            res.statusCode = 304;
            res.end();
            return;
        }
        res.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
        res.setHeader(
            &quot;Last-Modified&quot;,
            local.serverResponseHeaderLastModified.toUTCString()
        );
    }
    res.end(local.assetsDict[req.urlParsed.pathname]);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareBodyRead" id="apidoc.elem.utility2.middlewareBodyRead">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareBodyRead
        <span class="apidocSignatureSpan">(req, ignore, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareBodyRead = function (req, ignore, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * read and save &lt;req&gt; body to &lt;req&gt;.bodyRaw
 */
</span>    // if req is already read, then goto next
    if (!req.readable) {
        next();
        return;
    }
    let bufList;
    bufList = [];
    req.on(&quot;data&quot;, function (buf) {
        bufList.push(buf);
    }).on(&quot;end&quot;, function () {
        req.bodyRaw = (
            local.isBrowser
            ? bufList[0]
            : Buffer.concat(bufList)
        );
        next();
    // on event-error, pass error to onError
    }).on(&quot;error&quot;, next);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
/*
* this function will run test-middleware
*/
   switch (req.urlParsed.pathname) {
   // test http POST handling-behavior
   case &quot;/test.body&quot;:
       // test req-body-read handling-behavior
       local.<span class="apidocCodeKeywordSpan">middlewareBodyRead</span>(req, res, function () {
           // test multiple req-body-read handling-behavior
           local.middlewareBodyRead(req, res, function () {
               res.write(req.bodyRaw);
               res.end();
           });
       });
       break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareError" id="apidoc.elem.utility2.middlewareError">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareError
        <span class="apidocSignatureSpan">(err, req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareError = function (err, req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to handle errors
 */
</span>    // default - 404 Not Found
    if (!err) {
        local.serverRespondDefault(req, res, 404);
        return;
    }
    // statusCode [400, 600)
    local.serverRespondDefault(req, res, (
        (err.statusCode &gt;= 400 &amp;&amp; err.statusCode &lt; 600)
        ? err.statusCode
        : 500
    ), err);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}
globalThis.utility2_onReadyBefore.cnt += 1;
local.serverLocalReqHandler = function (req, res) {
    let that;
    that = {};
    local.gotoNext(that, function (err) {
        if (err || that.gotoState &gt;= local.middlewareList.length) {
            local.<span class="apidocCodeKeywordSpan">middlewareError</span>(err, req, res);
            return;
        }
        // recurse with next middleware in middlewareList
        local.middlewareList[that.gotoState](req, res, that.gotoNext);
    });
    that.gotoState = -1;
    that.gotoNext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareFileServer" id="apidoc.elem.utility2.middlewareFileServer">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareFileServer
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareFileServer = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to serve files
 */
</span>    let file;
    if (req.method !== &quot;GET&quot; || local.isBrowser) {
        next();
        return;
    }
    // resolve file
    file = require(&quot;path&quot;).resolve(
        // replace trailing &quot;/&quot; with &quot;/index.html&quot;
        require(&quot;url&quot;).parse(req.url).pathname.slice(1).replace((
            /\/$/
        ), &quot;/index.html&quot;)
    );
    // security - disable parent-directory lookup
    if (file.indexOf(process.cwd() + require(&quot;path&quot;).sep) !== 0) {
        next();
        return;
    }
    require(&quot;fs&quot;).readFile(file, function (err, data) {
        // default to next
        if (err) {
            next();
            return;
        }
        // respond with data
        res.end(data);
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    case &quot;/test.timeout&quot;:
        setTimeout(function () {
            res.end();
        }, 2000);
        break;
    // serve file
    default:
        local.<span class="apidocCodeKeywordSpan">middlewareFileServer</span>(req, res, next);
    }
});
}());



// run node js-env code - init-after
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareForwardProxy" id="apidoc.elem.utility2.middlewareForwardProxy">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareForwardProxy
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareForwardProxy = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to forward-proxy &lt;req&gt;
 * to its destination-host
 */
</span>    let clientHeaders;
    let clientReq;
    let clientRes;
    let clientUrl;
    let isDone;
    let onError;
    let timeStart;
    let timerTimeout;
    // handle preflight-cors
    if (req.method === &quot;OPTIONS&quot; &amp;&amp; (
        /forward-proxy-url/
    ).test(req.headers[&quot;access-control-request-headers&quot;])) {
        local.serverRespondHeadSet(req, res, undefined, {
            &quot;access-control-allow-headers&quot;: &quot;*&quot;,
            &quot;access-control-allow-methods&quot;: &quot;*&quot;,
            &quot;access-control-allow-origin&quot;: &quot;*&quot;
        });
        res.end();
        return;
    }
    if (!req.headers[&quot;forward-proxy-url&quot;]) {
        next();
        return;
    }
    local.serverRespondHeadSet(req, res, undefined, {
        &quot;access-control-allow-headers&quot;: &quot;*&quot;,
        &quot;access-control-allow-methods&quot;: &quot;*&quot;,
        &quot;access-control-allow-origin&quot;: &quot;*&quot;
    });
    // init onError
    onError = function (err) {
        if (isDone) {
            return;
        }
        isDone = true;
        // cleanup timerTimeout
        clearTimeout(timerTimeout);
        // debug middlewareForwardProxy
        console.error(&quot;serverLog - &quot; + JSON.stringify({
            time: new Date(timeStart).toISOString(),
            type: &quot;middlewareForwardProxyResponse&quot;,
            method: req.method,
            clientUrl,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - timeStart,
            // extra
            headers: clientHeaders
        }) + &quot;\n&quot;);
        if (!err) {
            return;
        }
        // cleanup clientReq and clientRes
        local.streamCleanup(clientReq);
        local.streamCleanup(clientRes);
        next(err);
    };
    // init timerTimeout
    timerTimeout = setTimeout(
        onError,
        local.timeoutDefault,
        new Error(
            &quot;timeout - &quot; + local.timeoutDefault + &quot; ms - &quot;
            + &quot;forward-proxy &quot; + req.method + &quot; &quot; + clientUrl
        )
    );
    // init client
    clientUrl = local.urlParse(req.headers[&quot;forward-proxy-url&quot;]).href;
    try {
        clientHeaders = {};
        clientHeaders = JSON.parse(req.headers[&quot;forward-proxy-headers&quot;]);
    } catch (ignore) {}
    clientReq = require(
        clientUrl.indexOf(&quot;http:&quot;) === 0
        ? &quot;http&quot;
        : &quot;https&quot;
    ).request(clientUrl, {
        headers: clientHeaders
    }, function (arg) {
        clientRes = arg;
        clientRes.on(&quot;error&quot;, onError);
        res.statusCode = clientRes.statusCode;
        // pipe clientRes to res
        clientRes.pipe(res);
    }).on(&quot;error&quot;, onError);
    timeStart = Date.now();
    // handle evt
    req.on(&quot;error&quot;, onError);
    res.on(&quot;finish&quot;, onError).on(&quot;error&quot;, onError);
    // pipe req to clientReq
    req.pipe(clientReq);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareInit" id="apidoc.elem.utility2.middlewareInit">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareInit
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareInit = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to init &lt;req&gt; and &lt;res&gt;
 */
</span>    let contentType;
    // debug req and res
    local._debugServerReqRes4 = local._debugServerReqRes3;
    local._debugServerReqRes3 = local._debugServerReqRes2;
    local._debugServerReqRes2 = local._debugServerReqRes1;
    local._debugServerReqRes1 = {
        req,
        res
    };
    // init timerTimeout
    local.serverRespondTimeoutDefault(req, res, local.timeoutDefault);
    // init req.urlParsed
    req.urlParsed = local.urlParse(req.url);
    // set reponse-header &quot;content-type&quot;
    contentType = {
        // application
        &quot;.js&quot;: &quot;application/javascript; charset=utf-8&quot;,
        &quot;.json&quot;: &quot;application/json; charset=utf-8&quot;,
        &quot;.pdf&quot;: &quot;application/pdf&quot;,
        &quot;.wasm&quot;: &quot;application/wasm&quot;,
        &quot;.xml&quot;: &quot;application/xml; charset=utf-8&quot;,
        // image
        &quot;.bmp&quot;: &quot;image/bmp&quot;,
        &quot;.gif&quot;: &quot;image/gif&quot;,
        &quot;.jpe&quot;: &quot;image/jpeg&quot;,
        &quot;.jpeg&quot;: &quot;image/jpeg&quot;,
        &quot;.jpg&quot;: &quot;image/jpeg&quot;,
        &quot;.png&quot;: &quot;image/png&quot;,
        &quot;.svg&quot;: &quot;image/svg+xml; charset=utf-8&quot;,
        // text
        &quot;/&quot;: &quot;text/html; charset=utf-8&quot;,
        &quot;.css&quot;: &quot;text/css; charset=utf-8&quot;,
        &quot;.htm&quot;: &quot;text/html; charset=utf-8&quot;,
        &quot;.html&quot;: &quot;text/html; charset=utf-8&quot;,
        &quot;.md&quot;: &quot;text/markdown; charset=utf-8&quot;,
        &quot;.txt&quot;: &quot;text/plain; charset=utf-8&quot;
    };
    contentType = contentType[(
        /^\/$|\.[^.]*?$|$/m
    ).exec(req.urlParsed.pathname)[0]];
    if (contentType) {
        res.setHeader(&quot;content-type&quot;, contentType);
    }
    // default to next
    next();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.middlewareJsonpStateInit" id="apidoc.elem.utility2.middlewareJsonpStateInit">
        function <span class="apidocSignatureSpan">utility2.</span>middlewareJsonpStateInit
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middlewareJsonpStateInit = function (req, res, next) {
<span class="apidocCodeCommentSpan">/*
 * this function will run middleware to
 * serve browser-state wrapped in given jsonp-callback
 */
</span>    let state;
    if (!(req.stateInit || (
        req.urlParsed
        &amp;&amp; req.urlParsed.pathname === &quot;/jsonp.utility2.stateInit&quot;
    ))) {
        next();
        return;
    }
    state = {
        utility2: {
            assetsDict: {
                &quot;/assets.example.html&quot;:
                local.assetsDict[&quot;/assets.example.html&quot;],
                &quot;/assets.example.js&quot;: local.assetsDict[&quot;/assets.example.js&quot;],
                &quot;/assets.test.js&quot;: local.assetsDict[&quot;/assets.test.js&quot;],
                &quot;/index.rollup.html&quot;: local.assetsDict[&quot;/index.rollup.html&quot;]
            },
            env: {
                NODE_ENV: local.env.NODE_ENV,
                npm_config_mode_backend: local.env.npm_config_mode_backend,
                npm_package_description: local.env.npm_package_description,
                npm_package_homepage: local.env.npm_package_homepage,
                npm_package_name: local.env.npm_package_name,
                npm_package_nameLib: local.env.npm_package_nameLib,
                npm_package_version: local.env.npm_package_version
            }
        }
    };
    if (req.stateInit) {
        return state;
    }
    res.end(
        req.urlParsed.query.callback + &quot;(&quot; + JSON.stringify(state) + &quot;);&quot;
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    code += local.assetsDict[tmp];
    break;
case &quot;local.stateInit&quot;:
    // handle large string-replace
    code = local.assetsDict[&quot;/assets.utility2.rollup.content.js&quot;].split(
        &quot;/* utility2.rollup.js content */&quot;
    );
    tmp = local.<span class="apidocCodeKeywordSpan">middlewareJsonpStateInit</span>({
        stateInit: true
    });
    // add extra physical files to assetsDict
    local.fs.readdirSync(&quot;.&quot;).forEach(function (file) {
        file = &quot;/&quot; + file;
        if (
            local.assetsDict[file]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.moduleDirname" id="apidoc.elem.utility2.moduleDirname">
        function <span class="apidocSignatureSpan">utility2.</span>moduleDirname
        <span class="apidocSignatureSpan">(module, pathList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moduleDirname = function (module, pathList) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
 */
</span>    let result;
    // search &quot;.&quot;
    if (!module || module === &quot;.&quot; || module.indexOf(&quot;/&quot;) &gt;= 0) {
        return require(&quot;path&quot;).resolve(module || &quot;&quot;);
    }
    // search pathList
    Array.from([
        pathList,
        require(&quot;module&quot;).globalPaths,
        [
            process.env.HOME + &quot;/node_modules&quot;, &quot;/usr/local/lib/node_modules&quot;
        ]
    ]).flat().some(function (path) {
        try {
            result = require(&quot;path&quot;).resolve(path + &quot;/&quot; + module);
            result = require(&quot;fs&quot;).statSync(result).isDirectory() &amp;&amp; result;
            return result;
        } catch (ignore) {
            result = &quot;&quot;;
        }
    });
    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return match0.replace((
            /(.{128}(?:\b|\w+))/g
        ), &quot;$1\n&quot;).trimEnd();
    });
    return str;
};
// init opt
opt.dir = local.<span class="apidocCodeKeywordSpan">moduleDirname</span>(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectAssignDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.nop" id="apidoc.elem.utility2.nop">
        function <span class="apidocSignatureSpan">utility2.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - function
(function () {
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(require);
globalThis.__coverageInclude__ = local.coalesce(
globalThis.__coverageInclude__,
{}
);
// mock builtins
process = local.process || {
cwd: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.normalizeJwt" id="apidoc.elem.utility2.normalizeJwt">
        function <span class="apidocSignatureSpan">utility2.</span>normalizeJwt
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeJwt = function (data) {
<span class="apidocCodeCommentSpan">/*
 * this function will normalize jwt-data with registered-headers
 * https://tools.ietf.org/html/rfc7519#section-4.1
 */
</span>    let timeNow;
    timeNow = Date.now() / 1000;
    return local.objectAssignDefault(data, {
        exp: timeNow + 5 * 60,
        iat: timeNow,
        jti: Math.random().toString(16).slice(2),
        nbf: timeNow
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.normalizeJwtBase64Url" id="apidoc.elem.utility2.normalizeJwtBase64Url">
        function <span class="apidocSignatureSpan">utility2.</span>normalizeJwtBase64Url
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeJwtBase64Url = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will normlize &lt;str&gt; to base64url format
 */
</span>    return str.replace((
        /\=/g
    ), &quot;&quot;).replace((
        /\+/g
    ), &quot;-&quot;).replace((
        /\//g
    ), &quot;_&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.numberToRomanNumerals" id="apidoc.elem.utility2.numberToRomanNumerals">
        function <span class="apidocSignatureSpan">utility2.</span>numberToRomanNumerals
        <span class="apidocSignatureSpan">(num)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberToRomanNumerals = function (num) {
<span class="apidocCodeCommentSpan">/*
 * this function will convert num to a roman-numeral
 * https://stackoverflow.com/questions/9083037/convert-a-number-into-a-roman-numeral-in-javascript
 */
</span>    let digits;
    let ii;
    let key;
    let roman;
    digits = String(num).split(&quot;&quot;);
    key = [
        &quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;,
        &quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;,
        &quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;
    ];
    roman = &quot;&quot;;
    ii = 3;
    while (ii) {
        ii -= 1;
        roman = (key[Number(digits.pop()) + (ii * 10)] || &quot;&quot;) + roman;
    }
    return new Array(Number(digits.join(&quot;&quot;) + 1)).join(&quot;M&quot;) + roman;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        &quot;XCVIII&quot;,
        &quot;XCIX&quot;,
        &quot;C&quot;
    ];
    opt.ii = 0;
    while (opt.ii &lt; 10) {
        local.assertJsonEqual(
            local.<span class="apidocCodeKeywordSpan">numberToRomanNumerals</span>(opt.ii),
            opt.list[opt.ii]
        );
        opt.ii += 1;
    }
    onError(undefined, opt);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.objectAssignDefault" id="apidoc.elem.utility2.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (tgt = {}, src = {}, depth = 0) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;tgt&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;src&gt;
 */
</span>    let recurse;
    recurse = function (tgt, src, depth) {
        Object.entries(src).forEach(function ([
            key, bb
        ]) {
            let aa;
            aa = tgt[key];
            if (aa === undefined || aa === null || aa === &quot;&quot;) {
                tgt[key] = bb;
                return;
            }
            if (
                depth !== 0
                &amp;&amp; typeof aa === &quot;object&quot; &amp;&amp; aa &amp;&amp; !Array.isArray(aa)
                &amp;&amp; typeof bb === &quot;object&quot; &amp;&amp; bb &amp;&amp; !Array.isArray(bb)
            ) {
                recurse(aa, bb, depth - 1);
            }
        });
    };
    recurse(tgt, src, depth | 0);
    return tgt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return str;
};
// init opt
opt.dir = local.moduleDirname(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.parse(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.objectAssignRecurse" id="apidoc.elem.utility2.objectAssignRecurse">
        function <span class="apidocSignatureSpan">utility2.</span>objectAssignRecurse
        <span class="apidocSignatureSpan">(dict, overrides, depth, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignRecurse = function (dict, overrides, depth, env) {
<span class="apidocCodeCommentSpan">/*
 * this function will recursively set overrides for items in dict
 */
</span>    dict = dict || {};
    env = env || (typeof process === &quot;object&quot; &amp;&amp; process.env) || {};
    overrides = overrides || {};
    Object.keys(overrides).forEach(function (key) {
        let dict2;
        let overrides2;
        dict2 = dict[key];
        overrides2 = overrides[key];
        if (overrides2 === undefined) {
            return;
        }
        // if both dict2 and overrides2 are non-undefined and non-array objects,
        // then recurse with dict2 and overrides2
        if (
            depth &gt; 1
            // dict2 is a non-undefined and non-array object
            &amp;&amp; typeof dict2 === &quot;object&quot; &amp;&amp; dict2 &amp;&amp; !Array.isArray(dict2)
            // overrides2 is a non-undefined and non-array object
            &amp;&amp; typeof overrides2 === &quot;object&quot; &amp;&amp; overrides2
            &amp;&amp; !Array.isArray(overrides2)
        ) {
            local.objectAssignRecurse(dict2, overrides2, depth - 1, env);
            return;
        }
        // else set dict[key] with overrides[key]
        dict[key] = (
            dict === env
            // if dict is env, then overrides falsy-value with empty-string
            ? overrides2 || &quot;&quot;
            : overrides2
        );
    });
    return dict;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
&lt;/body&gt;\n\
&lt;/html&gt;\n\
&apos;);
/* jslint ignore:end */
local.assetsDict[
&quot;/assets.swgg.swagger.schema.json&quot;
] = local.jsonStringifyOrdered(
local.<span class="apidocCodeKeywordSpan">objectAssignRecurse</span>(
    JSON.parse(local.assetsDict[&quot;/assets.swgg.json-schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    JSON.parse(local.assetsDict[&quot;/assets.swgg.schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.on" id="apidoc.elem.utility2.on">
        function <span class="apidocSignatureSpan">utility2.</span>on
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let isDone;
    if (typeof listener === &quot;function&quot;) {
        dict[type] = dict[type] || [];
        dict[type].push(
            opt.once
            ? function listener2(msg) {
                remove(type, listener2);
                if (!isDone) {
                    isDone = true;
                    listener(msg);
                }
            }
            : listener
        );
    }
    return that;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
         */
let bufList;
bufList = [];
xhr.resHeaders = resStream.headers || xhr.resHeaders;
xhr.resStream = resStream;
xhr.statusCode = resStream.statusCode;
resStream.dataLength = 0;
resStream.<span class="apidocCodeKeywordSpan">on</span>(&quot;data&quot;, function (buf) {
    bufList.push(buf);
});
resStream.on(&quot;end&quot;, function () {
    xhr.response = (
        local.isBrowser
        ? bufList[0]
        : Buffer.concat(bufList)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onErrorDefault" id="apidoc.elem.utility2.onErrorDefault">
        function <span class="apidocSignatureSpan">utility2.</span>onErrorDefault
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorDefault = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then print it to stderr
 */
</span>    if (err) {
        console.error(err);
    }
    return err;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.onParallel(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.<span class="apidocCodeKeywordSpan">onErrorDefault</span>(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.cnt -= 1;
            onEach(data, onParallel);
        }, 1000);
        return true;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onErrorThrow" id="apidoc.elem.utility2.onErrorThrow">
        function <span class="apidocSignatureSpan">utility2.</span>onErrorThrow
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorThrow = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then throw it
 */
</span>    if (err) {
        throw err;
    }
    return err;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.testCase_onErrorThrow_err = function (opt, onError) {
/*
 * this function will test onErrorThrow&apos;s err handling-behavior
 */
    local.tryCatchOnError(function () {
        local.<span class="apidocCodeKeywordSpan">onErrorThrow</span>(local.errorDefault);
    }, function (err) {
        // handle err
        local.assertOrThrow(err, err);
        onError(undefined, opt);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onErrorWithStack" id="apidoc.elem.utility2.onErrorWithStack">
        function <span class="apidocSignatureSpan">utility2.</span>onErrorWithStack
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorWithStack = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap &lt;onError&gt; with wrapper preserving current-stack
 */
</span>    let onError2;
    let stack;
    stack = new Error().stack;
    onError2 = function (err, data, meta) {
        // append current-stack to err.stack
        if (
            err
            &amp;&amp; typeof err.stack === &quot;string&quot;
            &amp;&amp; err !== local.errorDefault
        ) {
            err.stack += &quot;\n&quot; + stack;
        }
        onError(err, data, meta);
    };
    // debug onError
    onError2.toString = function () {
        return String(onError);
    };
    return onError2;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.<span class="apidocCodeKeywordSpan">onErrorWithStack</span>(function (err, data, meta) {
       try {
           opt.gotoState += (
               (err &amp;&amp; !opt.modeErrorIgnore)
               ? 1000
               : 1
           );
           if (opt.modeDebug) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onFileModifiedRestart" id="apidoc.elem.utility2.onFileModifiedRestart">
        function <span class="apidocSignatureSpan">utility2.</span>onFileModifiedRestart
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onFileModifiedRestart = function (file) {
<span class="apidocCodeCommentSpan">/*
 * this function will watch &lt;file&gt;, and if modified, then restart process
 */
</span>    if (
        local.env.npm_config_mode_auto_restart
        &amp;&amp; local.fs.existsSync(file)
        &amp;&amp; local.fs.statSync(file).isFile()
    ) {
        local.fs.watchFile(file, {
            interval: 1000,
            persistent: false
        }, function (stat2, stat1) {
            if (stat2.mtime &gt; stat1.mtime) {
                console.error(&quot;file modified - &quot; + file);
                setTimeout(function () {
                    process.exit(77);
                }, 1000);
            }
        });
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
[
    __dirname + &quot;/lib.jslint.js&quot;,
    __filename,
    &quot;undefined&quot;
].forEach(function (file) {
    local.fs.exists(file, function (exists) {
        if (exists) {
            local.<span class="apidocCodeKeywordSpan">onFileModifiedRestart</span>(file);
        }
    });
});
// if file is modified, then restart process
local.fs.readdirSync(&quot;.&quot;).forEach(function (file) {
    local.onFileModifiedRestart(file);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onParallel" id="apidoc.elem.utility2.onParallel">
        function <span class="apidocSignatureSpan">utility2.</span>onParallel
        <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallel = function (onError, onEach, onRetry) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a function that will
 * 1. run async tasks in parallel
 * 2. if cnt === 0 or err occurred, then call onError(err)
 */
</span>    let onParallel;
    onError = local.onErrorWithStack(onError);
    onEach = onEach || local.nop;
    onRetry = onRetry || local.nop;
    onParallel = function (err, data) {
        if (onRetry(err, data)) {
            return;
        }
        // decrement cnt
        onParallel.cnt -= 1;
        // validate cnt
        if (!(onParallel.cnt &gt;= 0 || err || onParallel.err)) {
            err = new Error(
                &quot;invalid onParallel.cnt = &quot; + onParallel.cnt
            );
        // ensure onError is run only once
        } else if (onParallel.cnt &lt; 0) {
            return;
        }
        // handle err
        if (err) {
            onParallel.err = err;
            // ensure cnt &lt;= 0
            onParallel.cnt = -Math.abs(onParallel.cnt);
        }
        // call onError when isDone
        if (onParallel.cnt &lt;= 0) {
            onError(err, data);
            return;
        }
        onEach();
    };
    // init cnt
    onParallel.cnt = 0;
    // return callback
    return onParallel;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            elem: opt.list[onParallel.ii],
            ii: onParallel.ii,
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.<span class="apidocCodeKeywordSpan">onParallel</span>(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.onErrorDefault(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.cnt -= 1;
            onEach(data, onParallel);
        }, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.onParallelList" id="apidoc.elem.utility2.onParallelList">
        function <span class="apidocSignatureSpan">utility2.</span>onParallelList
        <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallelList = function (opt, onEach, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. async-run onEach in parallel,
 *    with given &lt;opt&gt;.rateLimit and &lt;opt&gt;.retryLimit
 * 2. call &lt;onError&gt; when onParallel.ii + 1 === &lt;opt&gt;.list.length
 */
</span>    let isListEnd;
    let onEach2;
    let onParallel;
    opt.list = opt.list || [];
    onEach2 = function () {
        while (true) {
            if (!(onParallel.ii + 1 &lt; opt.list.length)) {
                isListEnd = true;
                return;
            }
            if (!(onParallel.cnt &lt; opt.rateLimit + 1)) {
                return;
            }
            onParallel.ii += 1;
            onEach({
                elem: opt.list[onParallel.ii],
                ii: onParallel.ii,
                list: opt.list,
                retry: 0
            }, onParallel);
        }
    };
    onParallel = local.onParallel(onError, onEach2, function (err, data) {
        if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
            local.onErrorDefault(err);
            data.retry += 1;
            setTimeout(function () {
                onParallel.cnt -= 1;
                onEach(data, onParallel);
            }, 1000);
            return true;
        }
        // restart if opt.list has grown
        if (isListEnd &amp;&amp; (onParallel.ii + 1 &lt; opt.list.length)) {
            isListEnd = undefined;
            onEach2();
        }
    });
    onParallel.ii = -1;
    opt.rateLimit = Number(opt.rateLimit) || 6;
    opt.rateLimit = Math.max(opt.rateLimit, 1);
    opt.retryLimit = Number(opt.retryLimit) || 2;
    onParallel.cnt += 1;
    onEach2();
    onParallel();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        method: &quot;DELETE&quot;,
        sha: data.sha,
        url: opt.url
    }, opt.gotoNext);
    return;
}
// delete tree
local.<span class="apidocCodeKeywordSpan">onParallelList</span>({
    list: data
}, function (opt2, onParallel) {
    onParallel.cnt += 1;
    // recurse
    local.githubCrudContentDelete({
        httpReq: opt.httpReq,
        message: opt.message,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.once" id="apidoc.elem.utility2.once">
        function <span class="apidocSignatureSpan">utility2.</span>once
        <span class="apidocSignatureSpan">(type, listener, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (type, listener, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will listen to evt &lt;type&gt; once with &lt;listener&gt;
 */
</span>    opt.once = true;
    return on(type, listener, opt);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  /**
   * Close the server.
   *
   * @param {Function} cb Callback
   * @public
   */
  close(cb) {
if (cb) this.<span class="apidocCodeKeywordSpan">once</span>(&apos;close&apos;, cb);

//
// Terminate all associated clients.
//
if (this.clients) {
  for (const client of this.clients) client.terminate();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.promisify" id="apidoc.elem.utility2.promisify">
        function <span class="apidocSignatureSpan">utility2.</span>promisify
        <span class="apidocSignatureSpan">(fnc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promisify = function (fnc) {
<span class="apidocCodeCommentSpan">/*
 * this function will promisify &lt;fnc&gt;
 */
</span>    return function (...argList) {
        return new Promise(function (resolve, reject) {
            fnc(...argList, function (err, ...argList) {
                if (err) {
                    reject(err, ...argList);
                    return;
                }
                resolve(...argList);
            });
        });
    };
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
     resultBuffer = Buffer.concat(bufs);
   } finally {
     return resultBuffer;
   }
 }
}

const openAsync = Helper.<span class="apidocCodeKeywordSpan">promisify</span>(fs.open);
const writeAsync = Helper.promisify(fs.write);
const closeAsync = Helper.promisify(fs.close);

/**
* @param {*} value
* @param {string=} message
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteerLaunch" id="apidoc.elem.utility2.puppeteerLaunch">
        function <span class="apidocSignatureSpan">utility2.</span>puppeteerLaunch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">puppeteerLaunch = function () { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">...
    local.timeoutDefault,
    new Error(
        &quot;timeout - &quot; + local.timeoutDefault + &quot; ms - &quot;
        + testName
    )
);
// create puppeteer browser
local.<span class="apidocCodeKeywordSpan">puppeteerLaunch</span>({
    args: [
        &quot;--headless&quot;,
        &quot;--incognito&quot;,
        &quot;--no-sandbox&quot;,
        &quot;--remote-debugging-port=0&quot;
    ],
    dumpio: !opt.modeSilent,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.removeEventListener" id="apidoc.elem.utility2.removeEventListener">
        function <span class="apidocSignatureSpan">utility2.</span>removeEventListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeEventListener = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.removeListener" id="apidoc.elem.utility2.removeListener">
        function <span class="apidocSignatureSpan">utility2.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (type, listener) {
<span class="apidocCodeCommentSpan">/*
 * this function will stop listening to evt &lt;type&gt; with &lt;listener&gt;
 */
</span>    let ii;
    let list;
    list = dict[type] || [];
    ii = list.length;
    while (ii &gt; 0) {
        ii -= 1;
        if (list[ii] === listener) {
            list.splice(ii, 1);
        }
    }
    return that;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   * @public
   */
  removeEventListener(method, listener) {
    const listeners = this.listeners(method);

    for (var i = 0; i &lt; listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.<span class="apidocCodeKeywordSpan">removeListener</span>(method, listeners[i]);
      }
    }
  }
};

exports_websockets_ws_lib_event_target = EventTarget;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.replStart" id="apidoc.elem.utility2.replStart">
        function <span class="apidocSignatureSpan">utility2.</span>replStart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replStart = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will start repl-debugger
 */
</span>    let that;
    if (globalThis.utility2_repl1) {
        return;
    }
    // start repl
    that = require(&quot;repl&quot;).start({
        useGlobal: true
    });
    globalThis.utility2_repl1 = that;
    // save eval-function
    that.evalDefault = that.eval;
    // hook custom-eval-function
    that.eval = function (script, context, file, onError) {
        script.replace((
            /^(\S+)\u0020(.*?)\n/
        ), function (ignore, match1, match2) {
            switch (match1) {
            // syntax-sugar - run shell-command
            case &quot;$&quot;:
                match2 = match2.replace((
                    /^git\b/
                ), &quot;git --no-pager&quot;);
                switch (match2) {
                // syntax-sugar - run git diff
                case &quot;git diff&quot;:
                    match2 = &quot;git diff --color&quot;;
                    break;
                // syntax-sugar - run git log
                case &quot;git log&quot;:
                    match2 = &quot;git log -n 4&quot;;
                    break;
                // syntax-sugar - run ll
                case &quot;ll&quot;:
                    match2 = &quot;ls -Fal&quot;;
                    break;
                }
                // source lib.utility2.sh
                if (
                    process.platform !== &quot;win32&quot;
                    &amp;&amp; process.env.npm_config_dir_utility2 &amp;&amp; (match2 !== &quot;:&quot;)
                ) {
                    match2 = (
                        &quot;. &quot; + process.env.npm_config_dir_utility2
                        + &quot;/lib.utility2.sh;&quot; + match2
                    );
                }
                // run shell-command
                require(&quot;child_process&quot;).spawn(match2, {
                    shell: true,
                    stdio: [
                        &quot;ignore&quot;, 1, 2
                    ]
                // print exitCode
                }).on(&quot;exit&quot;, function (exitCode) {
                    console.error(&quot;exitCode &quot; + exitCode);
                    that.evalDefault(&quot;\n&quot;, context, file, onError);
                });
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - map text with charCodeAt
            case &quot;charCode&quot;:
                console.error(
                    match2.split(&quot;&quot;).map(function (chr) {
                        return (
                            &quot;\\u&quot;
                            + chr.charCodeAt(0).toString(16).padStart(4, 0)
                        );
                    }).join(&quot;&quot;)
                );
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - sort chr
            case &quot;charSort&quot;:
                console.error(JSON.stringify(match2.split(&quot;&quot;).sort().join(&quot;&quot;)));
                script = &quot;\n&quot;;
                break;
            // syntax-sugar - grep current dir
            case &quot;grep&quot;:
                // run shell-command
                require(&quot;child_process&quot;).spawn((
                    &quot;find . -type f | grep -v -E &quot;
/* jslint ignore:start */
+ &apos;&quot;\
/\\.|~\$|/(obj|release)/|(\\b|_)(\\.\\d|\
archive|artifact|\
bower_component|build|\
coverage|\
doc|\
external|\
fixture|\
git_module|\
jquery|\
log|\
min|misc|mock|\
node_module|\
raw|\rollup|\
swp|\
tmp|\
vendor)s{0,1}(\\b|_)\
&quot; &apos;
/* jslint ignore:end */
                    + &quot;| tr \&quot;\\n\&quot; \&quot;\\000\&quot; | xargs -0 grep -HIin -E \&quot;&quot;
                    + match2 + &quot;\&quot;&quot;
                ), {
                    shell: true,
                    stdio: [
                        &quot;ignore&quot;, 1, 2
                    ]
                }).on(&quot;exit&quot;, function (exitCode) {
                    console.error(&qu...</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict[&quot;utility2.start&quot;] = function () {
/*
* &lt;port&gt;
* will start utility2 http-server on given &lt;port&gt; (default 8081)
*/
   local.env.PORT = process.argv[3] || local.env.PORT;
   globalThis.local = local;
   local.<span class="apidocCodeKeywordSpan">replStart</span>();
   local.testRunServer({});
};

local.cliDict[&quot;utility2.testReportCreate&quot;] = function () {
/*
*
* will create test-report
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.requireReadme" id="apidoc.elem.utility2.requireReadme">
        function <span class="apidocSignatureSpan">utility2.</span>requireReadme
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireReadme = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will require and export example.js embedded in README.md
 */
</span>    let code;
    let module;
    let tmp;
    // init module.exports
    module = {};
    if (local.isBrowser) {
        module.exports = local.objectAssignDefault(
            globalThis.utility2_rollup || globalThis.local,
            local
        );
        return module.exports;
    }
    // start repl-debugger
    local.replStart();
    // debug dir
    [
        __dirname + &quot;/lib.jslint.js&quot;,
        __filename,
        &quot;undefined&quot;
    ].forEach(function (file) {
        local.fs.exists(file, function (exists) {
            if (exists) {
                local.onFileModifiedRestart(file);
            }
        });
    });
    // if file is modified, then restart process
    local.fs.readdirSync(&quot;.&quot;).forEach(function (file) {
        local.onFileModifiedRestart(file);
    });
    // jslint process.cwd()
    if (!local.env.npm_config_mode_library) {
        local.child_process.spawn(&quot;node&quot;, [
            &quot;-e&quot;, (
                &quot;require(&quot;
                + JSON.stringify(__filename)
                + &quot;).jslint.jslintAndPrintDir(&quot;
                + JSON.stringify(process.cwd())
                + &quot;, {autofix:true,conditional:true}, process.exit);&quot;
            )
        ], {
            env: Object.assign({}, local.env, {
                npm_config_mode_library: &quot;1&quot;
            }),
            stdio: [
                &quot;ignore&quot;, &quot;ignore&quot;, 2
            ]
        });
    }
    if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
        // init assets index.html
        local.assetsDict[&quot;/index.html&quot;] = (
            local.fsReadFileOrDefaultSync(&quot;index.html&quot;, &quot;utf8&quot;, &quot;&quot;)
            || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
        );
        local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
        local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
            __filename,
            &quot;utf8&quot;
        ).replace((
            /^#!\//
        ), &quot;// &quot;);
        // init exports
        local[local.env.npm_package_nameLib] = local;
        module.exports = local;
        return module.exports;
    }
    // init file $npm_package_main
    globalThis.utility2_moduleExports = require(
        local.path.resolve(local.env.npm_package_main)
    );
    globalThis.utility2_moduleExports.globalThis = globalThis;
    // read code from README.md
    code = local.templateRenderMyApp(
        local.assetsDict[&quot;/assets.example.template.js&quot;]
    );
    local.fsReadFileOrDefaultSync(&quot;README.md&quot;, &quot;utf8&quot;, &quot;&quot;).replace((
        /\n```javascript(\n\/\*\nexample\.js\n[\S\s]*?\n)```\n/
    ), function (ignore, match1, index, input) {
        // preserve lineno
        code = input.slice(0, index).replace((
            /.+/g
        ), &quot;&quot;) + &quot;\n&quot; + match1;
        return &quot;&quot;;
    });
    // alias require($npm_package_name) to utility2_moduleExports;
    code = code.replace(
        new RegExp(&quot;require\\(.&quot; + local.env.npm_package_name + &quot;.\\)&quot;),
        &quot;globalThis.utility2_moduleExports&quot;
    ).replace(
        new RegExp(&quot;require\\(.&quot; + local.env.npm_package_nameOriginal + &quot;.\\)&quot;),
        &quot;globalThis.utility2_moduleExports&quot;
    );
    // init example.js
    tmp = local.path.resolve(&quot;example.js&quot;);
    // jslint code
    local.jslintAndPrint(code, tmp);
    // instrument code
    code = local.istanbulInstrumentInPackage(code, tmp);
    // init module.exports
    module = new local.Module(tmp);
    require.cache[tmp] = module;
    module._compile(code, tmp);
    // init exports
    module.exports.utility2 = local;
    module.exports[local.env.npm_package_nameLib] = (
        globalThis.utility2_moduleExpor...</pre></li>
    <li>example use<pre class="apidocCodePre">...
\n\
\n\
\n\
// run shared js\-env code - init-before\n\
(function () {\n\
// init local\n\
local = globalThis.utility2 || require(&quot;utility2&quot;);\n\
local = local.<span class="apidocCodeKeywordSpan">requireReadme</span>();\n\
globalThis.local = local;\n\
// init test\n\
local.testRunDefault(local);\n\
}());\n\
\n\
\n\
\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverLocalReqHandler" id="apidoc.elem.utility2.serverLocalReqHandler">
        function <span class="apidocSignatureSpan">utility2.</span>serverLocalReqHandler
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverLocalReqHandler = function (req, res) {
    let that;
    that = {};
    local.gotoNext(that, function (err) {
        if (err || that.gotoState &gt;= local.middlewareList.length) {
            local.middlewareError(err, req, res);
            return;
        }
        // recurse with next middleware in middlewareList
        local.middlewareList[that.gotoState](req, res, that.gotoNext);
    });
    that.gotoState = -1;
    that.gotoNext();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (isDone) {
        return;
    }
    isDone = true;
    data = _data;
    // async send req from client to server
    setTimeout(function () {
        local.<span class="apidocCodeKeywordSpan">serverLocalReqHandler</span>(req, res);
    });
},
headers: xhr.headers,
method: xhr.method,
on: function () {
    return xhr;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverLocalUrlTest" id="apidoc.elem.utility2.serverLocalUrlTest">
        function <span class="apidocSignatureSpan">utility2.</span>serverLocalUrlTest
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverLocalUrlTest = function (url) {
<span class="apidocCodeCommentSpan">/*
 * this function will test if &lt;url&gt; is local
 */
</span>    url = local.urlParse(url).pathname;
    return local.isBrowser &amp;&amp; !local.env.npm_config_mode_backend &amp;&amp; (
        /^\/test\./
    ).test(url);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    xhr.resHeaders = {};
    xhr.timeStart = xhr.timeStart || Date.now();
};
// init xhr - XMLHttpRequest
xhr = (
    local.isBrowser
    &amp;&amp; !opt.httpReq
    &amp;&amp; !(local2.serverLocalUrlTest &amp;&amp; local2.<span class="apidocCodeKeywordSpan">serverLocalUrlTest</span>(opt.url
))
    &amp;&amp; new XMLHttpRequest()
);
// init xhr - http.request
if (!xhr) {
    xhr = local.identity(local2.urlParse || require(&quot;url&quot;).parse)(opt.url);
    // init xhr
    xhrInit();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondDefault" id="apidoc.elem.utility2.serverRespondDefault">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondDefault
        <span class="apidocSignatureSpan">(req, res, statusCode, err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondDefault = function (req, res, statusCode, err) {
<span class="apidocCodeCommentSpan">/*
 * this function will respond with a default message,
 * or &lt;err&gt;.stack for given statusCode
 */
</span>    // init statusCode and contentType
    local.serverRespondHeadSet(
        req,
        res,
        statusCode,
        {
            &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;
        }
    );
    if (err) {
        // debug statusCode / method / url
        err.message = (
            res.statusCode + &quot; &quot; + req.method + &quot; &quot; + req.url + &quot;\n&quot;
            + err.message
        );
        // print err.stack to stderr
        local.onErrorDefault(err);
        // end res with err.stack
        res.end(err.stack);
        return;
    }
    // end res with default statusCode message
    res.end(
        statusCode + &quot; &quot; + local.http.STATUS_CODES[statusCode]
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        opt.gotoNext(null, data, meta);
    }
    break;
case 3:
    switch (crud.crudType[0]) {
    case &quot;fileGetOneById&quot;:
        if (!data) {
            local.<span class="apidocCodeKeywordSpan">serverRespondDefault</span>(req, res, 404);
            return;
        }
        local.serverRespondHeadSet(req, res, null, {
            &quot;Content-Type&quot;: data.fileContentType
        });
        res.end(local.base64ToBuffer(data.fileBlob));
        break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondEcho" id="apidoc.elem.utility2.serverRespondEcho">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondEcho
        <span class="apidocSignatureSpan">(req, res)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondEcho = function (req, res) {
<span class="apidocCodeCommentSpan">/*
 * this function will respond with debug info
 */
</span>    res.write(
        req.method + &quot; &quot; + req.url
        + &quot; HTTP/&quot; + req.httpVersion + &quot;\r\n&quot;
        + Object.keys(req.headers).map(function (key) {
            return key + &quot;: &quot; + req.headers[key] + &quot;\r\n&quot;;
        }).join(&quot;&quot;) + &quot;\r\n&quot;
    );
    req.pipe(res);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    break;
// test http POST handling-behavior
case &quot;/test.echo&quot;:
    // test res-header handling-behavior
    local.serverRespondHeadSet(req, res, null, {
        &quot;X-Res-Header-Test&quot;: &quot;bb&quot;
    });
    local.<span class="apidocCodeKeywordSpan">serverRespondEcho</span>(req, res);
    break;
// test 500-internal-server-error handling-behavior
case &quot;/test.err-500&quot;:
    // test multiple-callback serverRespondHeadSet handling-behavior
    local.serverRespondHeadSet(req, res, null, {});
    next(local.errorDefault);
    // test multiple-callback-error handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondHeadSet" id="apidoc.elem.utility2.serverRespondHeadSet">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondHeadSet
        <span class="apidocSignatureSpan">(ignore, res, statusCode, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondHeadSet = function (ignore, res, statusCode, headers) {
<span class="apidocCodeCommentSpan">/*
 * this function will set &lt;res&gt; object&apos;s &lt;statusCode&gt; and &lt;headers&gt;
 */
</span>    if (res.headersSent) {
        return;
    }
    // init res.statusCode
    if (Number(statusCode)) {
        res.statusCode = Number(statusCode);
    }
    Object.keys(headers).forEach(function (key) {
        if (headers[key]) {
            res.setHeader(key, headers[key]);
        }
    });
    return true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    });
    local.dbTableFile.crudSetManyById(crud.body, opt.gotoNext);
    break;
case &quot;userLoginByPassword&quot;:
case &quot;userLogout&quot;:
    // respond with 401 Unauthorized
    if (!user.isAuthenticated) {
        local.<span class="apidocCodeKeywordSpan">serverRespondHeadSet</span>(req, res, 401, {});
        req.swgg.crud.endArgList = [
            req, res
        ];
        opt.gotoState = Infinity;
        opt.gotoNext();
        return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.serverRespondTimeoutDefault" id="apidoc.elem.utility2.serverRespondTimeoutDefault">
        function <span class="apidocSignatureSpan">utility2.</span>serverRespondTimeoutDefault
        <span class="apidocSignatureSpan">(req, res, timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serverRespondTimeoutDefault = function (req, res, timeout) {
<span class="apidocCodeCommentSpan">/*
 * this function will create &lt;timeout&gt;-handler for server-&lt;req&gt;
 */
</span>    let isDone;
    let onError;
    onError = function () {
        if (isDone) {
            return;
        }
        isDone = true;
        // debug res
        console.error(&quot;serverLog - &quot; + JSON.stringify({
            time: new Date(req.timeStart).toISOString(),
            type: &quot;serverResponse&quot;,
            method: req.method,
            url: req.url,
            statusCode: res.statusCode | 0,
            timeElapsed: Date.now() - req.timeStart,
            // extra
            reqContentLength: req.dataLength || 0,
            resContentLength: res.contentLength,
            reqHeaderXForwardedFor: req.headers[&quot;x-forwarded-for&quot;] || &quot;&quot;,
            reqHeaderOrigin: req.headers.origin || &quot;&quot;,
            reqHeaderReferer: req.headers.referer || &quot;&quot;,
            reqHeaderUserAgent: req.headers[&quot;user-agent&quot;]
        }) + &quot;\n&quot;);
        // cleanup timerTimeout
        clearTimeout(req.timerTimeout);
    };
    req.timeStart = Date.now();
    req.onTimeout = req.onTimeout || function (err) {
        local.serverRespondDefault(req, res, 500, err);
        setTimeout(function () {
            // cleanup req and res
            local.streamCleanup(req);
            local.streamCleanup(res);
        }, 1000);
    };
    // init timerTimeout
    timeout = timeout || local.timeoutDefault;
    req.timerTimeout = setTimeout(
        req.onTimeout,
        timeout,
        new Error(
            &quot;timeout - &quot; + timeout + &quot; ms - &quot;
            + &quot;server &quot; + req.method + &quot; &quot; + req.url
        )
    );
    res.contentLength = 0;
    res.writeContentLength = res.writeContentLength || res.write;
    res.write = function (buf, encoding, callback) {
        buf = local.bufferValidateAndCoerce(buf, typeof buf);
        res.contentLength += buf.length;
        res.writeContentLength(buf, encoding, callback);
    };
    res.on(&quot;error&quot;, onError);
    res.on(&quot;finish&quot;, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local._debugServerReqRes3 = local._debugServerReqRes2;
local._debugServerReqRes2 = local._debugServerReqRes1;
local._debugServerReqRes1 = {
    req,
    res
};
// init timerTimeout
local.<span class="apidocCodeKeywordSpan">serverRespondTimeoutDefault</span>(req, res, local.timeoutDefault);
// init req.urlParsed
req.urlParsed = local.urlParse(req.url);
// set reponse-header &quot;content-type&quot;
contentType = {
    // application
    &quot;.js&quot;: &quot;application/javascript; charset=utf-8&quot;,
    &quot;.json&quot;: &quot;application/json; charset=utf-8&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.setTimeoutOnError" id="apidoc.elem.utility2.setTimeoutOnError">
        function <span class="apidocSignatureSpan">utility2.</span>setTimeoutOnError
        <span class="apidocSignatureSpan">(onError, timeout, err, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeoutOnError = function (onError, timeout, err, data) {
<span class="apidocCodeCommentSpan">/*
 * this function will after timeout has passed,
 * then call &lt;onError&gt;(&lt;err&gt;, &lt;data&gt;)
 */
</span>    if (typeof onError === &quot;function&quot;) {
        setTimeout(function () {
            onError(err, data);
        }, timeout);
    }
    return data;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
           element.querySelector(
               &quot;[tabIndex]&quot;
           ).focus();
           // validate input
           local.uiEventListenerDict.onEventInputValidateAndAjax({
               targetOnEvent: element
           });
           local.<span class="apidocCodeKeywordSpan">setTimeoutOnError</span>(onError, 0, null, element);
       }
   );
};

local.uiEventListenerDict.onEventResourceDisplayAction = function (evt) {
/*
* this function will toggle the display of the resource
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stateInit" id="apidoc.elem.utility2.stateInit">
        function <span class="apidocSignatureSpan">utility2.</span>stateInit
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stateInit = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will init state &lt;opt&gt;
 */
</span>    local.objectAssignRecurse(local, opt, 10);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - init-after
(function () {
// hack-coverage - test testRunServer&apos;s multiple-call handling-behavior
local.testRunServer(local);
// hack-coverage - stateInit
local.<span class="apidocCodeKeywordSpan">stateInit</span>({});
// init test-middleware
local.middlewareList.push(function (req, res, next) {
/*
* this function will run test-middleware
*/
   switch (req.urlParsed.pathname) {
   // test http POST handling-behavior
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stream" id="apidoc.elem.utility2.stream">
        function <span class="apidocSignatureSpan">utility2.</span>stream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream(opts) {
  EE.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.streamCleanup" id="apidoc.elem.utility2.streamCleanup">
        function <span class="apidocSignatureSpan">utility2.</span>streamCleanup
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">streamCleanup = function (stream) {
<span class="apidocCodeCommentSpan">/*
 * this function will try to end or destroy &lt;stream&gt;
 */
</span>    let err;
    // try to end stream
    try {
        stream.end();
    } catch (errCaught) {
        err = errCaught;
    }
    // if err, then try to destroy stream
    if (err) {
        try {
            stream.destroy();
        } catch (ignore) {}
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        // extra
        headers: clientHeaders
    }) + &quot;\n&quot;);
    if (!err) {
        return;
    }
    // cleanup clientReq and clientRes
    local.<span class="apidocCodeKeywordSpan">streamCleanup</span>(clientReq);
    local.streamCleanup(clientRes);
    next(err);
};
// init timerTimeout
timerTimeout = setTimeout(
    onError,
    local.timeoutDefault,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringHtmlSafe" id="apidoc.elem.utility2.stringHtmlSafe">
        function <span class="apidocSignatureSpan">utility2.</span>stringHtmlSafe
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringHtmlSafe = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will make &lt;str&gt; html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
</span>    return str.replace((
        /&amp;/gu
    ), &quot;&amp;&quot;).replace((
        /&quot;/gu
    ), &quot;&quot;&quot;).replace((
        /&apos;/gu
    ), &quot;&apos;&quot;).replace((
        /&lt;/gu
    ), &quot;&lt;&quot;).replace((
        /&gt;/gu
    ), &quot;&gt;&quot;).replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
    ), &quot;&amp;$1&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
);
// handle case where module is a function
elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
if (elem.typeof !== &quot;function&quot;) {
    return elem;
}
// init source
elem.source = local.<span class="apidocCodeKeywordSpan">stringHtmlSafe</span>(
    trimStart(toString(module[key])) || &quot;n/a&quot;
).replace((
    /\([\S\s]*?\)/
), function (match0) {
    // init signature
    elem.signature = match0.replace((
        /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringLineCount" id="apidoc.elem.utility2.stringLineCount">
        function <span class="apidocSignatureSpan">utility2.</span>stringLineCount
        <span class="apidocSignatureSpan">(str, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLineCount = function (str, start, end) {
<span class="apidocCodeCommentSpan">/*
 * this function will count number of &quot;\n&quot; in &lt;str&gt;
 * from &lt;start&gt; to &lt;end&gt;
 */
</span>    let count;
    count = 0;
    while (true) {
        start = str.indexOf(&quot;\n&quot;, start) + 1;
        if (start === 0 || start &gt;= end) {
            return count;
        }
        count += 1;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringMerge" id="apidoc.elem.utility2.stringMerge">
        function <span class="apidocSignatureSpan">utility2.</span>stringMerge
        <span class="apidocSignatureSpan">(str1, str2, rgx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringMerge = function (str1, str2, rgx) {
<span class="apidocCodeCommentSpan">/*
 * this function will merge &lt;str2&gt; into &lt;str1&gt;,
 * for sections where both match &lt;rgx&gt;
 */
</span>    str2.replace(rgx, function (match2) {
        str1.replace(rgx, function (match1) {
            str1 = str1.replace(match1, function () {
                return match2;
            });
            return &quot;&quot;;
        });
        return &quot;&quot;;
    });
    return str1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        /\n\u0020\*\n(?:[\S\s]*?\n)?\u0020\*\/\n/
    ),
    // customize code after /* validateLineSortedReset */
    (
        /\n\/\*\u0020validateLineSortedReset\u0020\*\/\n[\S\s]*?$/
    )
].forEach(function (rgx) {
    opt.dataTo = local.<span class="apidocCodeKeywordSpan">stringMerge</span>(opt.dataTo, opt.dataFrom, rgx);
});
// customize assets.utility2.rollup.js
if (
    local.fs.existsSync(&quot;./assets.utility2.rollup.js&quot;)
) {
    opt.dataTo = opt.dataTo.replace(
        &quot;    // || globalThis.utility2_rollup_old&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringQuotedToAscii" id="apidoc.elem.utility2.stringQuotedToAscii">
        function <span class="apidocSignatureSpan">utility2.</span>stringQuotedToAscii
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringQuotedToAscii = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will replace non-ascii-chr to unicode-escaped-ascii-chr
 * in quoted-&lt;str&gt;
 */
</span>    return str.replace((
        /\r/g
    ), &quot;\\r&quot;).replace((
        /\t/g
    ), &quot;\\t&quot;).replace((
        /[^\n\u0020-\u007e]/g
    ), function (chr) {
        return &quot;\\u&quot; + (&quot;0000&quot; + chr.charCodeAt(0).toString(16)).slice(-4);
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.testCase_stringQuotedToAscii_default = function (opt, onError) {
/*
 * this function will test stringQuotedToAscii&apos;s default handling-behavior
 */
    local.assertJsonEqual(
        local.<span class="apidocCodeKeywordSpan">stringQuotedToAscii</span>(local.stringHelloEmoji),
        &quot;hello \\ud83d\\ude01\n&quot;
    );
    onError(undefined, opt);
};

local.testCase_stringRegexpEscape_default = function (opt, onError) {
/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.stringRegexpEscape" id="apidoc.elem.utility2.stringRegexpEscape">
        function <span class="apidocSignatureSpan">utility2.</span>stringRegexpEscape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringRegexpEscape = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will regexp-escape &lt;str&gt;
 * https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
 */
</span>    return str.replace((
        /[\-\/\\\^$*+?.()|\[\]{}]/g
    ), &quot;\\$&amp;&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.testCase_stringRegexpEscape_default = function (opt, onError) {
/*
* this function will test stringRegexpEscape&apos;s default handling-behavior
*/
   local.assertJsonEqual(
       local.<span class="apidocCodeKeywordSpan">stringRegexpEscape</span>(local.stringCharsetAscii),
       (
           &quot;\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007&quot;
           + &quot;\b\t\n\u000b\f\r\u000e\u000f&quot;
           + &quot;\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017&quot;
           + &quot;\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f&quot;
           + &quot; !\&quot;#\\$%&amp;&apos;\\(\\)\\*\\+,\\-\\.\\/0123456789:;&lt;=&gt;\\?@&quot;
           + &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[\\\\\\]\\^_`&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.templateRender" id="apidoc.elem.utility2.templateRender">
        function <span class="apidocSignatureSpan">utility2.</span>templateRender
        <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRender = function (template, dict, opt, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    opt = opt || {};
    getVal = function (key) {
        argList = key.split(&quot; &quot;);
        val = dict;
        if (argList[0] === &quot;#this/&quot;) {
            return val;
        }
        if (argList[0] === &quot;#ii/&quot;) {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(&quot;.&quot;).forEach(function (key) {
            val = val &amp;&amp; val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case &quot;each&quot;:
        case &quot;eachTrimEndComma&quot;:
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join(&quot;&quot;)
                : &quot;&quot;
            );
            // remove trailing-comma from last elem
            if (helper === &quot;eachTrimEndComma&quot;) {
                val = val.trimEnd().replace((
                    /,$/
                ), &quot;&quot;);
            }
            return val;
        case &quot;if&quot;:
            partial = partial.split(&quot;{{#unless &quot; + key + &quot;}}&quot;);
            partial = (
                getVal(key)
                ? partial[0]
                // handle &quot;unless&quot; case
                : partial.slice(1).join(&quot;{{#unless &quot; + key + &quot;}}&quot;)
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case &quot;unless&quot;:
            return (
                getVal(key)
                ? &quot;&quot;
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || &quot;&quot;;
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                &quot;\\{\\{#(&quot; + match[1] + &quot;) (&quot; + match[2]
                + &quot;)\\}\\}([\\S\\s]*?)\\{\\{/&quot; + match[1] + &quot; &quot; + match[2]
                + &quot;\\}\\}&quot;
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case &quot;*&quot;:
                case &quot;+&quot;:
                case &quot;-&quot;:
                case &quot;/&quot;:
                    skip = ii + 1;
                    val = String(
                        fmt === &quot;*&quot;
                        ? Number(val) * Number(list[skip])
                        : fmt === &quot;+&quot;
                        ? Number(val) + Number(list[skip])
                        : fmt === &quot;-&quot;
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;...</pre></li>
    <li>example use<pre class="apidocCodePre">...
case &quot;each&quot;:
case &quot;eachTrimEndComma&quot;:
    val = getVal(key);
    val = (
        Array.isArray(val)
        ? val.map(function (dict, ii) {
            // recurse with partial
            return local.<span class="apidocCodeKeywordSpan">templateRender</span>(partial, dict, opt, ii);
        }).join(&quot;&quot;)
        : &quot;&quot;
    );
    // remove trailing-comma from last elem
    if (helper === &quot;eachTrimEndComma&quot;) {
        val = val.trimEnd().replace((
            /,$/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.templateRenderMyApp" id="apidoc.elem.utility2.templateRenderMyApp">
        function <span class="apidocSignatureSpan">utility2.</span>templateRenderMyApp
        <span class="apidocSignatureSpan">(template)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRenderMyApp = function (template) {
<span class="apidocCodeCommentSpan">/*
 * this function will render my-app-lite template
 */
</span>    let githubRepo;
    let packageJson;
    packageJson = JSON.parse(local.fs.readFileSync(&quot;package.json&quot;, &quot;utf8&quot;));
    local.objectAssignDefault(packageJson, {
        nameLib: packageJson.name.replace((
            /\W/g
        ), &quot;_&quot;),
        repository: {
            url: (
                &quot;https://github.com/kaizhu256/node-&quot; + packageJson.name
            )
        }
    }, 2);
    githubRepo = packageJson.repository.url.replace((
        /\.git$/
    ), &quot;&quot;).split(&quot;/&quot;).slice(-2);
    template = template.replace((
        /kaizhu256(\.github\.io\/|%252F|\/)/g
    ), githubRepo[0] + (&quot;$1&quot;));
    template = template.replace((
        /node-my-app-lite/g
    ), githubRepo[1]);
    template = template.replace((
        /\bh1-my-app\b/g
    ), (
        packageJson.nameHeroku
        || (&quot;h1-&quot; + packageJson.nameLib.replace((
            /_/g
        ), &quot;-&quot;))
    ));
    template = template.replace((
        /my-app-lite/g
    ), packageJson.name);
    template = template.replace((
        /my_app/g
    ), packageJson.nameLib);
    template = template.replace((
        /\{\{packageJson\.(\S+)\}\}/g
    ), function (ignore, match1) {
        return packageJson[match1];
    });
    return template;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
let result;
local.objectAssignDefault(opt, {
    customize: local.nop,
    dataFrom: local.fs.readFileSync(
        &quot;lib.&quot; + local.env.npm_package_nameLib + &quot;.js&quot;,
        &quot;utf8&quot;
    ),
    dataTo: local.<span class="apidocCodeKeywordSpan">templateRenderMyApp</span>(
        local.assetsDict[&quot;/assets.my_app.template.js&quot;]
    )
});
// search-and-replace - customize dataTo
[
    // customize top-level comment-description
    (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testMock" id="apidoc.elem.utility2.testMock">
        function <span class="apidocSignatureSpan">utility2.</span>testMock
        <span class="apidocSignatureSpan">(mockList, onTestCase, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testMock = function (mockList, onTestCase, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will mock objects in &lt;mockList&gt; when running &lt;onTestCase&gt;
 */
</span>    let onError2;
    onError2 = function (err) {
        // restore mock[0] from mock[2]
        mockList.reverse().forEach(function (mock) {
            Object.keys(mock[2]).forEach(function (key) {
                mock[0][key] = mock[2][key];
            });
        });
        onError(err);
    };
    // suppress console.error and console.log
    if (!(mockList[0] &amp;&amp; mockList[0][0] === console)) {
        mockList.unshift([
            console, {}
        ]);
    }
    local.objectAssignDefault(mockList[0][1], {
        error: local.nop,
        log: local.nop
    });
    // mock-objects
    mockList.forEach(function (mock) {
        mock[2] = {};
        // backup mock[0] into mock[2]
        Object.keys(mock[1]).forEach(function (key) {
            mock[2][key] = (
                (
                    typeof process === &quot;object&quot;
                    &amp;&amp; process.env === mock[0]
                    &amp;&amp; mock[0][key] === undefined
                )
                // handle process.env
                ? &quot;&quot;
                : mock[0][key]
            );
        });
        // override mock[0] with mock[1]
        Object.keys(mock[1]).forEach(function (key) {
            mock[0][key] = mock[1][key];
        });
    });
    // try to call onError with mock-objects
    local.tryCatchOnError(function () {
        // run onTestCase
        onTestCase(onError2);
    }, onError2);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
                };
            }
        });
        mockList.push([
            tmp, mockDict
        ]);
    });
    local.<span class="apidocCodeKeywordSpan">testMock</span>(mockList, function (onError) {
        local.tryCatchOnError(function () {
            exports = require(file);
        }, local.onErrorDefault);
        onError();
    }, local.onErrorThrow);
    return exports;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testReportCreate" id="apidoc.elem.utility2.testReportCreate">
        function <span class="apidocSignatureSpan">utility2.</span>testReportCreate
        <span class="apidocSignatureSpan">(testReport)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReportCreate = function (testReport) {
<span class="apidocCodeCommentSpan">/*
 * this function will create test-report artifacts
 */
</span>    testReport = local.objectAssignDefault(testReport, {
        testPlatformList: []
    });
    // print test-report summary
    console.error(
        &quot;\n&quot; + new Array(56).join(&quot;-&quot;)
        + &quot;\n&quot; + testReport.testPlatformList.filter(function (testPlatform) {
            // if testPlatform has no tests, then filter it out
            return testPlatform.testCaseList.length;
        }).map(function (testPlatform) {
            return (
                &quot;| test-report - &quot; + testPlatform.name + &quot;\n|&quot;
                + String(
                    testPlatform.timeElapsed + &quot; ms     &quot;
                ).padStart(16, &quot; &quot;)
                + String(
                    testPlatform.testsFailed + &quot; failed &quot;
                ).padStart(16, &quot; &quot;)
                + String(
                    testPlatform.testsPassed + &quot; passed &quot;
                ).padStart(16, &quot; &quot;)
                + &quot;     |\n&quot; + new Array(56).join(&quot;-&quot;)
            );
        }).join(&quot;\n&quot;) + &quot;\n&quot;
    );
    // create test-report.html
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/test-report.html&quot;,
        local.testReportMerge(testReport),
        &quot;wrote file - test-report - {{pathname}}&quot;
    );
    // create build.badge.svg
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/build.badge.svg&quot;,
        local.assetsDict[&quot;/assets.buildBadge.template.svg&quot;].replace((
            /0000-00-00\u002000:00:00\u0020UTC\u0020-\u0020master\u0020-\u0020aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/g
        ), (
            new Date().toISOString().slice(0, 19).replace(&quot;T&quot;, &quot; &quot;)
            + &quot; - &quot; + local.env.CI_BRANCH + &quot; - &quot; + local.env.CI_COMMIT_ID
        )),
        &quot;wrote file - test-report - {{pathname}}&quot;
    );
    // create test-report.badge.svg
    local.fsWriteFileWithMkdirpSync(
        &quot;tmp/build/test-report.badge.svg&quot;,
        local.assetsDict[&quot;/assets.testReportBadge.template.svg&quot;].replace((
            // edit number of tests failed
            /999/g
        ), testReport.testsFailed).replace((
            // edit badge color
            /d00/g
        ), (
            testReport.testsFailed
            ? &quot;d00&quot;
            : &quot;0d0&quot;
        )),
        &quot;wrote file - test-report - {{pathname}}&quot;
    );
    // if any test failed, then exit with non-zero exitCode
    console.error(
        &quot;\n&quot; + local.env.MODE_BUILD
        + &quot; - &quot; + testReport.testsFailed + &quot; failed tests\n&quot;
    );
    // print failed testCase
    testReport.testPlatformList.forEach(function (testPlatform) {
        testPlatform.testCaseList.forEach(function (testCase) {
            if (testCase.status !== &quot;passed&quot;) {
                console.error(JSON.stringify(testCase, undefined, 4));
            }
        });
    });
    return testReport;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

local.cliDict[&quot;utility2.testReportCreate&quot;] = function () {
/*
*
* will create test-report
*/
   process.exit(
       local.<span class="apidocCodeKeywordSpan">testReportCreate</span>(
           JSON.parse(local.fs.readFileSync(
               local.path.resolve(
                   local.env.npm_config_dir_build + &quot;/test-report.json&quot;
               ),
               &quot;utf8&quot;
           ))
       ).testsFailed !== 0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testReportMerge" id="apidoc.elem.utility2.testReportMerge">
        function <span class="apidocSignatureSpan">utility2.</span>testReportMerge
        <span class="apidocSignatureSpan">(testReport1, testReport2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReportMerge = function (testReport1, testReport2) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. merge testReport2 into testReport1
 * 2. return testReport1 in html-format
 */
</span>    let errorStackList;
    let testCaseNumber;
    let testReport;
    testReport2 = testReport2 || {};
    // 1. merge testReport2 into testReport1
    [
        testReport1, testReport2
    ].forEach(function (testReport, ii) {
        ii += 1;
        local.objectAssignDefault(testReport, {
            date: new Date().toISOString(),
            errorStackList: [],
            testPlatformList: [],
            timeElapsed: 0
        }, -1);
        // security - handle malformed testReport
        local.assertOrThrow(
            typeof testReport === &quot;object&quot; &amp;&amp; testReport,
            ii + &quot; invalid testReport &quot; + typeof testReport
        );
        // validate timeElapsed
        local.assertOrThrow(
            typeof testReport.timeElapsed === &quot;number&quot;,
            ii + &quot; invalid testReport.timeElapsed &quot;
            + typeof testReport.timeElapsed
        );
        // security - handle malformed testReport.testPlatformList
        testReport.testPlatformList.forEach(function (testPlatform) {
            local.objectAssignDefault(testPlatform, {
                name: &quot;undefined&quot;,
                testCaseList: [],
                timeElapsed: 0
            }, -1);
            local.assertOrThrow(
                typeof testPlatform.name === &quot;string&quot;,
                ii + &quot; invalid testPlatform.name &quot; + typeof testPlatform.name
            );
            // insert $MODE_BUILD into testPlatform.name
            if (local.env.MODE_BUILD) {
                testPlatform.name = testPlatform.name.replace((
                    /^(browser|node)\b/
                ), local.env.MODE_BUILD + &quot; - $1&quot;);
            }
            // validate timeElapsed
            local.assertOrThrow(
                typeof testPlatform.timeElapsed === &quot;number&quot;,
                (
                    ii + &quot; invalid testPlatform.timeElapsed &quot;
                    + typeof testPlatform.timeElapsed
                )
            );
            // security - handle malformed testPlatform.testCaseList
            testPlatform.testCaseList.forEach(function (testCase) {
                local.objectAssignDefault(testCase, {
                    errorStack: &quot;&quot;,
                    name: &quot;undefined&quot;,
                    timeElapsed: 0
                }, -1);
                local.assertOrThrow(
                    typeof testCase.errorStack === &quot;string&quot;,
                    ii + &quot; invalid testCase.errorStack &quot;
                    + typeof testCase.errorStack
                );
                local.assertOrThrow(
                    typeof testCase.name === &quot;string&quot;,
                    ii + &quot; invalid testCase.name &quot; + typeof testCase.name
                );
                // validate timeElapsed
                local.assertOrThrow(
                    typeof testCase.timeElapsed === &quot;number&quot;,
                    (
                        ii + &quot; invalid testCase.timeElapsed &quot;
                        + typeof testCase.timeElapsed
                    )
                );
            });
        });
    });
    // merge testReport2.testPlatformList into testReport1.testPlatformList
    testReport2.testPlatformList.forEach(function (testPlatform2) {
        // add testPlatform2 to testReport1.testPlatformList
        testReport1.testPlatformList.push(testPlatform2);
    });
    testReport = testReport1;
    testReport.testsFailed = 0;
    testReport.testsPassed = 0;
    testReport.testsPending = 0;
    testReport.testPlatformList.forEach(function (testPlatform) {
        testPlatform.testsFailed = 0;
        testPlatform.testsPassed = 0;
        testPlatform.testsPending = 0;
        testPlatform.testCaseList.forEach(function (testCase) {
            switch (testCase...</pre></li>
    <li>example use<pre class="apidocCodePre">...
// merge browser-screenshot
data.testPlatformList[0].screenshot = fileScreenshot.replace((
    /.*\//
), &quot;&quot;);
// merge browser-coverage
local.istanbulCoverageMerge(globalThis.__coverage__, data.coverage);
// merge browser-test-report
local.<span class="apidocCodeKeywordSpan">testReportMerge</span>(globalThis.utility2_testReport, data);
// save test-report.json
onParallel.cnt += 1;
local.fs.writeFile(
    local.path.resolve(
        local.env.npm_config_dir_build + &quot;/test-report.json&quot;
    ),
    JSON.stringify(globalThis.utility2_testReport),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testRunBrowser" id="apidoc.elem.utility2.testRunBrowser">
        function <span class="apidocSignatureSpan">utility2.</span>testRunBrowser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunBrowser = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will run browser-tests
 */
</span>    // hide browser-tests
    if (document.querySelector(&quot;#htmlTestReport1&quot;).style.maxHeight !== &quot;0px&quot;) {
        local.uiAnimateSlideUp(document.querySelector(&quot;#htmlTestReport1&quot;));
        document.querySelector(
            &quot;#buttonTestRun1&quot;
        ).textContent = &quot;run browser-tests&quot;;
        return;
    }
    // show browser-tests
    local.uiAnimateSlideDown(document.querySelector(&quot;#htmlTestReport1&quot;));
    document.querySelector(
        &quot;#buttonTestRun1&quot;
    ).textContent = &quot;hide browser-tests&quot;;
    local.modeTest = 1;
    local.testRunDefault(globalThis.local);
    // reset output
    document.querySelectorAll(&quot;.onevent-reset-output&quot;).forEach(function (elem) {
        elem.textContent = &quot;&quot;;
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testRunDefault" id="apidoc.elem.utility2.testRunDefault">
        function <span class="apidocSignatureSpan">utility2.</span>testRunDefault
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunDefault = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run tests in testPlatform.testCaseList
 */
</span>    let consoleError;
    let isCoverage;
    let processExit;
    let testPlatform;
    let testReport;
    let timerInterval;
    // run-server
    if (!local.isBrowser) {
        local.testRunServer(opt);
    }
    globalThis.utility2_modeTest = Number(
        globalThis.utility2_modeTest
        || opt.modeTest
        || local.modeTest
        || local.env.npm_config_mode_test
    );
    switch (globalThis.utility2_modeTest) {
    // init
    case 1:
        globalThis.utility2_modeTest += 1;
        // reset db
        globalThis.utility2_onReadyAfter(function () {
            local.testRunDefault(opt);
        });
        return;
    // test-run
    default:
        // test-ignore
        if (
            globalThis.utility2_onReadyBefore.cnt
            || !globalThis.utility2_modeTest
            || globalThis.utility2_modeTest &gt; 2
        ) {
            return;
        }
        // test-run
        globalThis.utility2_modeTest += 1;
    }
    // visual notification - testRun
    local.ajaxProgressUpdate();
    // mock console.error
    consoleError = console.error;
    isCoverage = (
        typeof globalThis.__coverage__ === &quot;object&quot; &amp;&amp; globalThis.__coverage__
        &amp;&amp; Object.keys(globalThis.__coverage__).length
    );
    console.error = function (...argList) {
    /*
     * this function will ignore serverLog-messages during test-run
     */
        if (!isCoverage &amp;&amp; !(
            /^serverLog\u0020-\u0020\{/
        ).test(argList[0])) {
            consoleError(...argList);
        }
    };
    // mock proces.exit
    if (!local.isBrowser) {
        processExit = process.exit;
        process.exit = local.nop;
    }
    // init modeTestCase
    local.modeTestCase = (
        local.modeTestCase
        || local.env.npm_config_mode_test_case || &quot;&quot;
    );
    // init testReport
    testReport = globalThis.utility2_testReport;
    // init testReport timer
    local.timeElapsedStart(testReport);
    // init testPlatform
    testPlatform = testReport.testPlatformList[0];
    // init testPlatform timer
    local.timeElapsedStart(testPlatform);
    // reset testPlatform.testCaseList
    testPlatform.testCaseList.length = 0;
    // add tests into testPlatform.testCaseList
    Object.keys(opt).forEach(function (key) {
        // add testCase opt[key] to testPlatform.testCaseList
        if (
            typeof opt[key] === &quot;function&quot; &amp;&amp; (
                local.modeTestCase
                ? local.modeTestCase.split(
                    /[,\s]/g
                ).indexOf(key) &gt;= 0
                : key.indexOf(&quot;testCase_&quot;) === 0
            )
        ) {
            testPlatform.testCaseList.push({
                isBrowser: local.isBrowser,
                name: key,
                status: &quot;pending&quot;,
                onTestCase: opt[key]
            });
        }
    });
    local.testReportMerge(testReport);
    if (local.isBrowser) {
        document.querySelectorAll(&quot;#htmlTestReport1&quot;).forEach(function (elem) {
            local.uiAnimateSlideDown(elem);
            elem.innerHTML = local.testReportMerge(testReport);
        });
    }
    local.emit(&quot;utility2.testRunStart&quot;, testReport);
    // testRunProgressUpdate every 2000 ms until isDone
    timerInterval = setInterval(function () {
        // update testPlatform.timeElapsed
        local.timeElapsedPoll(testPlatform);
        if (local.isBrowser) {
            document.querySelector(
                &quot;#htmlTestReport1&quot;
            ).innerHTML = local.testReportMerge(testReport);
        }
        local.emit(&quot;utility2.testRunProgressUpdate&quot;, testReport);
        // cleanup timerInterval
        if (!testReport.testsPending) {
            clearInterval(timerInterval);
        }
        // list pending testCase every 5000 ms
        if (testPlatform.timeElapsed % 5000 &lt; 2000) {...</pre></li>
    <li>example use<pre class="apidocCodePre">...
// run shared js\-env code - init-before\n\
(function () {\n\
// init local\n\
local = globalThis.utility2 || require(&quot;utility2&quot;);\n\
local = local.requireReadme();\n\
globalThis.local = local;\n\
// init test\n\
local.<span class="apidocCodeKeywordSpan">testRunDefault</span>(local);\n\
}());\n\
\n\
\n\
\n\
// run shared js\-env code - function\n\
(function () {\n\
return;\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.testRunServer" id="apidoc.elem.utility2.testRunServer">
        function <span class="apidocSignatureSpan">utility2.</span>testRunServer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testRunServer = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. create server from local.middlewareList
 * 2. start server on local.env.PORT
 * 3. run tests
 */
</span>    // 1. create server from local.middlewareList
    local.middlewareList = local.middlewareList || [
        local.middlewareInit,
        local.middlewareForwardProxy,
        local.middlewareAssetsCached,
        local.middlewareJsonpStateInit,
        local.middlewareFileServer
    ];
    if (local.env.npm_config_mode_library || globalThis.utility2_serverHttp1) {
        return;
    }
    globalThis.utility2_onReadyBefore.cnt += 1;
    local.serverLocalReqHandler = function (req, res) {
        let that;
        that = {};
        local.gotoNext(that, function (err) {
            if (err || that.gotoState &gt;= local.middlewareList.length) {
                local.middlewareError(err, req, res);
                return;
            }
            // recurse with next middleware in middlewareList
            local.middlewareList[that.gotoState](req, res, that.gotoNext);
        });
        that.gotoState = -1;
        that.gotoNext();
    };
    globalThis.utility2_serverHttp1 = local.http.createServer(
        local.serverLocalReqHandler
    );
    // 2. start server on local.env.PORT
    console.error(&quot;http-server listening on port &quot; + local.env.PORT);
    globalThis.utility2_onReadyBefore.cnt += 1;
    globalThis.utility2_serverHttp1.listen(
        local.env.PORT,
        globalThis.utility2_onReadyBefore
    );
    // 3. run tests
    local.testRunDefault(opt);
    globalThis.utility2_onReadyBefore();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
/*
* &lt;port&gt;
* will start utility2 http-server on given &lt;port&gt; (default 8081)
*/
   local.env.PORT = process.argv[3] || local.env.PORT;
   globalThis.local = local;
   local.replStart();
   local.<span class="apidocCodeKeywordSpan">testRunServer</span>({});
};

local.cliDict[&quot;utility2.testReportCreate&quot;] = function () {
/*
*
* will create test-report
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.throwError" id="apidoc.elem.utility2.throwError">
        function <span class="apidocSignatureSpan">utility2.</span>throwError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwError = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will throw new err
 */
</span>    throw new Error();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.testCase_throwError_default = function (opt, onError) {
/*
 * this function will test throwError&apos;s default handling-behavior
 */
    local.tryCatchOnError(function () {
        local.<span class="apidocCodeKeywordSpan">throwError</span>();
    }, function (err) {
        // handle err
        local.assertOrThrow(err, err);
        onError(undefined, opt);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.timeElapsedPoll" id="apidoc.elem.utility2.timeElapsedPoll">
        function <span class="apidocSignatureSpan">utility2.</span>timeElapsedPoll
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeElapsedPoll = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will poll &lt;opt&gt;.timeElapsed
 */
</span>    opt = local.timeElapsedStart(opt);
    opt.timeElapsed = Date.now() - opt.timeStart;
    return opt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        &gt; bb.status.replace(&quot;passed&quot;, &quot;z&quot;) + bb.name
        ? 1
        : -1
    );
});
// stop testReport timer
if (!testReport.testsPending) {
    local.<span class="apidocCodeKeywordSpan">timeElapsedPoll</span>(testReport);
}
// 2. return testReport1 in html-format
// json-copy testReport that will be modified for html templating
testReport = local.jsonCopy(testReport1);
// update timeElapsed
local.timeElapsedPoll(testReport);
testReport.testPlatformList.forEach(function (testPlatform) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.timeElapsedStart" id="apidoc.elem.utility2.timeElapsedStart">
        function <span class="apidocSignatureSpan">utility2.</span>timeElapsedStart
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeElapsedStart = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will start &lt;opt&gt;.timeElapsed
 */
</span>    opt = opt || {};
    opt.timeStart = opt.timeStart || Date.now();
    return opt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.modeTestCase = (
    local.modeTestCase
    || local.env.npm_config_mode_test_case || &quot;&quot;
);
// init testReport
testReport = globalThis.utility2_testReport;
// init testReport timer
local.<span class="apidocCodeKeywordSpan">timeElapsedStart</span>(testReport);
// init testPlatform
testPlatform = testReport.testPlatformList[0];
// init testPlatform timer
local.timeElapsedStart(testPlatform);
// reset testPlatform.testCaseList
testPlatform.testCaseList.length = 0;
// add tests into testPlatform.testCaseList
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.tryCatchOnError" id="apidoc.elem.utility2.tryCatchOnError">
        function <span class="apidocSignatureSpan">utility2.</span>tryCatchOnError
        <span class="apidocSignatureSpan">(fnc, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryCatchOnError = function (fnc, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run &lt;fnc&gt; in tryCatch block,
 * else call onError with errCaught
 */
</span>    let result;
    // validate onError
    local.assertOrThrow(typeof onError === &quot;function&quot;, typeof onError);
    try {
        // reset errCaught
        local._debugTryCatchError = null;
        result = fnc();
        local._debugTryCatchError = null;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return elem;
};
readExample = function (file) {
/*
 * this function will read the example from given file
 */
    let result;
    local.<span class="apidocCodeKeywordSpan">tryCatchOnError</span>(function () {
        file = local.path.resolve(opt.dir, file);
        console.error(&quot;apidocCreate - readExample &quot; + file);
        result = &quot;&quot;;
        result = local.identity(
            &quot;\n\n\n\n\n\n\n\n&quot;
            // bug-workaround - truncate example to manageable size
            + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uiAnimateSlideAccordian" id="apidoc.elem.utility2.uiAnimateSlideAccordian">
        function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideAccordian
        <span class="apidocSignatureSpan">(elem, elemList, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideAccordian = function (elem, elemList, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideDown &lt;elem&gt;, but slideUp elements in &lt;elemList&gt;
 */
</span>    elemList.forEach(function (elem2) {
        if (elem2 !== elem) {
            local.uiAnimateSlideUp(elem2);
        }
    });
    setTimeout(function () {
        local.uiAnimateSlideDown(elem, onError);
    }, 250);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// show parent resource
local.uiAnimateSlideDown(element.closest(
    &quot;.resource&quot;
).querySelector(
    &quot;.operationList&quot;
));
// show the operation, but hide all other operations
local.<span class="apidocCodeKeywordSpan">uiAnimateSlideAccordian</span>(
    element.querySelector(
        &quot;.operation &gt; form&quot;
    ),
    Array.from(element.closest(
        &quot;.operationList&quot;
    ).querySelectorAll(
        &quot;.operation &gt; form&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uiAnimateSlideDown" id="apidoc.elem.utility2.uiAnimateSlideDown">
        function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideDown
        <span class="apidocSignatureSpan">(elem, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideDown = function (elem, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideDown dom-&lt;elem&gt;
 */
</span>    onError = onError || local.nop;
    if (!(
        elem
        &amp;&amp; elem.style &amp;&amp; elem.style.maxHeight !== &quot;100%&quot;
        &amp;&amp; elem.classList &amp;&amp; elem.classList.contains(&quot;uiAnimateSlide&quot;)
    )) {
        onError();
        return;
    }
    elem.style.borderBottom = &quot;&quot;;
    elem.style.borderTop = &quot;&quot;;
    elem.style.marginBottom = &quot;&quot;;
    elem.style.marginTop = &quot;&quot;;
    elem.style.maxHeight = 1.5 * globalThis.innerHeight + &quot;px&quot;;
    elem.style.paddingBottom = &quot;&quot;;
    elem.style.paddingTop = &quot;&quot;;
    setTimeout(function () {
        elem.style.maxHeight = &quot;100%&quot;;
        onError();
    }, 250);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    &quot;.operation&quot;
);
location.hash = &quot;!&quot; + element.id;
element.closest(
    &quot;.resource&quot;
).classList.remove(&quot;expanded&quot;);
// show parent resource
local.<span class="apidocCodeKeywordSpan">uiAnimateSlideDown</span>(element.closest(
    &quot;.resource&quot;
).querySelector(
    &quot;.operationList&quot;
));
// show the operation, but hide all other operations
local.uiAnimateSlideAccordian(
    element.querySelector(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uiAnimateSlideUp" id="apidoc.elem.utility2.uiAnimateSlideUp">
        function <span class="apidocSignatureSpan">utility2.</span>uiAnimateSlideUp
        <span class="apidocSignatureSpan">(elem, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uiAnimateSlideUp = function (elem, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will slideUp dom-&lt;elem&gt;
 */
</span>    if (!(
        elem
        &amp;&amp; elem.style &amp;&amp; elem.style.maxHeight !== &quot;0px&quot;
        &amp;&amp; elem.classList &amp;&amp; elem.classList.contains(&quot;uiAnimateSlide&quot;)
    )) {
        local.setTimeoutOnError(onError);
        return;
    }
    elem.style.borderBottom = &quot;0&quot;;
    elem.style.borderTop = &quot;0&quot;;
    elem.style.marginBottom = &quot;0&quot;;
    elem.style.marginTop = &quot;0&quot;;
    elem.style.maxHeight = &quot;0&quot;;
    elem.style.paddingBottom = &quot;0&quot;;
    elem.style.paddingTop = &quot;0&quot;;
    local.setTimeoutOnError(onError, 250);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
);
// collapse all operations in the resource
if (evt.currentTarget.classList.contains(&quot;expanded&quot;)) {
    evt.currentTarget.classList.remove(&quot;expanded&quot;);
    Array.from(evt.currentTarget.querySelectorAll(
        &quot;.operation &gt; form&quot;
    )).forEach(function (element) {
        local.<span class="apidocCodeKeywordSpan">uiAnimateSlideUp</span>(element);
    });
// expand all operations in the resource
} else {
    evt.currentTarget.classList.add(&quot;expanded&quot;);
    Array.from(evt.currentTarget.querySelectorAll(
        &quot;.operation &gt; form&quot;
    )).forEach(function (element) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.urlJoin" id="apidoc.elem.utility2.urlJoin">
        function <span class="apidocSignatureSpan">utility2.</span>urlJoin
        <span class="apidocSignatureSpan">(aa, bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlJoin = function (aa, bb) {
<span class="apidocCodeCommentSpan">/*
 * this function will if bb is relative, url-join aa with bb
 */
</span>    // bb is absolute-url
    if ((
        /^\w+?:\/\//
    ).test(bb)) {
        return bb;
    }
    // bb is absolute-url without protocol
    if (bb.slice(0, 2) === &quot;//&quot;) {
        return aa.split(&quot;/&quot;)[0] + bb;
    }
    // bb is absolute-url without host
    if (bb[0] === &quot;/&quot;) {
        return aa.split(&quot;/&quot;).slice(0, 3).join(&quot;/&quot;) + bb;
    }
    // bb is relative-url
    if (aa.split(&quot;/&quot;).length &lt; 4) {
        aa += &quot;/&quot;;
    }
    return aa.replace((
        /[?#].*?$/
    ), &quot;&quot;).replace((
        /[^\/]*?$/
    ), &quot;&quot;) + bb;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   onError(undefined, opt);
};

local.testCase_urlJoin_default = function (opt, onError) {
/*
* this function will test urlJoin&apos;s default handling-behavior
*/
   local.assertJsonEqual(local.<span class="apidocCodeKeywordSpan">urlJoin</span>(&quot;&quot;, &quot;&quot;), &quot;/&quot;);
   local.assertJsonEqual(local.urlJoin(&quot;http://aa/bb&quot;, &quot;zz&quot;), &quot;http://aa/zz&quot;);
   local.assertJsonEqual(
       local.urlJoin(&quot;http://aa/bb/&quot;, &quot;zz&quot;),
       &quot;http://aa/bb/zz&quot;
   );
   local.assertJsonEqual(
       local.urlJoin(&quot;http://aa/bb/&quot;, &quot;/zz&quot;),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.urlParse" id="apidoc.elem.utility2.urlParse">
        function <span class="apidocSignatureSpan">utility2.</span>urlParse
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">urlParse = function (url) {
<span class="apidocCodeCommentSpan">/*
 * this function will parse &lt;url&gt; according to below spec, plus a query param
 * https://developer.mozilla.org/en-US/docs/Web/API/URL
 */
</span>    let urlParsed;
    urlParsed = {};
    // try to parse url
    local.tryCatchOnError(function () {
        // resolve host-less url
        if (local.isBrowser) {
            local.serverLocalHost = (
                local.serverLocalHost
                || location.protocol + &quot;//&quot; + location.host
            );
            // resolve absolute path
            if (url[0] === &quot;/&quot;) {
                url = local.serverLocalHost + url;
            // resolve relative path
            } else if (!(
                /^\w+?:\/\//
            ).test(url)) {
                url = (
                    local.serverLocalHost
                    + location.pathname.replace((
                        /\/[^\/]*?$/
                    ), &quot;&quot;) + &quot;/&quot; + url
                );
            }
            urlParsed = new globalThis.URL(url);
            urlParsed.path = (
                &quot;/&quot; + urlParsed.href.split(&quot;/&quot;).slice(3).join(&quot;/&quot;).split(&quot;#&quot;)[0]
            );
        } else {
            local.env.PORT = local.env.PORT || &quot;8081&quot;;
            local.serverLocalHost = (
                local.serverLocalHost
                || (&quot;http://127.0.0.1:&quot; + local.env.PORT)
            );
            // resolve absolute path
            if (url[0] === &quot;/&quot;) {
                url = local.serverLocalHost + url;
            // resolve relative path
            } else if (!(
                /^\w+?:\/\//
            ).test(url)) {
                url = local.serverLocalHost + &quot;/&quot; + url;
            }
            urlParsed = local.url.parse(url);
        }
        // init query
        urlParsed.query = {};
        local.coalesce(urlParsed.search, &quot;&quot;).slice(1).replace((
            /[^&amp;]+/g
        ), function (item) {
            item = item.split(&quot;=&quot;);
            item[0] = decodeURIComponent(item[0]);
            item[1] = decodeURIComponent(item.slice(1).join(&quot;=&quot;));
            // parse repeating query-param as an array
            if (urlParsed.query[item[0]]) {
                if (!Array.isArray(urlParsed.query[item[0]])) {
                    urlParsed.query[item[0]] = [
                        urlParsed.query[item[0]]
                    ];
                }
                urlParsed.query[item[0]].push(item[1]);
            } else {
                urlParsed.query[item[0]] = item[1];
            }
            return &quot;&quot;;
        });
        urlParsed.basename = urlParsed.pathname.replace((
            /^.*\//
        ), &quot;&quot;);
    }, local.nop);
    // https://developer.mozilla.org/en/docs/Web/API/URL#Properties
    return {
        basename: urlParsed.basename || &quot;&quot;,
        hash: urlParsed.hash || &quot;&quot;,
        host: urlParsed.host || &quot;&quot;,
        hostname: urlParsed.hostname || &quot;&quot;,
        href: urlParsed.href || &quot;&quot;,
        path: urlParsed.path || &quot;&quot;,
        pathname: urlParsed.pathname || &quot;&quot;,
        port: urlParsed.port || &quot;&quot;,
        protocol: urlParsed.protocol || &quot;&quot;,
        query: urlParsed.query || {},
        search: urlParsed.search || &quot;&quot;
    };
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    );
}
// init url
opt.url = &quot;&quot;;
opt.url += (
    local.identity(
        that[&quot;x-swgg-schemes&quot;] || local.swaggerJson.schemes || []
    )[0] || local.<span class="apidocCodeKeywordSpan">urlParse</span>(&quot;&quot;).protocol.slice(0, -1)
);
opt.url += &quot;://&quot;;
opt.url += (
    that[&quot;x-swgg-host&quot;]
    || local.swaggerJson.host
    || local.urlParse(&quot;&quot;).host
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.uuid4Create" id="apidoc.elem.utility2.uuid4Create">
        function <span class="apidocSignatureSpan">utility2.</span>uuid4Create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uuid4Create = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a random uuid,
 * with format &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;
 */
</span>    // code derived from http://jsperf.com/uuid4
    let id;
    let ii;
    id = &quot;&quot;;
    ii = 0;
    while (ii &lt; 32) {
        switch (ii) {
        case 8:
        case 20:
            id += &quot;-&quot;;
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
            break;
        case 12:
            id += &quot;-&quot;;
            id += &quot;4&quot;;
            break;
        case 16:
            id += &quot;-&quot;;
            id += local.identity((Math.random() * 4) | 8).toString(16);
            break;
        default:
            // coerce to finite integer
            id += local.identity((Math.random() * 16) | 0).toString(16);
        }
        ii += 1;
    }
    return id;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.testCase_uuid4Create_default = function (opt, onError) {
/*
 * this function will test uuid4Create&apos;s default handling-behavior
 */
    local.assertOrThrow(
        local.regexpValidateUuid.test(local.<span class="apidocCodeKeywordSpan">uuid4Create</span>()),
        local.uuid4Create()
    );
    onError(undefined, opt);
};

local.testCase_webpage_err = function (opt, onError) {
/*
...</pre></li>
    </ul>




























































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.FormData" id="apidoc.module.utility2.FormData">module utility2.FormData</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.FormData.FormData" id="apidoc.elem.utility2.FormData.FormData">
        function <span class="apidocSignatureSpan">utility2.</span>FormData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FormData = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will create a serverLocal-compatible FormData instance
 * The FormData(form) constructor must run these steps:
 * 1. Let fd be a new FormData object.
 * 2. If form is given, set fd&apos;s entries to the result
 *    of constructing the form data set for form. (not implemented)
 * 3. Return fd.
 * https://xhr.spec.whatwg.org/#dom-formdata
 */
</span>    this.entryList = [];
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    parameters: that.parameters,
    swaggerJson: local.swaggerJson
})[0];
// init default
local.objectSetDefault(opt, {
    inForm: (
        that._consumes0 === &quot;multipart/form-data&quot;
        ? new local.<span class="apidocCodeKeywordSpan">FormData</span>()
        : &quot;&quot;
    ),
    inHeader: {},
    inPath: that._path.replace((
        /#.*?$/
    ), &quot;&quot;),
    inQuery: &quot;&quot;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.FormData.prototype" id="apidoc.module.utility2.FormData.prototype">module utility2.FormData.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.FormData.prototype.append" id="apidoc.elem.utility2.FormData.prototype.append">
        function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>append
        <span class="apidocSignatureSpan">(name, value, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (name, value, filename) {
<span class="apidocCodeCommentSpan">/*
 * The append(name, value, filename) method, when invoked, must run these steps:
 * 1. If the filename argument is given, set value to a new File object
 *    whose contents are value and name is filename.
 * 2. Append a new entry whose name is name, and value is value,
 *    to context object&apos;s list of entries.
 * https://xhr.spec.whatwg.org/#dom-formdata-append
 */
</span>    if (filename) {
        // bug-workaround - chromium cannot assign name to Blob instance
        local.tryCatchOnError(function () {
            value.name = filename;
        }, local.nop);
    }
    this.entryList.push({
        name,
        value
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        &quot;\n&lt;&quot; + schemaP.name + &quot;&gt;&quot; + &quot;&lt;![CDATA[&quot;
        + tmp.replace((
            /\]\]&gt;/g
        ), &quot;]]&amp;#x3e;&quot;) + &quot;]]&gt;&lt;/&quot; + schemaP.name + &quot;&gt;&quot;
    );
    break;
case &quot;multipart/form-data&quot;:
    opt.inForm.<span class="apidocCodeKeywordSpan">append</span>(schemaP.name, tmp, tmp &amp;&amp; tmp.name);
    break;
default:
    if (opt.inForm) {
        opt.inForm += &quot;&amp;&quot;;
    }
    opt.inForm += (
        encodeURIComponent(schemaP.name) + &quot;=&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.FormData.prototype.read" id="apidoc.elem.utility2.FormData.prototype.read">
        function <span class="apidocSignatureSpan">utility2.FormData.prototype.</span>read
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will read from formData as a buffer, e.g.
 * --Boundary\r\n
 * Content-Disposition: form-data; name=&quot;key&quot;\r\n
 * \r\n
 * value\r\n
 * --Boundary\r\n
 * Content-Disposition: form-data; name=&quot;input1&quot;; filename=&quot;file1.png&quot;\r\n
 * Content-Type: image/jpeg\r\n
 * \r\n
 * &lt;data1&gt;\r\n
 * --Boundary\r\n
 * Content-Disposition: form-data; name=&quot;input2&quot;; filename=&quot;file2.png&quot;\r\n
 * Content-Type: image/jpeg\r\n
 * \r\n
 * &lt;data2&gt;\r\n
 * --Boundary--\r\n
 * https://tools.ietf.org/html/rfc7578
 */
</span>    let boundary;
    let result;
    // handle null-case
    if (!this.entryList.length) {
        onError();
        return;
    }
    // init boundary
    boundary = &quot;--&quot; + Date.now().toString(16) + Math.random().toString(16);
    // init result
    result = [];
    local.onParallelList({
        list: this.entryList
    }, function (opt2, onParallel) {
        let value;
        value = opt2.elem.value;
        if (!(value &amp;&amp; value.constructor === local.Blob)) {
            result[opt2.ii] = [
                (
                    boundary + &quot;\r\nContent-Disposition: form-data; name=\&quot;&quot;
                    + opt2.elem.name + &quot;\&quot;\r\n\r\n&quot;
                ), value, &quot;\r\n&quot;
            ];
            onParallel.cnt += 1;
            onParallel();
            return;
        }
        // read from blob in parallel
        onParallel.cnt += 1;
        local.blobRead(value, function (err, data) {
            result[opt2.ii] = !err &amp;&amp; [
                (
                    boundary + &quot;\r\nContent-Disposition: form-data; name=\&quot;&quot;
                    + opt2.elem.name + &quot;\&quot;&quot; + (
                        (value &amp;&amp; value.name)
                        // read param filename
                        ? &quot;; filename=\&quot;&quot; + value.name + &quot;\&quot;&quot;
                        : &quot;&quot;
                    ) + &quot;\r\n&quot; + (
                        (value &amp;&amp; value.type)
                        // read param Content-Type
                        ? &quot;Content-Type: &quot; + value.type + &quot;\r\n&quot;
                        : &quot;&quot;
                    ) + &quot;\r\n&quot;
                ), data, &quot;\r\n&quot;
            ];
            onParallel(err);
        });
    }, function (err) {
        // add closing boundary
        result.push([
            boundary + &quot;--\r\n&quot;
        ]);
        // concatenate result
        onError(
            err,
            // flatten result
            !err
            &amp;&amp; local.bufferConcat(result.flat())
        );
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.<span class="apidocCodeKeywordSpan">read</span>();

        while (c) {
            switch (c) {

/*
 * Potential tokens:
 * - COMMENT
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.Module" id="apidoc.module.utility2.Module">module utility2.Module</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.Module.Module" id="apidoc.elem.utility2.Module.Module">
        function <span class="apidocSignatureSpan">utility2.</span>Module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// init example.js
tmp = local.path.resolve(&quot;example.js&quot;);
// jslint code
local.jslintAndPrint(code, tmp);
// instrument code
code = local.istanbulInstrumentInPackage(code, tmp);
// init module.exports
module = new local.<span class="apidocCodeKeywordSpan">Module</span>(tmp);
require.cache[tmp] = module;
module._compile(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
    globalThis.utility2_moduleExports
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.SourceMap" id="apidoc.elem.utility2.Module.SourceMap">
        function <span class="apidocSignatureSpan">utility2.Module.</span>SourceMap
        <span class="apidocSignatureSpan">(payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SourceMap {
  #payload;
  #mappings = [];
  #sources = {};
  #sourceContentByURL = {};

<span class="apidocCodeCommentSpan">  /**
   * @constructor
   * @param {SourceMapV3} payload
   */
</span>  constructor(payload) {
    if (!base64Map) {
      const base64Digits =
             &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&apos;;
      base64Map = {};
      for (let i = 0; i &lt; base64Digits.length; ++i)
        base64Map[base64Digits[i]] = i;
    }
    this.#payload = cloneSourceMapV3(payload);
    this.#parseMappingPayload();
  }

  /**
   * @return {Object} raw source map v3 payload.
   */
  get payload() {
    return cloneSourceMapV3(this.#payload);
  }

  /**
   * @param {SourceMapV3} mappingPayload
   */
  #parseMappingPayload = () =&gt; {
    if (this.#payload.sections) {
      this.#parseSections(this.#payload.sections);
    } else {
      this.#parseMap(this.#payload, 0, 0);
    }
    this.#mappings.sort(compareSourceMapEntry);
  }

  /**
   * @param {Array.&lt;SourceMapV3.Section&gt;} sections
   */
  #parseSections = (sections) =&gt; {
    for (let i = 0; i &lt; sections.length; ++i) {
      const section = sections[i];
      this.#parseMap(section.map, section.offset.line, section.offset.column);
    }
  }

  /**
   * @param {number} lineNumber in compiled resource
   * @param {number} columnNumber in compiled resource
   * @return {?Array}
   */
  findEntry(lineNumber, columnNumber) {
    let first = 0;
    let count = this.#mappings.length;
    while (count &gt; 1) {
      const step = count &gt;&gt; 1;
      const middle = first + step;
      const mapping = this.#mappings[middle];
      if (lineNumber &lt; mapping[0] ||
          (lineNumber === mapping[0] &amp;&amp; columnNumber &lt; mapping[1])) {
        count = step;
      } else {
        first = middle;
        count -= step;
      }
    }
    const entry = this.#mappings[first];
    if (!first &amp;&amp; entry &amp;&amp; (lineNumber &lt; entry[0] ||
        (lineNumber === entry[0] &amp;&amp; columnNumber &lt; entry[1]))) {
      return {};
    } else if (!entry) {
      return {};
    }
    return {
      generatedLine: entry[0],
      generatedColumn: entry[1],
      originalSource: entry[2],
      originalLine: entry[3],
      originalColumn: entry[4]
    };
  }

  /**
   * @override
   */
  #parseMap = (map, lineNumber, columnNumber) =&gt; {
    let sourceIndex = 0;
    let sourceLineNumber = 0;
    let sourceColumnNumber = 0;

    const sources = [];
    const originalToCanonicalURLMap = {};
    for (let i = 0; i &lt; map.sources.length; ++i) {
      const url = map.sources[i];
      originalToCanonicalURLMap[url] = url;
      sources.push(url);
      this.#sources[url] = true;

      if (map.sourcesContent &amp;&amp; map.sourcesContent[i])
        this.#sourceContentByURL[url] = map.sourcesContent[i];
    }

    const stringCharIterator = new StringCharIterator(map.mappings);
    let sourceURL = sources[sourceIndex];

    while (true) {
      if (stringCharIterator.peek() === &apos;,&apos;)
        stringCharIterator.next();
      else {
        while (stringCharIterator.peek() === &apos;;&apos;) {
          lineNumber += 1;
          columnNumber = 0;
          stringCharIterator.next();
        }
        if (!stringCharIterator.hasNext())
          break;
      }

      columnNumber += decodeVLQ(stringCharIterator);
      if (isSeparator(stringCharIterator.peek())) {
        this.#mappings.push([lineNumber, columnNumber]);
        continue;
      }

      const sourceIndexDelta = decodeVLQ(stringCharIterator);
      if (sourceIndexDelta) {
        sourceIndex += sourceIndexDelta;
        sourceURL = sources[sourceIndex];
      }
      sourceLineNumber += decodeVLQ(stringCharIterator);
      sourceColumnNumber += decodeVLQ(stringCharIterator);
      if (!isSeparator(stringCharIterator.peek()))
        // Unused index into the names list.
        decodeVLQ(stringCharIterator);

      this.#mappings.push([lineNumber, columnNumber, sourceURL,
                           sourceLineNumber, sourceColumnNumber])...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._debug" id="apidoc.elem.utility2.Module._debug">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_debug
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated(...args) {
  if (!warned) {
    warned = true;
    if (code !== undefined) {
      if (!codesWarned.has(code)) {
        process.emitWarning(msg, &apos;DeprecationWarning&apos;, code, deprecated);
        codesWarned.add(code);
      }
    } else {
      process.emitWarning(msg, &apos;DeprecationWarning&apos;, deprecated);
    }
  }
  if (new.target) {
    return ReflectConstruct(fn, args, new.target);
  }
  return fn.apply(this, args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._findPath" id="apidoc.elem.utility2.Module._findPath">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_findPath
        <span class="apidocSignatureSpan">(request, paths, isMain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, paths, isMain) {
  const absoluteRequest = path.isAbsolute(request);
  if (absoluteRequest) {
    paths = [&apos;&apos;];
  } else if (!paths || paths.length === 0) {
    return false;
  }

  const cacheKey = request + &apos;\x00&apos; +
                (paths.length === 1 ? paths[0] : paths.join(&apos;\x00&apos;));
  const entry = Module._pathCache[cacheKey];
  if (entry)
    return entry;

  let exts;
  let trailingSlash = request.length &gt; 0 &amp;&amp;
    request.charCodeAt(request.length - 1) === CHAR_FORWARD_SLASH;
  if (!trailingSlash) {
    trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);
  }

  // For each path
  for (let i = 0; i &lt; paths.length; i++) {
    // Don&apos;t search further if path doesn&apos;t exist
    const curPath = paths[i];
    if (curPath &amp;&amp; stat(curPath) &lt; 1) continue;

    if (!absoluteRequest) {
      const exportsResolved = resolveExports(curPath, request);
      // Undefined means not found, false means no exports
      if (exportsResolved === undefined)
        break;
      if (exportsResolved) {
        return exportsResolved;
      }
    }

    const basePath = path.resolve(curPath, request);
    let filename;

    const rc = stat(basePath);
    if (!trailingSlash) {
      if (rc === 0) {  // File.
        if (!isMain) {
          if (preserveSymlinks) {
            filename = path.resolve(basePath);
          } else {
            filename = toRealPath(basePath);
          }
        } else if (preserveSymlinksMain) {
          // For the main module, we use the preserveSymlinksMain flag instead
          // mainly for backward compatibility, as the preserveSymlinks flag
          // historically has not applied to the main module.  Most likely this
          // was intended to keep .bin/ binaries working, as following those
          // symlinks is usually required for the imports in the corresponding
          // files to resolve; that said, in some use cases following symlinks
          // causes bigger problems which is why the preserveSymlinksMain option
          // is needed.
          filename = path.resolve(basePath);
        } else {
          filename = toRealPath(basePath);
        }
      }

      if (!filename) {
        // Try it with each of the extensions
        if (exts === undefined)
          exts = ObjectKeys(Module._extensions);
        filename = tryExtensions(basePath, exts, isMain);
      }
    }

    if (!filename &amp;&amp; rc === 1) {  // Directory.
      // try it with each of the extensions at &quot;index&quot;
      if (exts === undefined)
        exts = ObjectKeys(Module._extensions);
      filename = tryPackage(basePath, exts, isMain, request);
    }

    if (filename) {
      Module._pathCache[cacheKey] = filename;
      return filename;
    }
  }

  return false;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._initPaths" id="apidoc.elem.utility2.Module._initPaths">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_initPaths
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv(&apos;HOME&apos;);
  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv(&apos;NODE_PATH&apos;);

  // process.execPath is $PREFIX/bin/node except on Windows where it is
  // $PREFIX\node.exe where $PREFIX is the root of the Node.js installation.
  const prefixDir = isWindows ?
    path.resolve(process.execPath, &apos;..&apos;) :
    path.resolve(process.execPath, &apos;..&apos;, &apos;..&apos;);

  let paths = [path.resolve(prefixDir, &apos;lib&apos;, &apos;node&apos;)];

  if (homeDir) {
    paths.unshift(path.resolve(homeDir, &apos;.node_libraries&apos;));
    paths.unshift(path.resolve(homeDir, &apos;.node_modules&apos;));
  }

  if (nodePath) {
    paths = nodePath.split(path.delimiter).filter(function pathsFilterCB(path) {
      return !!path;
    }).concat(paths);
  }

  modulePaths = paths;

  // Clone as a shallow copy, for introspection.
  Module.globalPaths = modulePaths.slice(0);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._load" id="apidoc.elem.utility2.Module._load">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_load
        <span class="apidocSignatureSpan">(request, parent, isMain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, parent, isMain) {
  let relResolveCacheIdentifier;
  if (parent) {
    debug(&apos;Module._load REQUEST %s parent: %s&apos;, request, parent.id);
    // Fast path for (lazy loaded) modules in the same directory. The indirect
    // caching is required to allow cache invalidation without changing the old
    // cache key names.
    relResolveCacheIdentifier = `${parent.path}\x00${request}`;
    const filename = relativeResolveCache[relResolveCacheIdentifier];
    if (filename !== undefined) {
      const cachedModule = Module._cache[filename];
      if (cachedModule !== undefined) {
        updateChildren(parent, cachedModule, true);
        if (!cachedModule.loaded)
          return getExportsForCircularRequire(cachedModule);
        return cachedModule.exports;
      }
      delete relativeResolveCache[relResolveCacheIdentifier];
    }
  }

  const filename = Module._resolveFilename(request, parent, isMain);

  const cachedModule = Module._cache[filename];
  if (cachedModule !== undefined) {
    updateChildren(parent, cachedModule, true);
    if (!cachedModule.loaded)
      return getExportsForCircularRequire(cachedModule);
    return cachedModule.exports;
  }

  const mod = loadNativeModule(filename, request);
  if (mod &amp;&amp; mod.canBeRequiredByUsers) return mod.exports;

  // Don&apos;t call updateChildren(), Module constructor already does.
  const module = new Module(filename, parent);

  if (isMain) {
    process.mainModule = module;
    module.id = &apos;.&apos;;
  }

  Module._cache[filename] = module;
  if (parent !== undefined) {
    relativeResolveCache[relResolveCacheIdentifier] = filename;
  }

  let threw = true;
  try {
    // Intercept exceptions that occur during the first tick and rekey them
    // on error instance rather than module instance (which will immediately be
    // garbage collected).
    if (enableSourceMaps) {
      try {
        module.load(filename);
      } catch (err) {
        rekeySourceMap(Module._cache[filename], err);
        throw err;<span class="apidocCodeCommentSpan"> /* node-do-not-add-exception-line */
</span>      }
    } else {
      module.load(filename);
    }
    threw = false;
  } finally {
    if (threw) {
      delete Module._cache[filename];
      if (parent !== undefined) {
        delete relativeResolveCache[relResolveCacheIdentifier];
        const children = parent &amp;&amp; parent.children;
        if (ArrayIsArray(children)) {
          const index = children.indexOf(module);
          if (index !== -1) {
            children.splice(index, 1);
          }
        }
      }
    } else if (module.exports &amp;&amp;
               !isProxy(module.exports) &amp;&amp;
               ObjectGetPrototypeOf(module.exports) ===
                 CircularRequirePrototypeWarningProxy) {
      ObjectSetPrototypeOf(module.exports, PublicObjectPrototype);
    }
  }

  return module.exports;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._nodeModulePaths" id="apidoc.elem.utility2.Module._nodeModulePaths">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_nodeModulePaths
        <span class="apidocSignatureSpan">(from)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(from) {
  // Guarantee that &apos;from&apos; is absolute.
  from = path.resolve(from);
  // Return early not only to avoid unnecessary work, but to *avoid* returning
  // an array of two items for a root: [ &apos;//node_modules&apos;, &apos;/node_modules&apos; ]
  if (from === &apos;/&apos;)
    return [&apos;/node_modules&apos;];

  // note: this approach *only* works when the path is guaranteed
  // to be absolute.  Doing a fully-edge-case-correct path.split
  // that works on both Windows and Posix is non-trivial.
  const paths = [];
  for (let i = from.length - 1, p = 0, last = from.length; i &gt;= 0; --i) {
    const code = from.charCodeAt(i);
    if (code === CHAR_FORWARD_SLASH) {
      if (p !== nmLen)
        paths.push(from.slice(0, last) + &apos;/node_modules&apos;);
      last = i;
      p = 0;
    } else if (p !== -1) {
      if (nmChars[p] === code) {
        ++p;
      } else {
        p = -1;
      }
    }
  }

  // Append /node_modules to handle root paths.
  paths.push(&apos;/node_modules&apos;);

  return paths;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._preloadModules" id="apidoc.elem.utility2.Module._preloadModules">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_preloadModules
        <span class="apidocSignatureSpan">(requests)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(requests) {
  if (!ArrayIsArray(requests))
    return;

  // Preloaded modules have a dummy parent module which is deemed to exist
  // in the current working directory. This seeds the search path for
  // preloaded modules.
  const parent = new Module(&apos;internal/preload&apos;, null);
  try {
    parent.paths = Module._nodeModulePaths(process.cwd());
  } catch (e) {
    if (e.code !== &apos;ENOENT&apos;) {
      throw e;
    }
  }
  for (let n = 0; n &lt; requests.length; n++)
    parent.require(requests[n]);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._resolveFilename" id="apidoc.elem.utility2.Module._resolveFilename">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveFilename
        <span class="apidocSignatureSpan">(request, parent, isMain, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, parent, isMain, options) {
  if (NativeModule.canBeRequiredByUsers(request)) {
    return request;
  }

  let paths;

  if (typeof options === &apos;object&apos; &amp;&amp; options !== null) {
    if (ArrayIsArray(options.paths)) {
      const isRelative = request.startsWith(&apos;./&apos;) ||
          request.startsWith(&apos;../&apos;) ||
          ((isWindows &amp;&amp; request.startsWith(&apos;.\\&apos;)) ||
          request.startsWith(&apos;..\\&apos;));

      if (isRelative) {
        paths = options.paths;
      } else {
        const fakeParent = new Module(&apos;&apos;, null);

        paths = [];

        for (let i = 0; i &lt; options.paths.length; i++) {
          const path = options.paths[i];
          fakeParent.paths = Module._nodeModulePaths(path);
          const lookupPaths = Module._resolveLookupPaths(request, fakeParent);

          for (let j = 0; j &lt; lookupPaths.length; j++) {
            if (!paths.includes(lookupPaths[j]))
              paths.push(lookupPaths[j]);
          }
        }
      }
    } else if (options.paths === undefined) {
      paths = Module._resolveLookupPaths(request, parent);
    } else {
      throw new ERR_INVALID_OPT_VALUE(&apos;options.paths&apos;, options.paths);
    }
  } else {
    paths = Module._resolveLookupPaths(request, parent);
  }

  if (parent &amp;&amp; parent.filename) {
    const filename = trySelf(parent.filename, request);
    if (filename) {
      const cacheKey = request + &apos;\x00&apos; +
          (paths.length === 1 ? paths[0] : paths.join(&apos;\x00&apos;));
      Module._pathCache[cacheKey] = filename;
      return filename;
    }
  }

  // Look up the filename first, since that&apos;s the cache key.
  const filename = Module._findPath(request, paths, isMain, false);
  if (filename) return filename;
  const requireStack = [];
  for (let cursor = parent;
    cursor;
    cursor = cursor.parent) {
    requireStack.push(cursor.filename || cursor.id);
  }
  let message = `Cannot find module &apos;${request}&apos;`;
  if (requireStack.length &gt; 0) {
    message = message + &apos;\nRequire stack:\n- &apos; + requireStack.join(&apos;\n- &apos;);
  }
  // eslint-disable-next-line no-restricted-syntax
  const err = new Error(message);
  err.code = &apos;MODULE_NOT_FOUND&apos;;
  err.requireStack = requireStack;
  throw err;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module._resolveLookupPaths" id="apidoc.elem.utility2.Module._resolveLookupPaths">
        function <span class="apidocSignatureSpan">utility2.Module.</span>_resolveLookupPaths
        <span class="apidocSignatureSpan">(request, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(request, parent) {
  if (NativeModule.canBeRequiredByUsers(request)) {
    debug(&apos;looking for %j in []&apos;, request);
    return null;
  }

  // Check for node modules paths.
  if (request.charAt(0) !== &apos;.&apos; ||
      (request.length &gt; 1 &amp;&amp;
      request.charAt(1) !== &apos;.&apos; &amp;&amp;
      request.charAt(1) !== &apos;/&apos; &amp;&amp;
      (!isWindows || request.charAt(1) !== &apos;\\&apos;))) {

    let paths = modulePaths;
    if (parent != null &amp;&amp; parent.paths &amp;&amp; parent.paths.length) {
      paths = parent.paths.concat(paths);
    }

    debug(&apos;looking for %j in %j&apos;, request, paths);
    return paths.length &gt; 0 ? paths : null;
  }

  // In REPL, parent.filename is null.
  if (!parent || !parent.id || !parent.filename) {
    // Make require(&apos;./path/to/foo&apos;) work - normally the path is taken
    // from realpath(__filename) but in REPL there is no filename
    const mainPaths = [&apos;.&apos;];

    debug(&apos;looking for %j in %j&apos;, request, mainPaths);
    return mainPaths;
  }

  debug(&apos;RELATIVE: requested: %s from parent.id %s&apos;, request, parent.id);

  const parentDir = [path.dirname(parent.filename)];
  debug(&apos;looking for %j&apos;, parentDir);
  return parentDir;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.createRequire" id="apidoc.elem.utility2.Module.createRequire">
        function <span class="apidocSignatureSpan">utility2.Module.</span>createRequire
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createRequire(filename) {
  let filepath;

  if (filename instanceof URL ||
      (typeof filename === &apos;string&apos; &amp;&amp; !path.isAbsolute(filename))) {
    try {
      filepath = fileURLToPath(filename);
    } catch {
      throw new ERR_INVALID_ARG_VALUE(&apos;filename&apos;, filename,
                                      createRequireError);
    }
  } else if (typeof filename !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_VALUE(&apos;filename&apos;, filename, createRequireError);
  } else {
    filepath = filename;
  }
  return createRequireFromPath(filepath);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.createRequireFromPath" id="apidoc.elem.utility2.Module.createRequireFromPath">
        function <span class="apidocSignatureSpan">utility2.Module.</span>createRequireFromPath
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated(...args) {
  if (!warned) {
    warned = true;
    if (code !== undefined) {
      if (!codesWarned.has(code)) {
        process.emitWarning(msg, &apos;DeprecationWarning&apos;, code, deprecated);
        codesWarned.add(code);
      }
    } else {
      process.emitWarning(msg, &apos;DeprecationWarning&apos;, deprecated);
    }
  }
  if (new.target) {
    return ReflectConstruct(fn, args, new.target);
  }
  return fn.apply(this, args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.findSourceMap" id="apidoc.elem.utility2.Module.findSourceMap">
        function <span class="apidocSignatureSpan">utility2.Module.</span>findSourceMap
        <span class="apidocSignatureSpan">(uri, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findSourceMap(uri, error) {
  if (!Module) Module = require(&apos;internal/modules/cjs/loader&apos;).Module;
  if (!SourceMap) {
    SourceMap = require(&apos;internal/source_map/source_map&apos;).SourceMap;
  }
  let sourceMap = cjsSourceMapCache.get(Module._cache[uri]);
  if (!uri.startsWith(&apos;file://&apos;)) uri = normalizeReferrerURL(uri);
  if (sourceMap === undefined) {
    sourceMap = esmSourceMapCache.get(uri);
  }
  if (sourceMap === undefined) {
    const candidateSourceMap = cjsSourceMapCache.get(error);
    if (candidateSourceMap &amp;&amp; uri === candidateSourceMap.filename) {
      sourceMap = candidateSourceMap;
    }
  }
  if (sourceMap &amp;&amp; sourceMap.data) {
    return new SourceMap(sourceMap.data);
  }
  return undefined;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.runMain" id="apidoc.elem.utility2.Module.runMain">
        function <span class="apidocSignatureSpan">utility2.Module.</span>runMain
        <span class="apidocSignatureSpan">(main = process.argv[1])</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function executeUserEntryPoint(main = process.argv[1]) {
  const resolvedMain = resolveMainPath(main);
  const useESMLoader = shouldUseESMLoader(resolvedMain);
  if (useESMLoader) {
    runMainESM(resolvedMain || main);
  } else {
    // Module._load is the monkey-patchable CJS module loader.
    Module._load(main, null, true);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        process.argv.splice(1, 1, __dirname + &quot;/lib.istanbul.js&quot;, &quot;cover&quot;);
        local.istanbul.cliDict[process.argv[2]]();
        return;
    }
    // start
    process.argv.splice(1, 1);
    process.argv[1] = local.path.resolve(process.argv[1]);
    local.Module.<span class="apidocCodeKeywordSpan">runMain</span>();
}
// runme
if (local.env.npm_config_runme) {
    require(local.path.resolve(local.env.npm_config_runme));
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.syncBuiltinESMExports" id="apidoc.elem.utility2.Module.syncBuiltinESMExports">
        function <span class="apidocSignatureSpan">utility2.Module.</span>syncBuiltinESMExports
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function syncBuiltinESMExports() {
  for (const mod of NativeModule.map.values()) {
    if (mod.canBeRequiredByUsers) {
      mod.syncExports();
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.Module._extensions" id="apidoc.module.utility2.Module._extensions">module utility2.Module._extensions</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.Module.prototype" id="apidoc.module.utility2.Module.prototype">module utility2.Module.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.Module.prototype._compile" id="apidoc.elem.utility2.Module.prototype._compile">
        function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>_compile
        <span class="apidocSignatureSpan">(content, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(content, filename) {
  let moduleURL;
  let redirects;
  if (manifest) {
    moduleURL = pathToFileURL(filename);
    redirects = manifest.getRedirector(moduleURL);
    manifest.assertIntegrity(moduleURL, content);
  }

  maybeCacheSourceMap(filename, content, this);
  const compiledWrapper = wrapSafe(filename, content, this);

  let inspectorWrapper = null;
  if (getOptionValue(&apos;--inspect-brk&apos;) &amp;&amp; process._eval == null) {
    if (!resolvedArgv) {
      // We enter the repl if we&apos;re not given a filename argument.
      if (process.argv[1]) {
        try {
          resolvedArgv = Module._resolveFilename(process.argv[1], null, false);
        } catch {
          // We only expect this codepath to be reached in the case of a
          // preloaded module (it will fail earlier with the main entry)
          assert(ArrayIsArray(getOptionValue(&apos;--require&apos;)));
        }
      } else {
        resolvedArgv = &apos;repl&apos;;
      }
    }

    // Set breakpoint on module start
    if (resolvedArgv &amp;&amp; !hasPausedEntry &amp;&amp; filename === resolvedArgv) {
      hasPausedEntry = true;
      inspectorWrapper = internalBinding(&apos;inspector&apos;).callAndPauseOnStart;
    }
  }
  const dirname = path.dirname(filename);
  const require = makeRequireFunction(this, redirects);
  let result;
  const exports = this.exports;
  const thisValue = exports;
  const module = this;
  if (requireDepth === 0) statCache = new Map();
  if (inspectorWrapper) {
    result = inspectorWrapper(compiledWrapper, thisValue, exports,
                              require, module, filename, dirname);
  } else {
    result = compiledWrapper.call(thisValue, exports, require, module,
                                  filename, dirname);
  }
  hasLoadedAnyUserCJSModule = true;
  if (requireDepth === 0) statCache = null;
  return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// jslint code
local.jslintAndPrint(code, tmp);
// instrument code
code = local.istanbulInstrumentInPackage(code, tmp);
// init module.exports
module = new local.Module(tmp);
require.cache[tmp] = module;
module.<span class="apidocCodeKeywordSpan">_compile</span>(code, tmp);
// init exports
module.exports.utility2 = local;
module.exports[local.env.npm_package_nameLib] = (
    globalThis.utility2_moduleExports
);
// init assets lib.xxx.js
local.assetsDict[
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.prototype.load" id="apidoc.elem.utility2.Module.prototype.load">
        function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>load
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(filename) {
  debug(&apos;load %j for module %j&apos;, filename, this.id);

  assert(!this.loaded);
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));

  const extension = findLongestRegisteredExtension(filename);
  // allow .mjs to be overridden
  if (filename.endsWith(&apos;.mjs&apos;) &amp;&amp; !Module._extensions[&apos;.mjs&apos;]) {
    throw new ERR_REQUIRE_ESM(filename);
  }
  Module._extensions[extension](this, filename);
  this.loaded = true;

  const ESMLoader = asyncESM.ESMLoader;
  const url = `${pathToFileURL(filename)}`;
  const module = ESMLoader.moduleMap.get(url);
  // Create module entry at load time to snapshot exports correctly
  const exports = this.exports;
  // Called from cjs translator
  if (module !== undefined &amp;&amp; module.module !== undefined) {
    if (module.module.getStatus() &gt;= kInstantiated)
      module.module.setExport(&apos;default&apos;, exports);
  } else {
    // Preemptively cache
    // We use a function to defer promise creation for async hooks.
    ESMLoader.moduleMap.set(
      url,
      // Module job creation will start promises.
      // We make it a function to lazily trigger those promises
      // for async hooks compatibility.
      () =&gt; new ModuleJob(ESMLoader, url, () =&gt;
        new ModuleWrap(url, undefined, [&apos;default&apos;], function() {
          this.setExport(&apos;default&apos;, exports);
        })
      , false /* isMain */, false /* inspectBrk */)
    );
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.Module.prototype.require" id="apidoc.elem.utility2.Module.prototype.require">
        function <span class="apidocSignatureSpan">utility2.Module.prototype.</span>require
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateString(id, &apos;id&apos;);
  if (id === &apos;&apos;) {
    throw new ERR_INVALID_ARG_VALUE(&apos;id&apos;, id,
                                    &apos;must be a non-empty string&apos;);
  }
  requireDepth++;
  try {
    return Module._load(id, this, /* isMain */ false);
  } finally {
    requireDepth--;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}).slice(0, 256).map(readExample);
// init moduleMain
local.tryCatchOnError(function () {
    console.error(&quot;apidocCreate - requiring &quot; + opt.dir + &quot; ...&quot;);
    moduleMain = {};
    moduleMain = (
        opt.moduleDict[opt.env.npm_package_name]
        || opt.<span class="apidocCodeKeywordSpan">require</span>(opt.dir)
        || opt.require(
            opt.dir + &quot;/&quot;
            + (opt.packageJson.bin)[Object.keys(opt.packageJson.bin)[0]]
        ) || {}
    );
    opt.circularSet.add(moduleMain);
    console.error(&quot;apidocCreate - ... required &quot; + opt.dir);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2._http" id="apidoc.module.utility2._http">module utility2._http</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2._http.createServer" id="apidoc.elem.utility2._http.createServer">
        function <span class="apidocSignatureSpan">utility2._http.</span>createServer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will emulate in browser, node&apos;s http.createServer function
 * https://nodejs.org/dist/v0.12.18/docs/api/all.html#all_http_createserver_requestlistener
 */
</span>    return {
        listen: function (port, onError) {
            onError(undefined, port);
        }
    };
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (options.port == null &amp;&amp; !options.server &amp;&amp; !options.noServer) {
      throw new TypeError(
&apos;One of the &quot;port&quot;, &quot;server&quot;, or &quot;noServer&quot; options must be specified&apos;
      );
    }

    if (options.port != null) {
      this._server = http.<span class="apidocCodeKeywordSpan">createServer</span>((req, res) =&gt; {
const body = http.STATUS_CODES[426];

res.writeHead(426, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos;
});
res.end(body);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2._http.request" id="apidoc.elem.utility2._http.request">
        function <span class="apidocSignatureSpan">utility2._http.</span>request
        <span class="apidocSignatureSpan">(xhr, onResponse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (xhr, onResponse) {
<span class="apidocCodeCommentSpan">/*
 * this function will emulate in browser, node&apos;s http.request function
 * https://nodejs.org/dist/v0.12.18/docs/api/all.html#all_http_request_options_callback
 */
</span>    let bufList;
    let data;
    let handler;
    let isDone;
    let req;
    let res;
    xhr = {
        end: function (_data) {
            if (isDone) {
                return;
            }
            isDone = true;
            data = _data;
            // async send req from client to server
            setTimeout(function () {
                local.serverLocalReqHandler(req, res);
            });
        },
        headers: xhr.headers,
        method: xhr.method,
        on: function () {
            return xhr;
        },
        timeout: xhr.timeout,
        url: xhr.href
    };
    bufList = [];
    handler = new globalThis.EventTarget();
    req = {
        emit: function (type, data) {
            handler.dispatchEvent(new globalThis.CustomEvent(&quot;req.&quot; + type, {
                detail: data
            }));
        },
        headers: xhr.headers,
        httpVersion: &quot;1.1&quot;,
        method: xhr.method,
        on: function (type, onEvent) {
            handler.addEventListener(&quot;req.&quot; + type, function (evt) {
                onEvent(evt.detail);
            });
            if (req.readable &amp;&amp; type === &quot;end&quot;) {
                req.readable = null;
                req.emit(&quot;data&quot;, data);
                req.emit(&quot;end&quot;);
            }
            return req;
        },
        pipe: function (writable) {
            req.on(&quot;data&quot;, function (buf) {
                writable.write(buf);
            });
            req.on(&quot;end&quot;, function () {
                writable.end();
            });
            return writable;
        },
        readable: true,
        url: xhr.url
    };
    res = {
        emit: function (type, data) {
            handler.dispatchEvent(new globalThis.CustomEvent(&quot;res.&quot; + type, {
                detail: data
            }));
        },
        end: function (data) {
            if (res._isDone) {
                return;
            }
            res._isDone = true;
            bufList.push(data);
            // notify server res is finished
            res.emit(&quot;finish&quot;);
            // pass res to client
            onResponse(res);
            res.emit(&quot;data&quot;, local.bufferConcat(bufList));
            res.emit(&quot;end&quot;);
        },
        on: function (type, onEvent) {
            handler.addEventListener(&quot;res.&quot; + type, function (evt) {
                onEvent(evt.detail);
            });
            return res;
        },
        setHeader: function (key, val) {
            xhr.resHeaders[key.toLowerCase()] = val;
        },
        statusCode: 200,
        write: function (data) {
            bufList.push(data);
        }
    };
    return xhr;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}
// node - request
errStack = new Error().stack;
request = require(
    url.indexOf(&quot;https:&quot;) === 0
    ? &quot;https&quot;
    : &quot;http&quot;
).<span class="apidocCodeKeywordSpan">request</span>(url, opt, function (aa) {
    response = aa;
    let bufList;
    // handle err
    response.on(&quot;error&quot;, reject2);
    // handle stream
    if (opt.responseType === &quot;stream&quot;) {
        resolve2(response);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.apidoc" id="apidoc.module.utility2.apidoc">module utility2.apidoc</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.apidoc.apidocCreate" id="apidoc.elem.utility2.apidoc.apidocCreate">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apidocCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will create the apidoc from &lt;opt&gt;.dir
 */
</span>    let elemCreate;
    let module;
    let moduleMain;
    let readExample;
    let tmp;
    let toString;
    let trimStart;
    elemCreate = function (module, prefix, key) {
    /*
     * this function will create the apidoc-elem in given &lt;module&gt;
     */
        let elem;
        if (opt.modeNoApidoc) {
            return elem;
        }
        elem = {};
        elem.moduleName = prefix.split(&quot;.&quot;);
        // handle case where module is a function
        if (elem.moduleName.slice(-1)[0] === key) {
            elem.moduleName.pop();
        }
        elem.moduleName = elem.moduleName.join(&quot;.&quot;);
        elem.id = encodeURIComponent(&quot;apidoc.elem.&quot; + prefix + &quot;.&quot; + key);
        elem.typeof = typeof module[key];
        elem.name = (
            elem.typeof + &quot; &lt;span class=\&quot;apidocSignatureSpan\&quot;&gt;&quot;
            + elem.moduleName + &quot;.&lt;/span&gt;&quot; + key
        );
        // handle case where module is a function
        elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
        if (elem.typeof !== &quot;function&quot;) {
            return elem;
        }
        // init source
        elem.source = local.stringHtmlSafe(
            trimStart(toString(module[key])) || &quot;n/a&quot;
        ).replace((
            /\([\S\s]*?\)/
        ), function (match0) {
            // init signature
            elem.signature = match0.replace((
                /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
            ), &quot;&quot;).replace((
                /,/g
            ), &quot;, &quot;).replace((
                /\s+/g
            ), &quot; &quot;);
            return elem.signature;
        }).replace((
            /(\u0020*?\/\*[\S\s]*?\*\/\n)/
        ), &quot;&lt;span class=\&quot;apidocCodeCommentSpan\&quot;&gt;$1&lt;/span&gt;&quot;).replace((
            /^function\u0020\(/
        ), key + &quot; = function (&quot;);
        // init example
        opt.exampleList.some(function (example) {
            example.replace(
                new RegExp(&quot;((?:\n.*?){8}\\.)(&quot; + key + &quot;)(\\((?:.*?\n){8})&quot;),
                function (ignore, match1, match2, match3) {
                    elem.example = &quot;...&quot; + trimStart(
                        local.stringHtmlSafe(match1)
                        + &quot;&lt;span class=\&quot;apidocCodeKeywordSpan\&quot;&gt;&quot;
                        + local.stringHtmlSafe(match2)
                        + &quot;&lt;/span&gt;&quot;
                        + local.stringHtmlSafe(match3)
                    ).trimEnd() + &quot;\n...&quot;;
                    return &quot;&quot;;
                }
            );
            return elem.example;
        });
        elem.example = elem.example || &quot;n/a&quot;;
        return elem;
    };
    readExample = function (file) {
    /*
     * this function will read the example from given file
     */
        let result;
        local.tryCatchOnError(function () {
            file = local.path.resolve(opt.dir, file);
            console.error(&quot;apidocCreate - readExample &quot; + file);
            result = &quot;&quot;;
            result = local.identity(
                &quot;\n\n\n\n\n\n\n\n&quot;
                // bug-workaround - truncate example to manageable size
                + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
                + &quot;\n\n\n\n\n\n\n\n&quot;
            ).replace((
                /\r\n*/g
            ), &quot;\n&quot;);
        }, console.error);
        return result;
    };
    toString = function (value) {
    /*
     * this function will try to return the string form of the value
     */
        let result;
        local.tryCatchOnError(function () {
            result = &quot;&quot;;
            result = String(value);
        }, console.error);
        return result;
    };
    trimStart = function (str) {
    /*...</pre></li>
    <li>example use<pre class="apidocCodePre">...

local.cliDict._default = function () {
/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
    // jslint files
    process.stdout.write(local.<span class="apidocCodeKeywordSpan">apidocCreate</span>({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.apidocModuleDictAdd" id="apidoc.elem.utility2.apidoc.apidocModuleDictAdd">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>apidocModuleDictAdd
        <span class="apidocSignatureSpan">(opt, moduleDict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apidocModuleDictAdd = function (opt, moduleDict) {
<span class="apidocCodeCommentSpan">/*
 * this function will add the modules in &lt;moduleDict&gt; to &lt;opt&gt;.moduleDict
 */
</span>    let isModule;
    let objectKeys;
    let tmp;
    objectKeys = function (dict) {
    /*
     * this function will return a list of the dict&apos;s keys, with valid getters
     */
        return Object.keys(dict).sort().filter(function (key) {
            return local.tryCatchOnError(function () {
                return dict[key] || true;
            }, local.nop);
        });
    };
    [
        &quot;child&quot;, &quot;prototype&quot;, &quot;grandchild&quot;, &quot;prototype&quot;
    ].forEach(function (elem) {
        objectKeys(moduleDict).forEach(function (prefix) {
            if (!(
                /^\w[\w\-.]*?$/
            ).test(prefix)) {
                return;
            }
            objectKeys(moduleDict[prefix]).forEach(function (key) {
                if (!(
                    /^\w[\w\-.]*?$/
                ).test(key) || !moduleDict[prefix][key]) {
                    return;
                }
                tmp = (
                    elem === &quot;prototype&quot;
                    ? {
                        module: moduleDict[prefix][key].prototype,
                        name: prefix + &quot;.&quot; + key + &quot;.prototype&quot;
                    }
                    : {
                        module: moduleDict[prefix][key],
                        name: prefix + &quot;.&quot; + key
                    }
                );
                if (
                    !tmp.module
                    || !(
                        typeof tmp.module === &quot;function&quot;
                        || typeof tmp.module === &quot;object&quot;
                    )
                    || Array.isArray(tmp.module)
                    || opt.moduleDict[tmp.name]
                    || opt.circularSet.has(tmp.module)
                ) {
                    return;
                }
                isModule = Array.from([
                    tmp.module,
                    tmp.module.prototype
                ]).some(function (dict) {
                    return objectKeys(dict || {}).some(function (key) {
                        return typeof dict[key] === &quot;function&quot;;
                    });
                });
                if (!isModule) {
                    return;
                }
                opt.circularSet.add(tmp.module);
                opt.moduleDict[tmp.name] = tmp.module;
            });
        });
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    opt.circularSet.add(opt.moduleDict[key]);
});
// init circularSet - prototype
opt.circularSet.forEach(function (elem) {
    opt.circularSet.add(elem &amp;&amp; elem.prototype);
});
// init moduleDict child
local.<span class="apidocCodeKeywordSpan">apidocModuleDictAdd</span>(opt, opt.moduleDict);
// init moduleExtraDict
opt.moduleExtraDict[opt.env.npm_package_name] = (
    opt.moduleExtraDict[opt.env.npm_package_name] || {}
);
module = opt.moduleExtraDict[opt.env.npm_package_name];
([
    1, 2, 3, 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.assert" id="apidoc.elem.utility2.apidoc.assert">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.assertOrThrow" id="apidoc.elem.utility2.apidoc.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;msg&gt; if &lt;passed&gt; is falsy
 */
</span>    if (passed) {
        return;
    }
    throw (
        (
            msg
            &amp;&amp; typeof msg.message === &quot;string&quot;
            &amp;&amp; typeof msg.stack === &quot;string&quot;
        )
        // if msg is err, then leave as is
        ? msg
        : new Error(
            typeof msg === &quot;string&quot;
            // if msg is a string, then leave as is
            ? msg
            // else JSON.stringify msg
            : JSON.stringify(msg, undefined, 4)
        )
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(str).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.cliRun" id="apidoc.elem.utility2.apidoc.cliRun">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let str;
        let strDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            str = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(str);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(str).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        str = &quot;&quot;;
        str += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        str += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file
                + &quot;  &quo...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.coalesce" id="apidoc.elem.utility2.apidoc.coalesce">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(str);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.events" id="apidoc.elem.utility2.apidoc.events">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>events
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.fsReadFileOrDefaultSync" id="apidoc.elem.utility2.apidoc.fsReadFileOrDefaultSync">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsReadFileOrDefaultSync
        <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrDefaultSync = function (pathname, type, dflt) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync-read &lt;pathname&gt; with given &lt;type&gt; and &lt;dflt&gt;
 */
</span>    let fs;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;ignore&quot;, &quot;ignore&quot;, 2
        ]
    });
}
if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
    // init assets index.html
    local.assetsDict[&quot;/index.html&quot;] = (
        local.<span class="apidocCodeKeywordSpan">fsReadFileOrDefaultSync</span>(&quot;index.html&quot;, &quot;utf8&quot;, &quot
;&quot;)
        || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
    );
    local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
    local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
        __filename,
        &quot;utf8&quot;
    ).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.fsRmrfSync" id="apidoc.elem.utility2.apidoc.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(pathname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (pathname) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;pathname&gt;
 */
</span>    let child_process;
    // do nothing if module does not exist
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    if (process.platform !== &quot;win32&quot;) {
        child_process.spawnSync(&quot;rm&quot;, [
            &quot;-rf&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        });
        return;
    }
    try {
        child_process.spawnSync(&quot;rd&quot;, [
            &quot;/s&quot;, &quot;/q&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, &quot;ignore&quot;
            ]
        });
    } catch (ignore) {}
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.apidoc.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(pathname, data, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (pathname, data, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;pathname&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    let success;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
        success = true;
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require(&quot;path&quot;).dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    || local.env.npm_config_mode_test_case
    !== &quot;testCase_buildApidoc_default&quot;
) {
    onError(undefined, opt);
    return;
}
// save apidoc.html
local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
    &quot;tmp/build/apidoc.html&quot;,
    local.apidocCreate(local.objectAssignDefault(opt, {
        blacklistDict: local,
        require: require2
    })),
    &quot;wrote file apidoc - {{pathname}}&quot;
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.identity" id="apidoc.elem.utility2.apidoc.identity">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.moduleDirname" id="apidoc.elem.utility2.apidoc.moduleDirname">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>moduleDirname
        <span class="apidocSignatureSpan">(module, pathList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moduleDirname = function (module, pathList) {
<span class="apidocCodeCommentSpan">/*
 * this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
 */
</span>    let result;
    // search &quot;.&quot;
    if (!module || module === &quot;.&quot; || module.indexOf(&quot;/&quot;) &gt;= 0) {
        return require(&quot;path&quot;).resolve(module || &quot;&quot;);
    }
    // search pathList
    Array.from([
        pathList,
        require(&quot;module&quot;).globalPaths,
        [
            process.env.HOME + &quot;/node_modules&quot;, &quot;/usr/local/lib/node_modules&quot;
        ]
    ]).flat().some(function (path) {
        try {
            result = require(&quot;path&quot;).resolve(path + &quot;/&quot; + module);
            result = require(&quot;fs&quot;).statSync(result).isDirectory() &amp;&amp; result;
            return result;
        } catch (ignore) {
            result = &quot;&quot;;
        }
    });
    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return match0.replace((
            /(.{128}(?:\b|\w+))/g
        ), &quot;$1\n&quot;).trimEnd();
    });
    return str;
};
// init opt
opt.dir = local.<span class="apidocCodeKeywordSpan">moduleDirname</span>(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.objectAssignDefault(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.nop" id="apidoc.elem.utility2.apidoc.nop">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - function
(function () {
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(require);
globalThis.__coverageInclude__ = local.coalesce(
globalThis.__coverageInclude__,
{}
);
// mock builtins
process = local.process || {
cwd: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.objectAssignDefault" id="apidoc.elem.utility2.apidoc.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (tgt = {}, src = {}, depth = 0) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;tgt&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;src&gt;
 */
</span>    let recurse;
    recurse = function (tgt, src, depth) {
        Object.entries(src).forEach(function ([
            key, bb
        ]) {
            let aa;
            aa = tgt[key];
            if (aa === undefined || aa === null || aa === &quot;&quot;) {
                tgt[key] = bb;
                return;
            }
            if (
                depth !== 0
                &amp;&amp; typeof aa === &quot;object&quot; &amp;&amp; aa &amp;&amp; !Array.isArray(aa)
                &amp;&amp; typeof bb === &quot;object&quot; &amp;&amp; bb &amp;&amp; !Array.isArray(bb)
            ) {
                recurse(aa, bb, depth - 1);
            }
        });
    };
    recurse(tgt, src, depth | 0);
    return tgt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return str;
};
// init opt
opt.dir = local.moduleDirname(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.parse(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.stream" id="apidoc.elem.utility2.apidoc.stream">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>stream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream(opts) {
  EE.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.stringHtmlSafe" id="apidoc.elem.utility2.apidoc.stringHtmlSafe">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>stringHtmlSafe
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringHtmlSafe = function (str) {
<span class="apidocCodeCommentSpan">/*
 * this function will make &lt;str&gt; html-safe
 * https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html
 */
</span>    return str.replace((
        /&amp;/gu
    ), &quot;&amp;&quot;).replace((
        /&quot;/gu
    ), &quot;&quot;&quot;).replace((
        /&apos;/gu
    ), &quot;&apos;&quot;).replace((
        /&lt;/gu
    ), &quot;&lt;&quot;).replace((
        /&gt;/gu
    ), &quot;&gt;&quot;).replace((
        /&amp;(amp;|apos;|gt;|lt;|quot;)/igu
    ), &quot;&amp;$1&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
);
// handle case where module is a function
elem.name = elem.name.replace(&quot;&gt;.&lt;&quot;, &quot;&gt;&lt;&quot;);
if (elem.typeof !== &quot;function&quot;) {
    return elem;
}
// init source
elem.source = local.<span class="apidocCodeKeywordSpan">stringHtmlSafe</span>(
    trimStart(toString(module[key])) || &quot;n/a&quot;
).replace((
    /\([\S\s]*?\)/
), function (match0) {
    // init signature
    elem.signature = match0.replace((
        /\u0020*?\/\*[\S\s]*?\*\/\u0020*/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.templateRender" id="apidoc.elem.utility2.apidoc.templateRender">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>templateRender
        <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRender = function (template, dict, opt, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    opt = opt || {};
    getVal = function (key) {
        argList = key.split(&quot; &quot;);
        val = dict;
        if (argList[0] === &quot;#this/&quot;) {
            return val;
        }
        if (argList[0] === &quot;#ii/&quot;) {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(&quot;.&quot;).forEach(function (key) {
            val = val &amp;&amp; val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case &quot;each&quot;:
        case &quot;eachTrimEndComma&quot;:
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join(&quot;&quot;)
                : &quot;&quot;
            );
            // remove trailing-comma from last elem
            if (helper === &quot;eachTrimEndComma&quot;) {
                val = val.trimEnd().replace((
                    /,$/
                ), &quot;&quot;);
            }
            return val;
        case &quot;if&quot;:
            partial = partial.split(&quot;{{#unless &quot; + key + &quot;}}&quot;);
            partial = (
                getVal(key)
                ? partial[0]
                // handle &quot;unless&quot; case
                : partial.slice(1).join(&quot;{{#unless &quot; + key + &quot;}}&quot;)
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case &quot;unless&quot;:
            return (
                getVal(key)
                ? &quot;&quot;
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || &quot;&quot;;
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                &quot;\\{\\{#(&quot; + match[1] + &quot;) (&quot; + match[2]
                + &quot;)\\}\\}([\\S\\s]*?)\\{\\{/&quot; + match[1] + &quot; &quot; + match[2]
                + &quot;\\}\\}&quot;
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case &quot;*&quot;:
                case &quot;+&quot;:
                case &quot;-&quot;:
                case &quot;/&quot;:
                    skip = ii + 1;
                    val = String(
                        fmt === &quot;*&quot;
                        ? Number(val) * Number(list[skip])
                        : fmt === &quot;+&quot;
                        ? Number(val) + Number(list[skip])
                        : fmt === &quot;-&quot;
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;...</pre></li>
    <li>example use<pre class="apidocCodePre">...
case &quot;each&quot;:
case &quot;eachTrimEndComma&quot;:
    val = getVal(key);
    val = (
        Array.isArray(val)
        ? val.map(function (dict, ii) {
            // recurse with partial
            return local.<span class="apidocCodeKeywordSpan">templateRender</span>(partial, dict, opt, ii);
        }).join(&quot;&quot;)
        : &quot;&quot;
    );
    // remove trailing-comma from last elem
    if (helper === &quot;eachTrimEndComma&quot;) {
        val = val.trimEnd().replace((
            /,$/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.apidoc.tryCatchOnError" id="apidoc.elem.utility2.apidoc.tryCatchOnError">
        function <span class="apidocSignatureSpan">utility2.apidoc.</span>tryCatchOnError
        <span class="apidocSignatureSpan">(fnc, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryCatchOnError = function (fnc, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will run &lt;fnc&gt; in tryCatch block,
 * else call onError with errCaught
 */
</span>    let result;
    // validate onError
    local.assertOrThrow(typeof onError === &quot;function&quot;, typeof onError);
    try {
        // reset errCaught
        local._debugTryCatchError = null;
        result = fnc();
        local._debugTryCatchError = null;
        return result;
    } catch (errCaught) {
        // debug errCaught
        local._debugTryCatchError = errCaught;
        return onError(errCaught);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return elem;
};
readExample = function (file) {
/*
 * this function will read the example from given file
 */
    let result;
    local.<span class="apidocCodeKeywordSpan">tryCatchOnError</span>(function () {
        file = local.path.resolve(opt.dir, file);
        console.error(&quot;apidocCreate - readExample &quot; + file);
        result = &quot;&quot;;
        result = local.identity(
            &quot;\n\n\n\n\n\n\n\n&quot;
            // bug-workaround - truncate example to manageable size
            + local.fs.readFileSync(file, &quot;utf8&quot;).slice(0, 262144)
...</pre></li>
    </ul>






























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.apidoc.cliDict" id="apidoc.module.utility2.apidoc.cliDict">module utility2.apidoc.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.apidoc.cliDict._default" id="apidoc.elem.utility2.apidoc.cliDict._default">
        function <span class="apidocSignatureSpan">utility2.apidoc.cliDict.</span>_default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_default = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;moduleDirectory&gt;
 * will create apidoc from &lt;moduleDirectory&gt;
 */
</span>    // jslint files
    process.stdout.write(local.apidocCreate({
        dir: process.argv[2],
        modulePathList: module.paths
    }));
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
       local.cliDict._help();
       return;
   }
   if (local.cliDict[process.argv[2]]) {
       local.cliDict[process.argv[2]]();
       return;
   }
   local.cliDict.<span class="apidocCodeKeywordSpan">_default</span>();
};

local.moduleDirname = function (module, pathList) {
/*
* this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
*/
   let result;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.cliDict" id="apidoc.module.utility2.cliDict">module utility2.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.browserTest" id="apidoc.elem.utility2.cliDict.utility2.browserTest">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.browserTest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.browserTest = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;urlList&gt; &lt;mode&gt;
 * will browser-test in parallel, comma-separated &lt;urlList&gt; with given &lt;mode&gt;
 */
</span>    local.browserTest({
        url: process.argv[3]
    }, local.onErrorDefault);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentDelete" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentDelete">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentDelete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentDelete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
 * will delete from github &lt;fileRemote|dirRemote&gt;
 */
</span>    local.github_crud.githubCrudContentDelete({
        message: process.argv[4],
        url: process.argv[3]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentGet" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentGet">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentGet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentGet = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt;
 * will get from github &lt;fileRemote&gt;
 */
</span>    local.github_crud.githubCrudContentGet({
        url: process.argv[3]
    }, function (err, data) {
        try {
            process.stdout.write(data);
        } catch (ignore) {}
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentPut" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentPut">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentPut
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentPut = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt; &lt;fileLocal&gt; &lt;commitMessage&gt;
 * will put on github &lt;fileRemote&gt;, &lt;fileLocal&gt;
 */
</span>    local.github_crud.githubCrudContentPutFile({
        message: process.argv[5],
        url: process.argv[3],
        file: process.argv[4]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudContentTouch" id="apidoc.elem.utility2.cliDict.utility2.githubCrudContentTouch">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudContentTouch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudContentTouch = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemoteList&gt; &lt;commitMessage&gt;
 * will touch on github in parallel, comma-separated &lt;fileRemoteList&gt;
 */
</span>    local.github_crud.githubCrudContentTouchList({
        message: process.argv[4],
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoCreate" id="apidoc.elem.utility2.cliDict.utility2.githubCrudRepoCreate">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoCreate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudRepoCreate = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will create on github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoCreateList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.githubCrudRepoDelete" id="apidoc.elem.utility2.cliDict.utility2.githubCrudRepoDelete">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.githubCrudRepoDelete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.githubCrudRepoDelete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will delete from github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoDeleteList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.start" id="apidoc.elem.utility2.cliDict.utility2.start">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.start = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;port&gt;
 * will start utility2 http-server on given &lt;port&gt; (default 8081)
 */
</span>    local.env.PORT = process.argv[3] || local.env.PORT;
    globalThis.local = local;
    local.replStart();
    local.testRunServer({});
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.cliDict.utility2.testReportCreate" id="apidoc.elem.utility2.cliDict.utility2.testReportCreate">
        function <span class="apidocSignatureSpan">utility2.cliDict.</span>utility2.testReportCreate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utility2.testReportCreate = function () {
<span class="apidocCodeCommentSpan">/*
 *
 * will create test-report
 */
</span>    process.exit(
        local.testReportCreate(
            JSON.parse(local.fs.readFileSync(
                local.path.resolve(
                    local.env.npm_config_dir_build + &quot;/test-report.json&quot;
                ),
                &quot;utf8&quot;
            ))
        ).testsFailed !== 0
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.github_crud" id="apidoc.module.utility2.github_crud">module utility2.github_crud</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.github_crud.ajax" id="apidoc.elem.utility2.github_crud.ajax">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>ajax
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will send an ajax-req
 * with given &lt;opt&gt;.url and callback &lt;onError&gt;
 * with err and timeout handling
 * example use:
    local.ajax({
        data: &quot;hello world&quot;,
        header: {&quot;x-header-hello&quot;: &quot;world&quot;},
        method: &quot;POST&quot;,
        url: &quot;/index.html&quot;
    }, function (err, xhr) {
        console.log(xhr.statusCode);
        console.log(xhr.responseText);
    });
 */
</span>    let ajaxProgressUpdate;
    let bufferValidateAndCoerce;
    let isDone;
    let local2;
    let onError2;
    let onEvent;
    let stack;
    let streamCleanup;
    let timeout;
    let tmp;
    let xhr;
    let xhrInit;
    // init local2
    local2 = opt.local2 || local.utility2 || {};
    // init function
    ajaxProgressUpdate = local2.ajaxProgressUpdate || function () {
        return;
    };
    bufferValidateAndCoerce = local2.bufferValidateAndCoerce || function (
        buf,
        mode
    ) {
    /*
     * this function will validate and coerce/convert
     * &lt;buf&gt; to Buffer/Uint8Array, or String if &lt;mode&gt; = &quot;string&quot;
     */
        // coerce ArrayBuffer to Buffer
        if (Object.prototype.toString.call(buf) === &quot;[object ArrayBuffer]&quot;) {
            buf = new Uint8Array(buf);
        }
        // convert Buffer to utf8
        if (mode === &quot;string&quot; &amp;&amp; typeof buf !== &quot;string&quot;) {
            buf = String(buf);
        }
        return buf;
    };
    onEvent = function (evt) {
    /*
     * this function will handle events
     */
        if (Object.prototype.toString.call(evt) === &quot;[object Error]&quot;) {
            xhr.err = xhr.err || evt;
            xhr.onEvent({
                type: &quot;error&quot;
            });
            return;
        }
        // init statusCode
        xhr.statusCode = (xhr.statusCode || xhr.status) | 0;
        switch (evt.type) {
        case &quot;abort&quot;:
        case &quot;error&quot;:
        case &quot;load&quot;:
            if (isDone) {
                return;
            }
            isDone = true;
            // decrement cnt
            ajaxProgressUpdate.cnt = Math.max(
                ajaxProgressUpdate.cnt - 1,
                0
            );
            ajaxProgressUpdate();
            // handle abort or err event
            switch (!xhr.err &amp;&amp; evt.type) {
            case &quot;abort&quot;:
            case &quot;error&quot;:
                xhr.err = new Error(&quot;ajax - event &quot; + evt.type);
                break;
            case &quot;load&quot;:
                if (xhr.statusCode &gt;= 400) {
                    xhr.err = new Error(
                        &quot;ajax - statusCode &quot; + xhr.statusCode
                    );
                }
                break;
            }
            // debug statusCode / method / url
            if (xhr.err) {
                xhr.statusCode = xhr.statusCode || 500;
                xhr.err.statusCode = xhr.statusCode;
                tmp = (
                    (
                        local.isBrowser
                        ? &quot;browser&quot;
                        : &quot;node&quot;
                    )
                    + &quot; - &quot; + xhr.statusCode + &quot; &quot; + xhr.method + &quot; &quot; + xhr.url
                    + &quot;\n&quot;
                );
                xhr.err.message = tmp + xhr.err.message;
                xhr.err.stack = tmp + xhr.err.stack;
            }
            // update resHeaders
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
            if (xhr.getAllResponseHeaders) {
                xhr.getAllResponseHeaders().replace((
                    /(.*?):\u0020*(.*?)\r\n/g
                ), function (ignore, key, val) {
                    xhr.resHeaders[key.toLowerCase()] = val;
                });
            }
            // debug ajaxResponse
            xhr.resContentLength = (...</pre></li>
    <li>example use<pre class="apidocCodePre">...
/* validateLineSortedReset */
local.ajax = function (opt, onError) {
/*
* this function will send an ajax-req
* with given &lt;opt&gt;.url and callback &lt;onError&gt;
* with err and timeout handling
* example use:
   local.<span class="apidocCodeKeywordSpan">ajax</span>({
       data: &quot;hello world&quot;,
       header: {&quot;x-header-hello&quot;: &quot;world&quot;},
       method: &quot;POST&quot;,
       url: &quot;/index.html&quot;
   }, function (err, xhr) {
       console.log(xhr.statusCode);
       console.log(xhr.responseText);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.assert" id="apidoc.elem.utility2.github_crud.assert">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.assertOrThrow" id="apidoc.elem.utility2.github_crud.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;msg&gt; if &lt;passed&gt; is falsy
 */
</span>    if (passed) {
        return;
    }
    throw (
        (
            msg
            &amp;&amp; typeof msg.message === &quot;string&quot;
            &amp;&amp; typeof msg.stack === &quot;string&quot;
        )
        // if msg is err, then leave as is
        ? msg
        : new Error(
            typeof msg === &quot;string&quot;
            // if msg is a string, then leave as is
            ? msg
            // else JSON.stringify msg
            : JSON.stringify(msg, undefined, 4)
        )
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(str).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliRun" id="apidoc.elem.utility2.github_crud.cliRun">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let str;
        let strDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            str = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(str);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(str).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        str = &quot;&quot;;
        str += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        str += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file
                + &quot;  &quo...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.coalesce" id="apidoc.elem.utility2.github_crud.coalesce">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(str);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.events" id="apidoc.elem.utility2.github_crud.events">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>events
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.fsReadFileOrDefaultSync" id="apidoc.elem.utility2.github_crud.fsReadFileOrDefaultSync">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsReadFileOrDefaultSync
        <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrDefaultSync = function (pathname, type, dflt) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync-read &lt;pathname&gt; with given &lt;type&gt; and &lt;dflt&gt;
 */
</span>    let fs;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;ignore&quot;, &quot;ignore&quot;, 2
        ]
    });
}
if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
    // init assets index.html
    local.assetsDict[&quot;/index.html&quot;] = (
        local.<span class="apidocCodeKeywordSpan">fsReadFileOrDefaultSync</span>(&quot;index.html&quot;, &quot;utf8&quot;, &quot
;&quot;)
        || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
    );
    local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
    local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
        __filename,
        &quot;utf8&quot;
    ).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.fsRmrfSync" id="apidoc.elem.utility2.github_crud.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(pathname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (pathname) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;pathname&gt;
 */
</span>    let child_process;
    // do nothing if module does not exist
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    if (process.platform !== &quot;win32&quot;) {
        child_process.spawnSync(&quot;rm&quot;, [
            &quot;-rf&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        });
        return;
    }
    try {
        child_process.spawnSync(&quot;rd&quot;, [
            &quot;/s&quot;, &quot;/q&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, &quot;ignore&quot;
            ]
        });
    } catch (ignore) {}
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.github_crud.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(pathname, data, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (pathname, data, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;pathname&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    let success;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
        success = true;
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require(&quot;path&quot;).dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    || local.env.npm_config_mode_test_case
    !== &quot;testCase_buildApidoc_default&quot;
) {
    onError(undefined, opt);
    return;
}
// save apidoc.html
local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
    &quot;tmp/build/apidoc.html&quot;,
    local.apidocCreate(local.objectAssignDefault(opt, {
        blacklistDict: local,
        require: require2
    })),
    &quot;wrote file apidoc - {{pathname}}&quot;
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudAjax" id="apidoc.elem.utility2.github_crud.githubCrudAjax">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudAjax
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudAjax = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will make a low-level content-req to github
 * https://developer.github.com/v3/repos/contents/
 */
</span>    // init opt
    opt = {
        content: opt.content,
        headers: Object.assign({
            // github oauth authentication
            Authorization: &quot;token &quot; + (
                typeof process === &quot;object&quot;
                &amp;&amp; process &amp;&amp; process.env.GITHUB_TOKEN
            ),
            // bug-workaround
            // https://developer.github.com/v3/#user-agent-required
            &quot;User-Agent&quot;: &quot;undefined&quot;
        }, opt.headers),
        httpReq: opt.httpReq,
        message: opt.message,
        method: opt.method || &quot;GET&quot;,
        responseJson: {},
        sha: opt.sha,
        url: opt.url
    };
    // parse https://github.com/:owner/:repo/blob/:branch/:path
    opt.url = opt.url.replace((
        /^https:\/\/github.com\/([^\/]+?\/[^\/]+?)\/blob\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/contents/$3?branch=$2&quot;);
    // parse https://github.com/:owner/:repo/tree/:branch/:path
    opt.url = opt.url.replace((
        /^https:\/\/github.com\/([^\/]+?\/[^\/]+?)\/tree\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/contents/$3?branch=$2&quot;);
    // parse https://raw.githubusercontent.com/:owner/:repo/:branch/:path
    opt.url = opt.url.replace((
        /^https:\/\/raw.githubusercontent.com\/([^\/]+?\/[^\/]+?)\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/contents/$3?branch=$2&quot;);
    // parse https://:owner.github.io/:repo/:path
    opt.url = opt.url.replace((
        /^https:\/\/([^.]+?)\.github\.io\/([^\/]+?)\/(.+)/
    ), &quot;https://api.github.com/repos/$1/$2/contents/$3?branch=gh-pages&quot;);
    // parse :owner/:repo
    opt.url = opt.url.replace((
        /^([^\/]+?\/[^\/]+?)$/
    ), &quot;https://github.com/$1&quot;);
    opt.url = opt.url.replace((
        /\?branch=(.*)/
    ), function (match0, match1) {
        opt.branch = match1;
        if (opt.method === &quot;GET&quot;) {
            match0 = match0.replace(&quot;branch&quot;, &quot;ref&quot;);
        }
        return match0;
    });
    if ((
        /^https:\/\/github\.com\/[^\/]+?\/[^\/]+?$/
    ).test(opt.url)) {
        opt.data = JSON.stringify({
            name: opt.url.split(&quot;/&quot;)[4]
        });
        switch (opt.method) {
        case &quot;DELETE&quot;:
            opt.url = (
                &quot;https://api.github.com/repos/&quot;
                + opt.url.split(&quot;/&quot;).slice(3).join(&quot;/&quot;)
            );
            break;
        case &quot;POST_ORG&quot;:
            opt.url = (
                &quot;https://api.github.com/orgs/&quot;
                + opt.url.split(&quot;/&quot;)[3] + &quot;/repos&quot;
            );
            break;
        case &quot;POST_USER&quot;:
            opt.url = &quot;https://api.github.com/user/repos&quot;;
            break;
        }
        opt.method = opt.method.split(&quot;_&quot;)[0];
    } else {
        if (opt.url.indexOf(&quot;https://api.github.com/repos/&quot;) !== 0) {
            console.error(&quot;githubCrud - invalid url &quot; + opt.url);
            onError(new Error(&quot;invalid url &quot; + opt.url));
            return;
        }
        if (opt.method !== &quot;GET&quot;) {
            opt.message = (
                opt.message
                || &quot;[ci skip] &quot; + opt.method + &quot; file &quot;
                + opt.url.replace((
                    /\?.*/
                ), &quot;&quot;)
            );
            opt.url += &quot;&amp;message=&quot; + encodeURIComponent(opt.message);
            if (opt.sha) {
                opt.url += &quot;&amp;sha=&quot; + opt.sha;
            }
            opt.data = JSON.stringify({
                branch: opt.branch,
                content: Buffer.from(opt.content || &quot;&quot;).toString(&quot;base64&quot;),
                message: opt.message,...</pre></li>
    <li>example use<pre class="apidocCodePre">...
    message: opt.message,
    url: opt.url
};
local.gotoNext(opt, function (err, data) {
    switch (opt.gotoState) {
    case 1:
        // get sha
        local.<span class="apidocCodeKeywordSpan">githubCrudAjax</span>({
            httpReq: opt.httpReq,
            url: opt.url
        }, opt.gotoNext);
        break;
    case 2:
        // delete file with sha
        if (!err &amp;&amp; data.sha) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentDelete" id="apidoc.elem.utility2.github_crud.githubCrudContentDelete">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentDelete
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentDelete = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will delete github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#delete-a-file
 */
</span>    opt = {
        httpReq: opt.httpReq,
        message: opt.message,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get sha
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            // delete file with sha
            if (!err &amp;&amp; data.sha) {
                local.githubCrudAjax({
                    httpReq: opt.httpReq,
                    message: opt.message,
                    method: &quot;DELETE&quot;,
                    sha: data.sha,
                    url: opt.url
                }, opt.gotoNext);
                return;
            }
            // delete tree
            local.onParallelList({
                list: data
            }, function (opt2, onParallel) {
                onParallel.cnt += 1;
                // recurse
                local.githubCrudContentDelete({
                    httpReq: opt.httpReq,
                    message: opt.message,
                    url: opt2.elem.url
                }, onParallel);
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }
    // delete tree
    local.onParallelList({
        list: data
    }, function (opt2, onParallel) {
        onParallel.cnt += 1;
        // recurse
        local.<span class="apidocCodeKeywordSpan">githubCrudContentDelete</span>({
            httpReq: opt.httpReq,
            message: opt.message,
            url: opt2.elem.url
        }, onParallel);
    }, opt.gotoNext);
    break;
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentGet" id="apidoc.elem.utility2.github_crud.githubCrudContentGet">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentGet
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentGet = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will get github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#get-contents
 */
</span>    opt = {
        httpReq: opt.httpReq,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            opt.gotoNext(null, Buffer.from(data.content || &quot;&quot;, &quot;base64&quot;));
            break;
        default:
            onError(err, !err &amp;&amp; data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.cliDict.get = function () {
/*
* &lt;fileRemote&gt;
* will get from github &lt;fileRemote&gt;
*/
   local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudContentGet</span>({
       url: process.argv[3]
   }, function (err, data) {
       try {
           process.stdout.write(data);
       } catch (ignore) {}
       process.exit(Boolean(err));
   });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentPut" id="apidoc.elem.utility2.github_crud.githubCrudContentPut">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPut
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentPut = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will put &lt;opt&gt;.content to github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#create-a-file
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    opt = {
        content: opt.content,
        httpReq: opt.httpReq,
        message: opt.message,
        modeErrorIgnore: true,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get sha
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            // put file with sha
            local.githubCrudAjax({
                content: opt.content,
                httpReq: opt.httpReq,
                message: opt.message,
                method: &quot;PUT&quot;,
                sha: data.sha,
                url: opt.url
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        });
        return;
    }
    // get file
    local.fs.readFile(opt.file, opt.gotoNext);
    break;
case 2:
    local.<span class="apidocCodeKeywordSpan">githubCrudContentPut</span>({
        content: data,
        httpReq: opt.httpReq,
        message: opt.message,
        // resolve file in url
        url: (
            (
                /\/$/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentPutFile" id="apidoc.elem.utility2.github_crud.githubCrudContentPutFile">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentPutFile
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentPutFile = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will put opt.file to github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    opt = {
        file: opt.file,
        httpReq: opt.httpReq,
        message: opt.message,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get file from url
            if ((
                /^(?:http|https):\/\//
            ).test(opt.file)) {
                local.ajax({
                    httpReq: opt.httpReq,
                    url: opt.file
                }, function (err, res) {
                    opt.gotoNext(err, res &amp;&amp; res.data);
                });
                return;
            }
            // get file
            local.fs.readFile(opt.file, opt.gotoNext);
            break;
        case 2:
            local.githubCrudContentPut({
                content: data,
                httpReq: opt.httpReq,
                message: opt.message,
                // resolve file in url
                url: (
                    (
                        /\/$/
                    ).test(opt.url)
                    ? opt.url + local.path.basename(opt.file)
                    : opt.url
                )
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.cliDict.put = function () {
/*
 * &lt;fileRemote&gt; &lt;fileLocal&gt; &lt;commitMessage&gt;
 * will put on github &lt;fileRemote&gt; to &lt;fileLocal&gt;
 */
    local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudContentPutFile</span>({
        message: process.argv[5],
        url: process.argv[3],
        file: process.argv[4]
    }, function (err) {
        process.exit(Boolean(err));
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentTouch" id="apidoc.elem.utility2.github_crud.githubCrudContentTouch">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouch
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentTouch = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will touch github-file &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    opt = {
        httpReq: opt.httpReq,
        message: opt.message,
        modeErrorIgnore: true,
        url: opt.url
    };
    local.gotoNext(opt, function (err, data) {
        switch (opt.gotoState) {
        case 1:
            // get sha
            local.githubCrudAjax({
                httpReq: opt.httpReq,
                url: opt.url
            }, opt.gotoNext);
            break;
        case 2:
            // put file with sha
            local.githubCrudAjax({
                content: Buffer.from(data.content || &quot;&quot;, &quot;base64&quot;),
                httpReq: opt.httpReq,
                message: opt.message,
                method: &quot;PUT&quot;,
                sha: data.sha,
                url: opt.url
            }, opt.gotoNext);
            break;
        default:
            onError(err, data);
        }
    });
    opt.gotoState = 0;
    opt.gotoNext();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
 * this function will touch github-files &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
    local.onParallelList({
        list: opt.urlList
    }, function (opt2, onParallel) {
        onParallel.cnt += 1;
        local.<span class="apidocCodeKeywordSpan">githubCrudContentTouch</span>({
            httpReq: opt.httpReq,
            message: opt.message,
            url: opt2.elem
        }, onParallel);
    }, onError);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudContentTouchList" id="apidoc.elem.utility2.github_crud.githubCrudContentTouchList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudContentTouchList
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudContentTouchList = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will touch github-files &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/contents/#update-a-file
 */
</span>    local.onParallelList({
        list: opt.urlList
    }, function (opt2, onParallel) {
        onParallel.cnt += 1;
        local.githubCrudContentTouch({
            httpReq: opt.httpReq,
            message: opt.message,
            url: opt2.elem
        }, onParallel);
    }, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.cliDict.touch = function () {
/*
* &lt;fileRemoteList&gt; &lt;commitMessage&gt;
* will touch on github in parallel, comma-separated &lt;fileRemoteList&gt;
*/
   local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudContentTouchList</span>({
       message: process.argv[4],
       urlList: process.argv[3].split(
           /[,\s]/g
       ).filter(local.identity)
   }, function (err) {
       process.exit(Boolean(err));
   });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreate" id="apidoc.elem.utility2.github_crud.githubCrudRepoCreate">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreate
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoCreate = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will create github-repo &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/#create
 */
</span>    local.githubCrudAjax({
        httpReq: opt.httpReq,
        method: &quot;POST_ORG&quot;,
        url: opt.url
    }, function (err, data) {
        if (!(err &amp;&amp; err.statusCode === 404)) {
            onError(err, data);
            return;
        }
        local.githubCrudAjax({
            httpReq: opt.httpReq,
            method: &quot;POST_USER&quot;,
            url: opt.url
        }, onError);
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
 * this function will create github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#create
 */
    local.onParallelList({
        list: opt.urlList
    }, function (opt2, onParallel) {
        onParallel.cnt += 1;
        local.<span class="apidocCodeKeywordSpan">githubCrudRepoCreate</span>({
            httpReq: opt.httpReq,
            url: opt2.elem
        }, onParallel);
    }, onError);
};

local.githubCrudRepoDelete = function (opt, onError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoCreateList" id="apidoc.elem.utility2.github_crud.githubCrudRepoCreateList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoCreateList
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoCreateList = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will create github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#create
 */
</span>    local.onParallelList({
        list: opt.urlList
    }, function (opt2, onParallel) {
        onParallel.cnt += 1;
        local.githubCrudRepoCreate({
            httpReq: opt.httpReq,
            url: opt2.elem
        }, onParallel);
    }, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.cliDict.repo_create = function () {
/*
 * &lt;repoList&gt;
 * will create on github in parallel, comma-separated &lt;repoList&gt;
 */
    local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudRepoCreateList</span>({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoDelete" id="apidoc.elem.utility2.github_crud.githubCrudRepoDelete">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDelete
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoDelete = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will delete github-repo &lt;opt&gt;.url
 * https://developer.github.com/v3/repos/#delete-a-repository
 */
</span>    local.githubCrudAjax({
        httpReq: opt.httpReq,
        method: &quot;DELETE&quot;,
        url: opt.url
    }, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
 * this function will delete github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#delete-a-repository
 */
    local.onParallelList({
        list: opt.urlList
    }, function (opt2, onParallel) {
        onParallel.cnt += 1;
        local.<span class="apidocCodeKeywordSpan">githubCrudRepoDelete</span>({
            httpReq: opt.httpReq,
            url: opt2.elem
        }, onParallel);
    }, onError);
};
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.githubCrudRepoDeleteList" id="apidoc.elem.utility2.github_crud.githubCrudRepoDeleteList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>githubCrudRepoDeleteList
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">githubCrudRepoDeleteList = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will delete github-repos &lt;opt&gt;.urlList in parallel
 * https://developer.github.com/v3/repos/#delete-a-repository
 */
</span>    local.onParallelList({
        list: opt.urlList
    }, function (opt2, onParallel) {
        onParallel.cnt += 1;
        local.githubCrudRepoDelete({
            httpReq: opt.httpReq,
            url: opt2.elem
        }, onParallel);
    }, onError);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.cliDict.repo_delete = function () {
/*
 * &lt;repoList&gt;
 * will delete from github in parallel, comma-separated &lt;repoList&gt;
 */
    local.github_crud.<span class="apidocCodeKeywordSpan">githubCrudRepoDeleteList</span>({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.gotoNext" id="apidoc.elem.utility2.github_crud.gotoNext">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>gotoNext
        <span class="apidocSignatureSpan">(opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gotoNext = function (opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
 * and append current-stack to any err
 */
</span>    opt.gotoNext = local.onErrorWithStack(function (err, data, meta) {
        try {
            opt.gotoState += (
                (err &amp;&amp; !opt.modeErrorIgnore)
                ? 1000
                : 1
            );
            if (opt.modeDebug) {
                console.error(&quot;gotoNext - &quot; + JSON.stringify({
                    gotoState: opt.gotoState,
                    errorMessage: err &amp;&amp; err.message
                }));
                if (err &amp;&amp; err.stack) {
                    console.error(err.stack);
                }
            }
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.gotoNext(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            onError(err, data, meta);
        } catch (errCaught) {
            // throw errCaught to break infinite recursion-loop
            if (opt.errCaught) {
                local.assertOrThrow(undefined, opt.errCaught);
            }
            opt.errCaught = errCaught;
            opt.<span class="apidocCodeKeywordSpan">gotoNext</span>(errCaught, data, meta);
        }
    });
    opt.gotoNextData = opt.gotoNext.bind(undefined, undefined);
    return opt;
};

local.onErrorDefault = function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.identity" id="apidoc.elem.utility2.github_crud.identity">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.nop" id="apidoc.elem.utility2.github_crud.nop">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - function
(function () {
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(require);
globalThis.__coverageInclude__ = local.coalesce(
globalThis.__coverageInclude__,
{}
);
// mock builtins
process = local.process || {
cwd: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.objectAssignDefault" id="apidoc.elem.utility2.github_crud.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (tgt = {}, src = {}, depth = 0) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;tgt&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;src&gt;
 */
</span>    let recurse;
    recurse = function (tgt, src, depth) {
        Object.entries(src).forEach(function ([
            key, bb
        ]) {
            let aa;
            aa = tgt[key];
            if (aa === undefined || aa === null || aa === &quot;&quot;) {
                tgt[key] = bb;
                return;
            }
            if (
                depth !== 0
                &amp;&amp; typeof aa === &quot;object&quot; &amp;&amp; aa &amp;&amp; !Array.isArray(aa)
                &amp;&amp; typeof bb === &quot;object&quot; &amp;&amp; bb &amp;&amp; !Array.isArray(bb)
            ) {
                recurse(aa, bb, depth - 1);
            }
        });
    };
    recurse(tgt, src, depth | 0);
    return tgt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return str;
};
// init opt
opt.dir = local.moduleDirname(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.parse(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onErrorDefault" id="apidoc.elem.utility2.github_crud.onErrorDefault">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorDefault
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorDefault = function (err) {
<span class="apidocCodeCommentSpan">/*
 * this function will if &lt;err&gt; exists, then print it to stderr
 */
</span>    if (err) {
        console.error(err);
    }
    return err;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.onParallel(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.<span class="apidocCodeKeywordSpan">onErrorDefault</span>(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.cnt -= 1;
            onEach(data, onParallel);
        }, 1000);
        return true;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onErrorWithStack" id="apidoc.elem.utility2.github_crud.onErrorWithStack">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onErrorWithStack
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorWithStack = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap &lt;onError&gt; with wrapper preserving current-stack
 */
</span>    let onError2;
    let stack;
    stack = new Error().stack;
    onError2 = function (err, data, meta) {
        // append current-stack to err.stack
        if (
            err
            &amp;&amp; typeof err.stack === &quot;string&quot;
            &amp;&amp; err !== local.errorDefault
        ) {
            err.stack += &quot;\n&quot; + stack;
        }
        onError(err, data, meta);
    };
    // debug onError
    onError2.toString = function () {
        return String(onError);
    };
    return onError2;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.<span class="apidocCodeKeywordSpan">onErrorWithStack</span>(function (err, data, meta) {
       try {
           opt.gotoState += (
               (err &amp;&amp; !opt.modeErrorIgnore)
               ? 1000
               : 1
           );
           if (opt.modeDebug) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onParallel" id="apidoc.elem.utility2.github_crud.onParallel">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallel
        <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallel = function (onError, onEach, onRetry) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a function that will
 * 1. run async tasks in parallel
 * 2. if cnt === 0 or err occurred, then call onError(err)
 */
</span>    let onParallel;
    onError = local.onErrorWithStack(onError);
    onEach = onEach || local.nop;
    onRetry = onRetry || local.nop;
    onParallel = function (err, data) {
        if (onRetry(err, data)) {
            return;
        }
        // decrement cnt
        onParallel.cnt -= 1;
        // validate cnt
        if (!(onParallel.cnt &gt;= 0 || err || onParallel.err)) {
            err = new Error(
                &quot;invalid onParallel.cnt = &quot; + onParallel.cnt
            );
        // ensure onError is run only once
        } else if (onParallel.cnt &lt; 0) {
            return;
        }
        // handle err
        if (err) {
            onParallel.err = err;
            // ensure cnt &lt;= 0
            onParallel.cnt = -Math.abs(onParallel.cnt);
        }
        // call onError when isDone
        if (onParallel.cnt &lt;= 0) {
            onError(err, data);
            return;
        }
        onEach();
    };
    // init cnt
    onParallel.cnt = 0;
    // return callback
    return onParallel;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            elem: opt.list[onParallel.ii],
            ii: onParallel.ii,
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.<span class="apidocCodeKeywordSpan">onParallel</span>(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.onErrorDefault(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.cnt -= 1;
            onEach(data, onParallel);
        }, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.onParallelList" id="apidoc.elem.utility2.github_crud.onParallelList">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>onParallelList
        <span class="apidocSignatureSpan">(opt, onEach, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallelList = function (opt, onEach, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will
 * 1. async-run onEach in parallel,
 *    with given &lt;opt&gt;.rateLimit and &lt;opt&gt;.retryLimit
 * 2. call &lt;onError&gt; when onParallel.ii + 1 === &lt;opt&gt;.list.length
 */
</span>    let isListEnd;
    let onEach2;
    let onParallel;
    opt.list = opt.list || [];
    onEach2 = function () {
        while (true) {
            if (!(onParallel.ii + 1 &lt; opt.list.length)) {
                isListEnd = true;
                return;
            }
            if (!(onParallel.cnt &lt; opt.rateLimit + 1)) {
                return;
            }
            onParallel.ii += 1;
            onEach({
                elem: opt.list[onParallel.ii],
                ii: onParallel.ii,
                list: opt.list,
                retry: 0
            }, onParallel);
        }
    };
    onParallel = local.onParallel(onError, onEach2, function (err, data) {
        if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
            local.onErrorDefault(err);
            data.retry += 1;
            setTimeout(function () {
                onParallel.cnt -= 1;
                onEach(data, onParallel);
            }, 1000);
            return true;
        }
        // restart if opt.list has grown
        if (isListEnd &amp;&amp; (onParallel.ii + 1 &lt; opt.list.length)) {
            isListEnd = undefined;
            onEach2();
        }
    });
    onParallel.ii = -1;
    opt.rateLimit = Number(opt.rateLimit) || 6;
    opt.rateLimit = Math.max(opt.rateLimit, 1);
    opt.retryLimit = Number(opt.retryLimit) || 2;
    onParallel.cnt += 1;
    onEach2();
    onParallel();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        method: &quot;DELETE&quot;,
        sha: data.sha,
        url: opt.url
    }, opt.gotoNext);
    return;
}
// delete tree
local.<span class="apidocCodeKeywordSpan">onParallelList</span>({
    list: data
}, function (opt2, onParallel) {
    onParallel.cnt += 1;
    // recurse
    local.githubCrudContentDelete({
        httpReq: opt.httpReq,
        message: opt.message,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.stream" id="apidoc.elem.utility2.github_crud.stream">
        function <span class="apidocSignatureSpan">utility2.github_crud.</span>stream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream(opts) {
  EE.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.github_crud.cliDict" id="apidoc.module.utility2.github_crud.cliDict">module utility2.github_crud.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.delete" id="apidoc.elem.utility2.github_crud.cliDict.delete">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>delete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
 * will delete from github &lt;fileRemote|dirRemote&gt;
 */
</span>    local.github_crud.githubCrudContentDelete({
        message: process.argv[4],
        url: process.argv[3]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        tmp = stringify(obj);
        return (
            typeof tmp === &quot;string&quot;
            ? tmp
            : &quot;null&quot;
        );
    }).join(&quot;,&quot;) + &quot;]&quot;;
    circularSet.<span class="apidocCodeKeywordSpan">delete</span>(obj);
    return tmp;
}
// if obj is not an array,
// then recurse its items with object-keys sorted
tmp = &quot;{&quot; + Object.keys(obj).sort().map(function (key) {
    // recurse
    tmp = stringify(obj[key]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.get" id="apidoc.elem.utility2.github_crud.cliDict.get">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt;
 * will get from github &lt;fileRemote&gt;
 */
</span>    local.github_crud.githubCrudContentGet({
        url: process.argv[3]
    }, function (err, data) {
        try {
            process.stdout.write(data);
        } catch (ignore) {}
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
                                this._skipCruft();
                                break;
                            case Tokens.SUPPORTS_SYM:
                                this._supports();
                                this._skipCruft();
                                break;
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.<span class="apidocCodeKeywordSpan">get</span>();
                                if (!this.options.strict) {

//fire error event
this.fire({
    type:       &quot;error&quot;,
    error:      null,
    message:    &quot;Unknown @ rule: &quot; + tokenStream.LT(0).value + &quot;.&quot;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.put" id="apidoc.elem.utility2.github_crud.cliDict.put">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>put
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">put = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemote&gt; &lt;fileLocal&gt; &lt;commitMessage&gt;
 * will put on github &lt;fileRemote&gt; to &lt;fileLocal&gt;
 */
</span>    local.github_crud.githubCrudContentPutFile({
        message: process.argv[5],
        url: process.argv[3],
        file: process.argv[4]
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.repo_create" id="apidoc.elem.utility2.github_crud.cliDict.repo_create">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repo_create = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will create on github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoCreateList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.repo_delete" id="apidoc.elem.utility2.github_crud.cliDict.repo_delete">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>repo_delete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">repo_delete = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;repoList&gt;
 * will delete from github in parallel, comma-separated &lt;repoList&gt;
 */
</span>    local.github_crud.githubCrudRepoDeleteList({
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.github_crud.cliDict.touch" id="apidoc.elem.utility2.github_crud.cliDict.touch">
        function <span class="apidocSignatureSpan">utility2.github_crud.cliDict.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;fileRemoteList&gt; &lt;commitMessage&gt;
 * will touch on github in parallel, comma-separated &lt;fileRemoteList&gt;
 */
</span>    local.github_crud.githubCrudContentTouchList({
        message: process.argv[4],
        urlList: process.argv[3].split(
            /[,\s]/g
        ).filter(local.identity)
    }, function (err) {
        process.exit(Boolean(err));
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul" id="apidoc.module.utility2.istanbul">module utility2.istanbul</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter" id="apidoc.elem.utility2.istanbul.Instrumenter">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.__istanbul_module" id="apidoc.elem.utility2.istanbul.__istanbul_module">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>__istanbul_module
        <span class="apidocSignatureSpan">(id = &apos;&apos;, parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Module(id = &apos;&apos;, parent) {
  this.id = id;
  this.path = path.dirname(id);
  this.exports = {};
  this.parent = parent;
  updateChildren(parent, this, false);
  this.filename = null;
  this.loaded = false;
  this.children = [];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.assert" id="apidoc.elem.utility2.istanbul.assert">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.assertOrThrow" id="apidoc.elem.utility2.istanbul.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;msg&gt; if &lt;passed&gt; is falsy
 */
</span>    if (passed) {
        return;
    }
    throw (
        (
            msg
            &amp;&amp; typeof msg.message === &quot;string&quot;
            &amp;&amp; typeof msg.stack === &quot;string&quot;
        )
        // if msg is err, then leave as is
        ? msg
        : new Error(
            typeof msg === &quot;string&quot;
            // if msg is a string, then leave as is
            ? msg
            // else JSON.stringify msg
            : JSON.stringify(msg, undefined, 4)
        )
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(str).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliRun" id="apidoc.elem.utility2.istanbul.cliRun">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let str;
        let strDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            str = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(str);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(str).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        str = &quot;&quot;;
        str += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        str += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file
                + &quot;  &quo...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coalesce" id="apidoc.elem.utility2.istanbul.coalesce">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(str);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageMerge" id="apidoc.elem.utility2.istanbul.coverageMerge">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageMerge
        <span class="apidocSignatureSpan">(coverage1 = {}, coverage2 = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverageMerge = function (coverage1 = {}, coverage2 = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will inplace-merge &lt;coverage2&gt; into &lt;coverage1&gt;
 */
</span>    let dict1;
    let dict2;
    Object.keys(coverage2).forEach(function (file) {
        // if coverage1[file] is undefined, then override it
        if (!coverage1[file]) {
            coverage1[file] = coverage2[file];
            return;
        }
        // merge coverage2 into coverage1
        [
            &quot;b&quot;, &quot;f&quot;, &quot;s&quot;
        ].forEach(function (key) {
            dict1 = coverage1[file][key];
            dict2 = coverage2[file][key];
            switch (key) {
            // increment coverage for branch lines
            case &quot;b&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict2[key].forEach(function (cnt, ii) {
                        dict1[key][ii] += cnt;
                    });
                });
                break;
            // increment coverage for function and statement lines
            case &quot;f&quot;:
            case &quot;s&quot;:
                Object.keys(dict2).forEach(function (key) {
                    dict1[key] += dict2[key];
                });
                break;
            }
        });
    });
    return coverage1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.coverageReportCreate" id="apidoc.elem.utility2.istanbul.coverageReportCreate">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>coverageReportCreate
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverageReportCreate = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will
    // 1. merge previous &lt;dirCoverage&gt;/coverage.json into &lt;opt&gt;.coverage
    // 2. convert &lt;opt&gt;.coverage to &lt;summaryDict&gt;
    // 3. convert &lt;summaryDict&gt; to &lt;nodeRoot&gt;
    // 4. convert &lt;nodeRoot&gt; to text-report &lt;dirCoverage&gt;/coverage.txt
    // 5. convert &lt;nodeRoot&gt; to html-report &lt;dirCoverage&gt;/\*
    // 6. return coverage-report in html-format as single document
 */
</span>    let coverageInclude;
    let dirCoverage;
    let filePrefix;
    let filesUnderRoot;
    let htmlAll;
    let nodeChildAdd;
    let nodeCreate;
    let nodeDict;
    let nodeNormalize;
    let nodeRoot;
    let summaryDict;
    let tmp;
    let tmpChildren;
    if (!(opt &amp;&amp; opt.coverage)) {
        return &quot;&quot;;
    }
    // init function
    nodeChildAdd = function (node, child) {
    /*
     * this function will add &lt;child&gt; to &lt;node&gt;
     */
        node.children.push(child);
        child.parent = node;
    };
    nodeCreate = function (pathname) {
    /*
     * this function will create a tree-node
     */
        return {
            children: [],
            pathname,
            metrics: {
                branches: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                functions: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                lines: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                },
                statements: {
                    total: 0,
                    covered: 0,
                    skipped: 0,
                    pct: &quot;Unknown&quot;
                }
            },
            name: pathname
        };
    };
    nodeNormalize = function (node, level, filePrefix, parent) {
    /*
     * this function will recursively normalize &lt;node&gt; and its children
     */
        let metric;
        // init name
        if (node.name.indexOf(filePrefix) === 0) {
            node.name = node.name.slice(filePrefix.length);
        }
        if (node.name[0] === path.sep) {
            node.name = node.name.slice(1);
        }
        // init relativeName
        node.relativeName = (
            parent
            ? (
                parent.name !== &quot;__root__/&quot;
                ? node.name.slice(parent.name.length)
                : node.name
            )
            : node.name.slice(filePrefix.length)
        );
        // init nameOrAllFiles
        node.nameOrAllFiles = node.name || &quot;All files&quot;;
        // init relativeNameOrAllFiles
        node.relativeNameOrAllFiles = node.relativeName || &quot;All files&quot;;
        // init href
        node.href = node.relativeName.split(path.sep).join(&quot;/&quot;) + (
            node.isFile
            ? &quot;.html&quot;
            : &quot;index.html&quot;
        );
        // recurse
        node.children.forEach(function (child) {
            nodeNormalize(child, level + 1, filePrefix, node);
        });
        // sort children by name
        node.children.sort(function (aa, bb) {
            return (
                aa.name &gt; bb.name
                ? 1
                : -1
            );
        });
        // init metrics
        if (!node.isFile) {
            node.children.forEach(function (child) {
                [
                    &quot;lines&quot;, &quot;statements&quot;, &quot;branches&quot;, &quot;functions&quot;
                ].forEach(function (key) {
                    metric = node.metrics[key];
                    metric.total += child.metrics[key].total;
                    metric.covered += child.metrics[key].covered;
                    metric.skipped += child.metrics[key].skipped;...</pre></li>
    <li>example use<pre class="apidocCodePre">...
    break;\n\
}\n\
};\n\
// handle evt\n\
local.on(&quot;utility2.testRunEnd&quot;, function () {\n\
document.querySelector(\n\
    &quot;#htmlCoverageReport1&quot;\n\
).innerHTML = local.istanbul.<span class="apidocCodeKeywordSpan">coverageReportCreate</span>({\n\
    coverage: globalThis.__coverage__\n\
});\n\
});\n\
local.on(&quot;utility2.testRunProgressUpdate&quot;, function (testReport) {\n\
document.querySelector(\n\
    &quot;#htmlTestReport2&quot;\n\
).innerHTML = local.testReportMerge(testReport, {});\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.events" id="apidoc.elem.utility2.istanbul.events">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>events
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.fsReadFileOrDefaultSync" id="apidoc.elem.utility2.istanbul.fsReadFileOrDefaultSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsReadFileOrDefaultSync
        <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrDefaultSync = function (pathname, type, dflt) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync-read &lt;pathname&gt; with given &lt;type&gt; and &lt;dflt&gt;
 */
</span>    let fs;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;ignore&quot;, &quot;ignore&quot;, 2
        ]
    });
}
if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
    // init assets index.html
    local.assetsDict[&quot;/index.html&quot;] = (
        local.<span class="apidocCodeKeywordSpan">fsReadFileOrDefaultSync</span>(&quot;index.html&quot;, &quot;utf8&quot;, &quot
;&quot;)
        || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
    );
    local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
    local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
        __filename,
        &quot;utf8&quot;
    ).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.fsRmrfSync" id="apidoc.elem.utility2.istanbul.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(pathname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (pathname) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;pathname&gt;
 */
</span>    let child_process;
    // do nothing if module does not exist
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    if (process.platform !== &quot;win32&quot;) {
        child_process.spawnSync(&quot;rm&quot;, [
            &quot;-rf&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        });
        return;
    }
    try {
        child_process.spawnSync(&quot;rd&quot;, [
            &quot;/s&quot;, &quot;/q&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, &quot;ignore&quot;
            ]
        });
    } catch (ignore) {}
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.istanbul.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(pathname, data, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (pathname, data, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;pathname&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    let success;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
        success = true;
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require(&quot;path&quot;).dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    || local.env.npm_config_mode_test_case
    !== &quot;testCase_buildApidoc_default&quot;
) {
    onError(undefined, opt);
    return;
}
// save apidoc.html
local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
    &quot;tmp/build/apidoc.html&quot;,
    local.apidocCreate(local.objectAssignDefault(opt, {
        blacklistDict: local,
        require: require2
    })),
    &quot;wrote file apidoc - {{pathname}}&quot;
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.identity" id="apidoc.elem.utility2.istanbul.identity">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.instrumentInPackage" id="apidoc.elem.utility2.istanbul.instrumentInPackage">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentInPackage
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentInPackage = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will instrument &lt;code&gt;
 * if macro /\* istanbul instrument in package $npm_package_nameLib *\/
 * exists in &lt;code&gt;
 */
</span>    return (
        (
            process.env.npm_config_mode_coverage
            &amp;&amp; code.indexOf(&quot;/* istanbul ignore all */\n&quot;) &lt; 0 &amp;&amp; (
                process.env.npm_config_mode_coverage === &quot;all&quot;
                || process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_package_nameLib + &quot; */\n&quot;
                ) &gt;= 0
                || code.indexOf(
                    &quot;/* istanbul instrument in package &quot;
                    + process.env.npm_config_mode_coverage + &quot; */\n&quot;
                ) &gt;= 0
            )
        )
        ? local.instrumentSync(code, file)
        : code
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.instrumentSync" id="apidoc.elem.utility2.istanbul.instrumentSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>instrumentSync
        <span class="apidocSignatureSpan">(code, file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentSync = function (code, file) {
<span class="apidocCodeCommentSpan">/*
 * this function will
    // 1. normalize &lt;file&gt;
    // 2. save &lt;code&gt; to __coverageInclude__[&lt;file&gt;] for future html-report
    // 3. return instrumented-code
 */
</span>    // 1. normalize &lt;file&gt;
    file = path.resolve(file);
    // 2. save &lt;code&gt; to __coverageInclude__[&lt;file&gt;] for future html-report
    globalThis.__coverageInclude__[file] = 1;
    // 3. return instrumented-code
    return new local.Instrumenter({
        embedSource: true,
        esModules: true,
        noAutoWrap: true
    }).instrumentSync(code, file).trimStart();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
try {\n\
    delete globalThis.__coverage__[&quot;/inputTextarea1.js&quot;];\n\
} catch (ignore) {}\n\
// try to cover and eval #inputTextarea1\n\
try {\n\
    document.querySelector(\n\
        &quot;#outputTextarea1&quot;\n\
    ).value = local.istanbul.<span class="apidocCodeKeywordSpan">instrumentSync</span>(\n\
        document.querySelector(&quot;#inputTextarea1&quot;).value,\n\
        &quot;/inputTextarea1.js&quot;\n\
    );\n\
    eval( // jslint ignore:line\n\
        document.querySelector(&quot;#outputTextarea1&quot;).value\n\
    );\n\
} catch (errCaught) {\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.nop" id="apidoc.elem.utility2.istanbul.nop">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - function
(function () {
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(require);
globalThis.__coverageInclude__ = local.coalesce(
globalThis.__coverageInclude__,
{}
);
// mock builtins
process = local.process || {
cwd: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.objectAssignDefault" id="apidoc.elem.utility2.istanbul.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (tgt = {}, src = {}, depth = 0) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;tgt&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;src&gt;
 */
</span>    let recurse;
    recurse = function (tgt, src, depth) {
        Object.entries(src).forEach(function ([
            key, bb
        ]) {
            let aa;
            aa = tgt[key];
            if (aa === undefined || aa === null || aa === &quot;&quot;) {
                tgt[key] = bb;
                return;
            }
            if (
                depth !== 0
                &amp;&amp; typeof aa === &quot;object&quot; &amp;&amp; aa &amp;&amp; !Array.isArray(aa)
                &amp;&amp; typeof bb === &quot;object&quot; &amp;&amp; bb &amp;&amp; !Array.isArray(bb)
            ) {
                recurse(aa, bb, depth - 1);
            }
        });
    };
    recurse(tgt, src, depth | 0);
    return tgt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return str;
};
// init opt
opt.dir = local.moduleDirname(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.parse(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require" id="apidoc.elem.utility2.istanbul.require">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}).slice(0, 256).map(readExample);
// init moduleMain
local.tryCatchOnError(function () {
    console.error(&quot;apidocCreate - requiring &quot; + opt.dir + &quot; ...&quot;);
    moduleMain = {};
    moduleMain = (
        opt.moduleDict[opt.env.npm_package_name]
        || opt.<span class="apidocCodeKeywordSpan">require</span>(opt.dir)
        || opt.require(
            opt.dir + &quot;/&quot;
            + (opt.packageJson.bin)[Object.keys(opt.packageJson.bin)[0]]
        ) || {}
    );
    opt.circularSet.add(moduleMain);
    console.error(&quot;apidocCreate - ... required &quot; + opt.dir);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.stream" id="apidoc.elem.utility2.istanbul.stream">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>stream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream(opts) {
  EE.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.templateRender" id="apidoc.elem.utility2.istanbul.templateRender">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>templateRender
        <span class="apidocSignatureSpan">(template, dict, opt, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateRender = function (template, dict, opt, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will render &lt;template&gt; with given &lt;dict&gt;
 */
</span>    let argList;
    let getVal;
    let match;
    let renderPartial;
    let rgx;
    let skip;
    let val;
    if (dict === null || dict === undefined) {
        dict = {};
    }
    opt = opt || {};
    getVal = function (key) {
        argList = key.split(&quot; &quot;);
        val = dict;
        if (argList[0] === &quot;#this/&quot;) {
            return val;
        }
        if (argList[0] === &quot;#ii/&quot;) {
            return ii;
        }
        // iteratively lookup nested val in dict
        argList[0].split(&quot;.&quot;).forEach(function (key) {
            val = val &amp;&amp; val[key];
        });
        return val;
    };
    renderPartial = function (match0, helper, key, partial) {
        switch (helper) {
        case &quot;each&quot;:
        case &quot;eachTrimEndComma&quot;:
            val = getVal(key);
            val = (
                Array.isArray(val)
                ? val.map(function (dict, ii) {
                    // recurse with partial
                    return local.templateRender(partial, dict, opt, ii);
                }).join(&quot;&quot;)
                : &quot;&quot;
            );
            // remove trailing-comma from last elem
            if (helper === &quot;eachTrimEndComma&quot;) {
                val = val.trimEnd().replace((
                    /,$/
                ), &quot;&quot;);
            }
            return val;
        case &quot;if&quot;:
            partial = partial.split(&quot;{{#unless &quot; + key + &quot;}}&quot;);
            partial = (
                getVal(key)
                ? partial[0]
                // handle &quot;unless&quot; case
                : partial.slice(1).join(&quot;{{#unless &quot; + key + &quot;}}&quot;)
            );
            // recurse with partial
            return local.templateRender(partial, dict, opt);
        case &quot;unless&quot;:
            return (
                getVal(key)
                ? &quot;&quot;
                // recurse with partial
                : local.templateRender(partial, dict, opt)
            );
        default:
            // recurse with partial
            return match0[0] + local.templateRender(match0.slice(1), dict, opt);
        }
    };
    // render partials
    rgx = (
        /\{\{#(\w+)\u0020([^}]+?)\}\}/g
    );
    template = template || &quot;&quot;;
    match = rgx.exec(template);
    while (match) {
        rgx.lastIndex += 1 - match[0].length;
        template = template.replace(
            new RegExp(
                &quot;\\{\\{#(&quot; + match[1] + &quot;) (&quot; + match[2]
                + &quot;)\\}\\}([\\S\\s]*?)\\{\\{/&quot; + match[1] + &quot; &quot; + match[2]
                + &quot;\\}\\}&quot;
            ),
            renderPartial
        );
        match = rgx.exec(template);
    }
    // search for keys in template
    return template.replace((
        /\{\{[^}]+?\}\}/g
    ), function (match0) {
        let markdownToHtml;
        let notHtmlSafe;
        notHtmlSafe = opt.notHtmlSafe;
        try {
            val = getVal(match0.slice(2, -2));
            if (val === undefined) {
                return match0;
            }
            argList.slice(1).forEach(function (fmt, ii, list) {
                switch (fmt) {
                case &quot;*&quot;:
                case &quot;+&quot;:
                case &quot;-&quot;:
                case &quot;/&quot;:
                    skip = ii + 1;
                    val = String(
                        fmt === &quot;*&quot;
                        ? Number(val) * Number(list[skip])
                        : fmt === &quot;+&quot;
                        ? Number(val) + Number(list[skip])
                        : fmt === &quot;-&quot;
                        ? Number(val) - Number(list[skip])
                        : Number(val) / Number(list[skip])
                    );
                    break;...</pre></li>
    <li>example use<pre class="apidocCodePre">...
case &quot;each&quot;:
case &quot;eachTrimEndComma&quot;:
    val = getVal(key);
    val = (
        Array.isArray(val)
        ? val.map(function (dict, ii) {
            // recurse with partial
            return local.<span class="apidocCodeKeywordSpan">templateRender</span>(partial, dict, opt, ii);
        }).join(&quot;&quot;)
        : &quot;&quot;
    );
    // remove trailing-comma from last elem
    if (helper === &quot;eachTrimEndComma&quot;) {
        val = val.trimEnd().replace((
            /,$/
...</pre></li>
    </ul>










































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.Instrumenter" id="apidoc.module.utility2.istanbul.Instrumenter">module utility2.istanbul.Instrumenter</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.Instrumenter" id="apidoc.elem.utility2.istanbul.Instrumenter.Instrumenter">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>Instrumenter
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Instrumenter(options) {
    this.opts = options || {
        debug: false,
        walkDebug: false,
        coverageVariable: &apos;__coverage__&apos;,
        codeGenerationOptions: undefined,
        noAutoWrap: false,
        noCompact: false,
        embedSource: false,
        preserveComments: false,
        esModules: false
    };

    if (this.opts.esModules &amp;&amp; !this.opts.noAutoWrap) {
        this.opts.noAutoWrap = true;
        if (this.opts.debug) {
            console.log(&apos;Setting noAutoWrap to true as required by esModules&apos;);
        }
    }

    this.walker = new Walker({
        ArrowFunctionExpression: [ this.arrowBlockConverter ],
        ExpressionStatement: this.coverStatement,
        ExportNamedDeclaration: this.coverExport,
        BreakStatement: this.coverStatement,
        ContinueStatement: this.coverStatement,
        DebuggerStatement: this.coverStatement,
        ReturnStatement: this.coverStatement,
        ThrowStatement: this.coverStatement,
        TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],
        VariableDeclaration: this.coverStatement,
        IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],
        ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],
        ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],
        WhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],
        SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],
        SwitchCase: [ this.switchCaseInjector ],
        WithStatement: [ this.withBlockConverter, this.coverStatement ],
        FunctionDeclaration: [ this.coverFunction, this.coverStatement ],
        FunctionExpression: this.coverFunction,
        LabeledStatement: this.coverStatement,
        ConditionalExpression: this.conditionalBranchInjector,
        LogicalExpression: this.logicalExpressionBranchInjector,
        ObjectExpression: this.maybeAddType,
        MetaProperty: this.coverMetaProperty,
    }, this.extractCurrentHint, this, this.opts.walkDebug);

    //unit testing purposes only
    if (this.opts.backdoor &amp;&amp; this.opts.backdoor.omitTrackerSuffix) {
        this.omitTrackerSuffix = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.Instrumenter.prototype" id="apidoc.module.utility2.istanbul.Instrumenter.prototype">module utility2.istanbul.Instrumenter.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.arrowBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.arrowBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>arrowBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowBlockConverter = function (node) {
    var retStatement;
    if (node.expression) { // turn expression nodes into a block with a return statement
        retStatement = astgen.returnStatement(node.body);
        // ensure the generated return statement is covered
        retStatement.loc = node.body.loc;
        node.body = this.convertToBlock(retStatement);
        node.expression = false;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchIncrementExprAst" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchIncrementExprAst">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchIncrementExprAst
        <span class="apidocSignatureSpan">(varName, branchIndex, down)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchIncrementExprAst = function (varName, branchIndex, down) {
    var ret = astgen.postIncrement(
        astgen.subscript(
            astgen.subscript(
                astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;b&apos;)),
                astgen.stringLiteral(varName)
            ),
            astgen.numericLiteral(branchIndex)
        ),
        down
    );
    return ret;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchLocationFor" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchLocationFor">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchLocationFor
        <span class="apidocSignatureSpan">(name, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchLocationFor = function (name, index) {
    return this.coverState.branchMap[name].locations[index];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchName" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.branchName">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>branchName
        <span class="apidocSignatureSpan">(type, startLine, pathLocations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">branchName = function (type, startLine, pathLocations) {
    var bName,
        paths = [],
        locations = [],
        i,
        ignoring = !!this.currentState.ignoring;
    this.currentState.branch += 1;
    bName = this.currentState.branch;
    for (i = 0; i &lt; pathLocations.length; i += 1) {
        pathLocations[i].skip = pathLocations[i].skip || ignoring || undefined;
        locations.push(pathLocations[i]);
        paths.push(0);
    }
    this.coverState.b[bName] = paths;
    this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };
    return bName;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.conditionalBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.conditionalBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>conditionalBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalBranchInjector = function (node, walker) {
    var bName = this.branchName(&apos;cond-expr&apos;, walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate
 ])),
        ast1 = this.branchIncrementExprAst(bName, 0),
        ast2 = this.branchIncrementExprAst(bName, 1);

    node.consequent.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 0));
    node.alternate.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 1));
    node.consequent = astgen.sequence(ast1, node.consequent);
    node.alternate = astgen.sequence(ast2, node.alternate);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.convertToBlock" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.convertToBlock">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>convertToBlock
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">convertToBlock = function (node) {
    if (!node) {
        return { type: &apos;BlockStatement&apos;, body: [] };
    } else if (node.type === &apos;BlockStatement&apos;) {
        return node;
    } else {
        return { type: &apos;BlockStatement&apos;, body: [ node ] };
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverExport" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverExport
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverExport = function (node, walker) {
    var sName, incrStatementCount;

    if ( !node.declaration || !node.declaration.declarations ) { return; }

    this.maybeSkipNode(node, &apos;next&apos;);

    sName = this.statementName(node.declaration.loc);
    incrStatementCount = astgen.statement(
        astgen.postIncrement(
            astgen.subscript(
                astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;s&apos;)),
                astgen.stringLiteral(sName)
            )
        )
    );

    this.splice(incrStatementCount, node, walker);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverFunction" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverFunction
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverFunction = function (node, walker) {
    var id,
        body = node.body,
        blockBody = body.body,
        popped;

    this.maybeSkipNode(node, &apos;next&apos;);

    id = this.functionName(node, walker.startLineForNode(node), {
        start: node.loc.start,
        end: { line: node.body.loc.start.line, column: node.body.loc.start.column }
    });

    if (blockBody.length &gt; 0 &amp;&amp; this.isUseStrictExpression(blockBody[0])) {
        popped = blockBody.shift();
    }
    blockBody.unshift(
        astgen.statement(
            astgen.postIncrement(
                astgen.subscript(
                    astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;f&apos;)),
                    astgen.stringLiteral(id)
                )
            )
        )
    );
    if (popped) {
        blockBody.unshift(popped);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverMetaProperty" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverMetaProperty">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverMetaProperty
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
   node.skipSelf = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverStatement" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.coverStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>coverStatement
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coverStatement = function (node, walker) {
    var sName,
        incrStatementCount,
        parent,
        grandParent;

    this.maybeSkipNode(node, &apos;next&apos;);

    if (this.isUseStrictExpression(node)) {
        grandParent = walker.ancestor(2);
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: difficult to test */
</span>        if (grandParent) {
            if ((grandParent.node.type === SYNTAX.FunctionExpression.name ||
                grandParent.node.type === SYNTAX.FunctionDeclaration.name)  &amp;&amp;
                walker.parent().node.body[0] === node) {
                return;
            }
        }
    }

    if (node.type === SYNTAX.FunctionDeclaration.name) {
        // Called for the side-effect of setting the function&apos;s statement count to 1.
        this.statementName(node.loc, 1);
    } else {
        // We let `coverExport` handle ExportNamedDeclarations.
        parent = walker.parent();
        if (parent &amp;&amp; parent.node.type === SYNTAX.ExportNamedDeclaration.name) {
            return;
        }

        sName = this.statementName(node.loc);

        incrStatementCount = astgen.statement(
            astgen.postIncrement(
                astgen.subscript(
                    astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable(&apos;s&apos;)),
                    astgen.stringLiteral(sName)
                )
            )
        );

        this.splice(incrStatementCount, node, walker);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.endIgnore" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.endIgnore">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>endIgnore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endIgnore = function () {
    this.currentState.ignoring -= 1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.extractCurrentHint" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.extractCurrentHint">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>extractCurrentHint
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extractCurrentHint = function (node) {
    if (!node.range) { return; }
    var i = this.currentState.lastHintPosition + 1,
        hints = this.currentState.hints,
        nodeStart = node.range[0],
        hint;
    this.currentState.currentHint = null;
    // hack-coverage - allow top-level istanbul-ignore-next
    if (node.type === &quot;Program&quot;) { return; }
    while (i &lt; hints.length) {
        hint = hints[i];
        if (hint.end &lt; nodeStart) {
            this.currentState.currentHint = hint;
            this.currentState.lastHintPosition = i;
            i += 1;
        } else {
            break;
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.filterHints" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.filterHints">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>filterHints
        <span class="apidocSignatureSpan">(comments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterHints = function (comments) {
    var ret = [],
        i,
        comment,
        groups;
    if (!(comments &amp;&amp; isArray(comments))) {
        return ret;
    }
    for (i = 0; i &lt; comments.length; i += 1) {
        comment = comments[i];
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: paranoid check */
</span>        if (comment &amp;&amp; comment.value &amp;&amp; comment.range &amp;&amp; isArray(comment.range)) {
            groups = String(comment.value).match(COMMENT_RE);
            if (groups) {
                ret.push({ type: groups[1], start: comment.range[0], end: comment.range[1] });
            }
        }
    }
    return ret;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.findLeaves" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.findLeaves">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>findLeaves
        <span class="apidocSignatureSpan">(node, accumulator, parent, property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLeaves = function (node, accumulator, parent, property) {
    if (node.type === SYNTAX.LogicalExpression.name) {
        this.findLeaves(node.left, accumulator, node, &apos;left&apos;);
        this.findLeaves(node.right, accumulator, node, &apos;right&apos;);
    } else {
        accumulator.push({ node: node, parent: parent, property: property });
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.fixColumnPositions" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.fixColumnPositions">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>fixColumnPositions
        <span class="apidocSignatureSpan">(coverState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixColumnPositions = function (coverState) {
    var offset = LEADER_WRAP.length,
        fixer = function (loc) {
            if (loc.start.line === 1) {
                loc.start.column -= offset;
            }
            if (loc.end.line === 1) {
                loc.end.column -= offset;
            }
        },
        k,
        obj,
        i,
        locations;

    obj = coverState.statementMap;
    for (k in obj) {
<span class="apidocCodeCommentSpan">        /* istanbul ignore else: has own property */
</span>        if (obj.hasOwnProperty(k)) { fixer(obj[k]); }
    }
    obj = coverState.fnMap;
    for (k in obj) {
        /* istanbul ignore else: has own property */
        if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }
    }
    obj = coverState.branchMap;
    for (k in obj) {
        /* istanbul ignore else: has own property */
        if (obj.hasOwnProperty(k)) {
            locations = obj[k].locations;
            for (i = 0; i &lt; locations.length; i += 1) {
                fixer(locations[i]);
            }
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.functionName" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.functionName">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>functionName
        <span class="apidocSignatureSpan">(node, line, location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionName = function (node, line, location) {
    this.currentState.func += 1;
    var id = this.currentState.func,
        ignoring = !!this.currentState.ignoring,
        name = node.id ? node.id.name : &apos;(anonymous_&apos; + id + &apos;)&apos;,
        clone = function (attr) {
            var obj = location[attr] || /* istanbul ignore next */ {};
            return { line: obj.line, column: obj.column };
        };
    this.coverState.fnMap[id] = {
        name: name, line: line,
        loc: {
            start: clone(&apos;start&apos;),
            end: clone(&apos;end&apos;)
        },
        skip: ignoring || undefined
    };
    this.coverState.f[id] = 0;
    return id;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.getPreamble" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.getPreamble">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>getPreamble
        <span class="apidocSignatureSpan">(sourceCode, emitUseStrict)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPreamble = function (sourceCode, emitUseStrict) {
    var varName = this.opts.coverageVariable || &apos;__coverage__&apos;,
        file = this.coverState.path.replace(/\\/g, &apos;\\\\&apos;),
        tracker = this.currentState.trackerVar,
        coverState,
        strictLine = emitUseStrict ? &apos;&quot;use strict&quot;;&apos; : &apos;&apos;,
        // return replacements using the function to ensure that the replacement is
        // treated like a dumb string and not as a string with RE replacement patterns
        replacer = function (s) {
            return function () { return s; };
        },
        code;
    if (!this.opts.noAutoWrap) {
        this.fixColumnPositions(this.coverState);
    }
    if (this.opts.embedSource) {
        this.coverState.code = sourceCode.split(/(?:\r?\n)|\r/);
    }
    coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);
    code = [
        &quot;%STRICT%&quot;,
        &quot;var %VAR% = (Function(&apos;return this&apos;))();&quot;,
        &quot;if (!%VAR%.%GLOBAL%) { %VAR%.%GLOBAL% = {}; }&quot;,
        &quot;%VAR% = %VAR%.%GLOBAL%;&quot;,
        &quot;if (!(%VAR%[&apos;%FILE%&apos;])) {&quot;,
        &quot;   %VAR%[&apos;%FILE%&apos;] = %OBJECT%;&quot;,
        &quot;}&quot;,
        &quot;%VAR% = %VAR%[&apos;%FILE%&apos;];&quot;
    ].join(&quot;\n&quot;)
        .replace(/%STRICT%/g, replacer(strictLine))
        .replace(/%VAR%/g, replacer(tracker))
        .replace(/%GLOBAL%/g, replacer(varName))
        .replace(/%FILE%/g, replacer(file))
        .replace(/%OBJECT%/g, replacer(coverState));
    return code;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifBlockConverter = function (node) {
    node.consequent = this.convertToBlock(node.consequent);
    node.alternate = this.convertToBlock(node.alternate);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.ifBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>ifBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifBranchInjector = function (node, walker) {
    var alreadyIgnoring = !!this.currentState.ignoring,
        hint = this.currentState.currentHint,
        ignoreThen = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;if&apos;,
        ignoreElse = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;else&apos;,
        line = node.loc.start.line,
        col = node.loc.start.column,
        makeLoc = function () { return  { line: line, column: col }; },
        bName = this.branchName(&apos;if&apos;, walker.startLineForNode(node), [
            { start: makeLoc(), end: makeLoc(), skip: ignoreThen || undefined },
            { start: makeLoc(), end: makeLoc(), skip: ignoreElse || undefined }
        ]),
        thenBody = node.consequent.body,
        elseBody = node.alternate.body,
        child;
    thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));
    elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));
    if (ignoreThen) { child = node.consequent; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
    if (ignoreElse) { child = node.alternate; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrument" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrument">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrument
        <span class="apidocSignatureSpan">(code, filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrument = function (code, filename, callback) {

    if (!callback &amp;&amp; typeof filename === &apos;function&apos;) {
        callback = filename;
        filename = null;
    }
    try {
        callback(null, this.instrumentSync(code, filename));
    } catch (ex) {
        callback(ex);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentASTSync" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentASTSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentASTSync
        <span class="apidocSignatureSpan">(program, filename, originalCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentASTSync = function (program, filename, originalCode) {
    var usingStrict = false,
        codegenOptions,
        generated,
        preamble,
        lineCount,
        i;
    filename = filename || String(new Date().getTime()) + &apos;.js&apos;;
    this.sourceMap = null;
    this.coverState = {
        path: filename,
        s: {},
        b: {},
        f: {},
        fnMap: {},
        statementMap: {},
        branchMap: {}
    };
    this.currentState = {
        trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),
        func: 0,
        branch: 0,
        variable: 0,
        statement: 0,
        hints: this.filterHints(program.comments),
        currentHint: null,
        lastHintPosition: -1,
        ignoring: 0
    };
    if (program.body &amp;&amp; program.body.length &gt; 0 &amp;&amp; this.isUseStrictExpression(program.body[0])) {
        //nuke it
        program.body.shift();
        //and add it back at code generation time
        usingStrict = true;
    }
    this.walker.startWalk(program);
    codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};
    codegenOptions.comment = this.opts.preserveComments;
    //console.log(JSON.stringify(program, undefined, 2));

    generated = ESPGEN.generate(program, codegenOptions);
    preamble = this.getPreamble(originalCode || &apos;&apos;, usingStrict);

    if (generated.map &amp;&amp; generated.code) {
        lineCount = preamble.split(/\r\n|\r|\n/).length;
        // offset all the generated line numbers by the number of lines in the preamble
        for (i = 0; i &lt; generated.map._mappings._array.length; i += 1) {
            generated.map._mappings._array[i].generatedLine += lineCount;
        }
        this.sourceMap = generated.map;
        generated = generated.code;
    }

    return preamble + &apos;\n&apos; + generated + &apos;\n&apos;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentSync" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.instrumentSync">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>instrumentSync
        <span class="apidocSignatureSpan">(code, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrumentSync = function (code, filename) {
    var program;

    //protect from users accidentally passing in a Buffer object instead
    if (typeof code !== &apos;string&apos;) { throw new Error(&apos;Code must be string&apos;); }
    if (code.charAt(0) === &apos;#&apos;) { //shebang, &apos;comment&apos; it out, won&apos;t affect syntax tree locations for things we care about
        code = &apos;//&apos; + code;
    }
    if (!this.opts.noAutoWrap) {
        code = LEADER_WRAP + code + TRAILER_WRAP;
    }
    try {
        // hack-coverage - acorn opt
        let opt = {
            locations: true,
            onComment: [],
            onToken: this.opts.preserveComments,
            ranges: true,
            sourceType: this.opts.esModules ? &apos;module&apos; : &apos;script&apos;
        };
        program = ESP.parse(code, opt);
        program.comments = opt.onComment
    } catch (e) {
        console.log(&apos;Failed to parse file: &apos; + filename);
        throw e;
    }
    if (this.opts.preserveComments) {
        program = ESPGEN.attachComments(program, program.comments, program.tokens);
    }
    if (!this.opts.noAutoWrap) {
        program = {
            type: SYNTAX.Program.name,
            body: program.body[0].expression.callee.body.body,
            comments: program.comments
        };
    }
    return this.instrumentASTSync(program, filename, code);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
try {\n\
    delete globalThis.__coverage__[&quot;/inputTextarea1.js&quot;];\n\
} catch (ignore) {}\n\
// try to cover and eval #inputTextarea1\n\
try {\n\
    document.querySelector(\n\
        &quot;#outputTextarea1&quot;\n\
    ).value = local.istanbul.<span class="apidocCodeKeywordSpan">instrumentSync</span>(\n\
        document.querySelector(&quot;#inputTextarea1&quot;).value,\n\
        &quot;/inputTextarea1.js&quot;\n\
    );\n\
    eval( // jslint ignore:line\n\
        document.querySelector(&quot;#outputTextarea1&quot;).value\n\
    );\n\
} catch (errCaught) {\n\
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.isUseStrictExpression" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.isUseStrictExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>isUseStrictExpression
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUseStrictExpression = function (node) {
    return node &amp;&amp; node.type === SYNTAX.ExpressionStatement.name &amp;&amp;
        node.expression  &amp;&amp; node.expression.type === SYNTAX.Literal.name &amp;&amp;
        node.expression.value === &apos;use strict&apos;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastFileCoverage" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastFileCoverage">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastFileCoverage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastFileCoverage = function () {
    return this.coverState;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastSourceMap" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.lastSourceMap">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>lastSourceMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastSourceMap = function () {
    return this.sourceMap;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.locationsForNodes" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.locationsForNodes">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>locationsForNodes
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locationsForNodes = function (nodes) {
    var ret = [],
        i;
    for (i = 0; i &lt; nodes.length; i += 1) {
        ret.push(nodes[i].loc);
    }
    return ret;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.logicalExpressionBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.logicalExpressionBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>logicalExpressionBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalExpressionBranchInjector = function (node, walker) {
    var parent = walker.parent(),
        leaves = [],
        bName,
        tuple,
        i;

    this.maybeSkipNode(node, &apos;next&apos;);

    if (parent &amp;&amp; parent.node.type === SYNTAX.LogicalExpression.name) {
        //already covered
        return;
    }

    this.findLeaves(node, leaves);
    bName = this.branchName(&apos;binary-expr&apos;,
        walker.startLineForNode(node),
        this.locationsForNodes(leaves.map(function (item) { return item.node; }))
    );
    for (i = 0; i &lt; leaves.length; i += 1) {
        tuple = leaves[i];
        tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);
        tuple.node.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, i));
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.loopBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.loopBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>loopBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loopBlockConverter = function (node) {
    node.body = this.convertToBlock(node.body);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddSkip" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddSkip">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddSkip
        <span class="apidocSignatureSpan">(branchLocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeAddSkip = function (branchLocation) {
    return function (node) {
        var alreadyIgnoring = !!this.currentState.ignoring,
            hint = this.currentState.currentHint,
            ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === &apos;next&apos;;
        if (ignoreThis) {
            this.startIgnore();
            node.postprocessor = this.endIgnore;
        }
        if (ignoreThis || alreadyIgnoring) {
            branchLocation.skip = true;
        }
    };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddType" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeAddType">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeAddType
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeAddType = function (node) {
    var props = node.properties,
        i,
        child;
    for (i = 0; i &lt; props.length; i += 1) {
        child = props[i];
        if (!child.type) {
            child.type = SYNTAX.Property.name;
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeSkipNode" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.maybeSkipNode">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>maybeSkipNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeSkipNode = function (node, type) {
    var alreadyIgnoring = !!this.currentState.ignoring,
        hint = this.currentState.currentHint,
        ignoreThis = !alreadyIgnoring &amp;&amp; hint &amp;&amp; hint.type === type;

    if (ignoreThis) {
        this.startIgnore();
        node.postprocessor = this.endIgnore;
        return true;
    }
    return false;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.paranoidHandlerCheck" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.paranoidHandlerCheck">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>paranoidHandlerCheck
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">paranoidHandlerCheck = function (node) {
    // if someone is using an older esprima on the browser
    // convert handlers array to single handler attribute
    // containing its first element
<span class="apidocCodeCommentSpan">    /* istanbul ignore next */
</span>    if (!node.handler &amp;&amp; node.handlers) {
        node.handler = node.handlers[0];
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipInit" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipInit">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipInit
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipInit = function (node) {
    if (node.init) {
        node.init.skipWalk = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipLeft" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.skipLeft">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>skipLeft
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLeft = function (node) {
    node.left.skipWalk = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.splice" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.splice">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>splice
        <span class="apidocSignatureSpan">(statements, node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (statements, node, walker) {
    var targetNode = walker.isLabeled() ? walker.parent().node : node;
    targetNode.prepend = targetNode.prepend || [];
    pushAll(targetNode.prepend, statements);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
};

Reference.prototype.remove = function remove() {
    if (isArray(this.parent)) {
        this.parent.<span class="apidocCodeKeywordSpan">splice</span>(this.key, 1);
        return true;
    } else {
        this.replace(null);
        return false;
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.startIgnore" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.startIgnore">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>startIgnore
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startIgnore = function () {
    this.currentState.ignoring += 1;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.statementName" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.statementName">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>statementName
        <span class="apidocSignatureSpan">(location, initValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statementName = function (location, initValue) {
    var sName,
        ignoring = !!this.currentState.ignoring;

    location.skip = ignoring || undefined;
    initValue = initValue || 0;
    this.currentState.statement += 1;
    sName = this.currentState.statement;
    this.coverState.statementMap[sName] = location;
    this.coverState.s[sName] = initValue;
    return sName;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchBranchInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchBranchInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchBranchInjector
        <span class="apidocSignatureSpan">(node, walker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchBranchInjector = function (node, walker) {
    var cases = node.cases,
        bName,
        i;

    if (!(cases &amp;&amp; cases.length &gt; 0)) {
        return;
    }
    bName = this.branchName(&apos;switch&apos;, walker.startLineForNode(node), this.locationsForNodes(cases));
    for (i = 0; i &lt; cases.length; i += 1) {
        cases[i].branchLocation = this.branchLocationFor(bName, i);
        cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchCaseInjector" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.switchCaseInjector">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>switchCaseInjector
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchCaseInjector = function (node) {
    var location = node.branchLocation;
    delete node.branchLocation;
    if (this.maybeSkipNode(node, &apos;next&apos;)) {
        location.skip = true;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.Instrumenter.prototype.withBlockConverter" id="apidoc.elem.utility2.istanbul.Instrumenter.prototype.withBlockConverter">
        function <span class="apidocSignatureSpan">utility2.istanbul.Instrumenter.prototype.</span>withBlockConverter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withBlockConverter = function (node) {
    node.body = this.convertToBlock(node.body);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.cliDict" id="apidoc.module.utility2.istanbul.cliDict">module utility2.istanbul.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.cover" id="apidoc.elem.utility2.istanbul.cliDict.cover">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>cover
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cover = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will run and cover &lt;script&gt;
 */
</span>    let tmp;
    try {
        tmp = JSON.parse(local.fs.readFileSync(&quot;package.json&quot;, &quot;utf8&quot;));
        process.env.npm_package_nameLib = (
            process.env.npm_package_nameLib
            || tmp.nameLib
            || tmp.name.replace((
                /-/g
            ), &quot;_&quot;)
        );
    } catch (ignore) {}
    process.env.npm_config_mode_coverage = (
        process.env.npm_config_mode_coverage
        || process.env.npm_package_nameLib
        || &quot;all&quot;
    );
    // add coverage hook to require
    local.__istanbul_moduleExtensionsJs = (
        local.__istanbul_module._extensions[&quot;.js&quot;]
    );
    local.__istanbul_module._extensions[&quot;.js&quot;] = function (module, file) {
        if (typeof file === &quot;string&quot; &amp;&amp; (
            file.indexOf(process.env.npm_config_mode_coverage_dir) === 0 || (
                file.indexOf(process.cwd() + local.path.sep) === 0
                &amp;&amp; (
                    process.env.npm_config_mode_coverage === &quot;node_modules&quot;
                    || file.indexOf(
                        local.path.resolve(&quot;node_modules&quot;) + local.path.sep
                    ) !== 0
                )
            )
        )) {
            module._compile(local.instrumentInPackage(
                local.fs.readFileSync(file, &quot;utf8&quot;),
                file
            ), file);
            return;
        }
        local.__istanbul_moduleExtensionsJs(module, file);
    };
    // init process.argv
    process.argv.splice(1, 2);
    process.argv[1] = local.path.resolve(process.argv[1]);
    console.error(&quot;\nistanbul - covering $ &quot; + process.argv.join(&quot; &quot;));
    // create coverage on exit
    process.on(&quot;exit&quot;, function () {
        local.coverageReportCreate({
            coverage: globalThis.__coverage__
        });
    });
    // re-init cli
    local.__istanbul_module.runMain();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.instrument" id="apidoc.elem.utility2.istanbul.cliDict.instrument">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>instrument
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instrument = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will instrument &lt;script&gt; and print result to stdout
 */
</span>    process.argv[3] = local.path.resolve(process.argv[3]);
    process.stdout.write(local.instrumentSync(
        local.fs.readFileSync(process.argv[3], &quot;utf8&quot;),
        process.argv[3]
    ));
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.report" id="apidoc.elem.utility2.istanbul.cliDict.report">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>report
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;coverageJson&gt;
 * will create coverage-report from file &lt;coverageJson&gt;
 */
</span>    process.argv[3] = local.path.resolve(process.argv[3]);
    globalThis.__coverage__ = JSON.parse(
        local.fs.readFileSync(process.argv[3])
    );
    globalThis.__coverageInclude__ = {};
    Object.keys(globalThis.__coverage__).forEach(function (file) {
        globalThis.__coverageInclude__[file] = 1;
    });
    local.coverageReportCreate({
        coverage: globalThis.__coverage__
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.cliDict.test" id="apidoc.elem.utility2.istanbul.cliDict.test">
        function <span class="apidocSignatureSpan">utility2.istanbul.cliDict.</span>test
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;script&gt;
 * will run and cover &lt;script&gt; if env-var $npm_config_mode_coverage is set
 */
</span>    if (process.env.npm_config_mode_coverage) {
        process.argv[2] = &quot;cover&quot;;
        // re-init cli
        local.cliDict[process.argv[2]]();
        return;
    }
    // restart node with __filename removed from process.argv
    process.argv.splice(1, 2);
    process.argv[1] = local.path.resolve(process.argv[1]);
    // re-init cli
    local.__istanbul_module.runMain();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return {
elemList: Object.keys(module).filter(function (key) {
    return local.tryCatchOnError(function () {
        return (
            key
            &amp;&amp; (
                /^\w[\w\-.]*?$/
            ).<span class="apidocCodeKeywordSpan">test</span>(key)
            &amp;&amp; key.indexOf(&quot;testCase_&quot;) !== 0
            &amp;&amp; (
                module[key] !== opt.blacklistDict[key]
                || opt.whitelistDict[key]
            )
        );
    }, console.error);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.escodegen" id="apidoc.module.utility2.istanbul.escodegen">module utility2.istanbul.escodegen</a></h1>




    <h2>
        <a href="#apidoc.elem.utility2.istanbul.escodegen.attachComments" id="apidoc.elem.utility2.istanbul.escodegen.attachComments">
        function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [], comment, len, i, cursor;

    if (!tree.range) {
        throw new Error(&apos;attachComments needs range information&apos;);
    }

    // tokens array is empty, we attach comments to tree as &apos;leadingComments&apos;
    if (!tokens.length) {
        if (providedComments.length) {
            for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
                comment = deepCopy(providedComments[i]);
                comment.extendedRange = [0, tree.range[0]];
                comments.push(comment);
            }
            tree.leadingComments = comments;
        }
        return tree;
    }

    for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman&apos;s implementation.
    cursor = 0;
    traverse(tree, {
        enter: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (comment.extendedRange[1] &gt; node.range[0]) {
                    break;
                }

                if (comment.extendedRange[1] === node.range[0]) {
                    if (!node.leadingComments) {
                        node.leadingComments = [];
                    }
                    node.leadingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    cursor = 0;
    traverse(tree, {
        leave: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (node.range[1] &lt; comment.extendedRange[0]) {
                    break;
                }

                if (node.range[1] === comment.extendedRange[0]) {
                    if (!node.trailingComments) {
                        node.trailingComments = [];
                    }
                    node.trailingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    return tree;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.escodegen.generate" id="apidoc.elem.utility2.istanbul.escodegen.generate">
        function <span class="apidocSignatureSpan">utility2.istanbul.escodegen.</span>generate
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(node, options) {
    var defaultOptions = getDefaultOptions(), result, pair;

    if (options != null) {
        // Obsolete options
        //
        //   `options.indent`
        //   `options.base`
        //
        // Instead of them, we can use `option.format.indent`.
        if (typeof options.indent === &apos;string&apos;) {
            defaultOptions.format.indent.style = options.indent;
        }
        if (typeof options.base === &apos;number&apos;) {
            defaultOptions.format.indent.base = options.base;
        }
        options = updateDeeply(defaultOptions, options);
        indent = options.format.indent.style;
        if (typeof options.base === &apos;string&apos;) {
            base = options.base;
        } else {
            base = stringRepeat(indent, options.format.indent.base);
        }
    } else {
        options = defaultOptions;
        indent = options.format.indent.style;
        base = stringRepeat(indent, options.format.indent.base);
    }
    json = options.format.json;
    renumber = options.format.renumber;
    hexadecimal = json ? false : options.format.hexadecimal;
    quotes = json ? &apos;double&apos; : options.format.quotes;
    escapeless = options.format.escapeless;
    newline = options.format.newline;
    space = options.format.space;
    if (options.format.compact) {
        newline = space = indent = base = &apos;&apos;;
    }
    parentheses = options.format.parentheses;
    semicolons = options.format.semicolons;
    safeConcatenation = options.format.safeConcatenation;
    directive = options.directive;
    parse = json ? null : options.parse;
    sourceMap = options.sourceMap;
    sourceCode = options.sourceCode;
    preserveBlankLines = options.format.preserveBlankLines &amp;&amp; sourceCode !== null;
    extra = options;

    if (sourceMap) {
        if (!exports.browser) {
            // We assume environment is node.js
            // And prevent from including source-map by browserify
            SourceNode = require(&apos;source-map&apos;).SourceNode;
        } else {
            SourceNode = global.sourceMap.SourceNode;
        }
    }

    result = generateInternal(node);

    if (!sourceMap) {
        pair = {code: result.toString(), map: null};
        return options.sourceMapWithCode ? pair : pair.code;
    }

    pair = result.toStringWithSourceMap({
        file: options.file,
        sourceRoot: options.sourceMapRoot
    });

    if (options.sourceContent) {
        pair.map.setSourceContent(options.sourceMap,
                                  options.sourceContent);
    }

    if (options.sourceMapWithCode) {
        return pair;
    }

    return pair.map.toString();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.esprima" id="apidoc.module.utility2.istanbul.esprima">module utility2.istanbul.esprima</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Node" id="apidoc.elem.utility2.istanbul.esprima.Node">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Node
        <span class="apidocSignatureSpan">(parser, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(parser, pos, loc) {
  this.type = &quot;&quot;;
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser" id="apidoc.elem.utility2.istanbul.esprima.Parser">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : options.sourceType === &quot;module&quot; ? &quot;5module&quot; : 5]);
  var reserved = &quot;&quot;;
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === &quot;module&quot;) { reserved += &quot; await&quot;; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + &quot; &quot; : &quot;&quot;) + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + &quot; &quot; + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(&quot;\n&quot;, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it&apos;s a module code.
  this.inModule = options.sourceType === &quot;module&quot;;
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Position" id="apidoc.elem.utility2.istanbul.esprima.Position">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line;
  this.column = col;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.SourceLocation" id="apidoc.elem.utility2.istanbul.esprima.SourceLocation">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>SourceLocation
        <span class="apidocSignatureSpan">(p, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.TokContext" id="apidoc.elem.utility2.istanbul.esprima.TokContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokContext
        <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Token" id="apidoc.elem.utility2.istanbul.esprima.Token">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>Token
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.TokenType" id="apidoc.elem.utility2.istanbul.esprima.TokenType">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>TokenType
        <span class="apidocSignatureSpan">(label, conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.getLineInfo" id="apidoc.elem.utility2.istanbul.esprima.getLineInfo">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>getLineInfo
        <span class="apidocSignatureSpan">(input, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match &amp;&amp; match.index &lt; offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierChar" id="apidoc.elem.utility2.istanbul.esprima.isIdentifierChar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierChar
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierChar(code, astral) {
  if (code &lt; 48) { return code === 36 }
  if (code &lt; 58) { return true }
  if (code &lt; 65) { return false }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.isIdentifierStart" id="apidoc.elem.utility2.istanbul.esprima.isIdentifierStart">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isIdentifierStart
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierStart(code, astral) {
  if (code &lt; 65) { return code === 36 }
  if (code &lt; 91) { return true }
  if (code &lt; 97) { return code === 95 }
  if (code &lt; 123) { return true }
  if (code &lt;= 0xffff) { return code &gt;= 0xaa &amp;&amp; nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.isNewLine" id="apidoc.elem.utility2.istanbul.esprima.isNewLine">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>isNewLine
        <span class="apidocSignatureSpan">(code, ecma2019String)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String &amp;&amp; (code === 0x2028 || code === 0x2029))
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.parse" id="apidoc.elem.utility2.istanbul.esprima.parse">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parse
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(input, options) {
  return Parser.parse(input, options)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.parseExpressionAt" id="apidoc.elem.utility2.istanbul.esprima.parseExpressionAt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>parseExpressionAt
        <span class="apidocSignatureSpan">(input, pos, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.<span class="apidocCodeKeywordSpan">parseExpressionAt</span>(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.tokenizer" id="apidoc.elem.utility2.istanbul.esprima.tokenizer">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.</span>tokenizer
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.<span class="apidocCodeKeywordSpan">tokenizer</span>(input, options)
}

exports.Node = Node;
exports.Parser = Parser;
exports.Position = Position;
exports.SourceLocation = SourceLocation;
exports.TokContext = TokContext;
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.esprima.Parser.prototype" id="apidoc.module.utility2.istanbul.esprima.Parser.prototype">module utility2.istanbul.esprima.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.adaptDirectivePrologue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.adaptDirectivePrologue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>adaptDirectivePrologue
        <span class="apidocSignatureSpan">(statements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(statements) {
  for (var i = 0; i &lt; statements.length &amp;&amp; this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined
&quot;));
      } }
  this.<span class="apidocCodeKeywordSpan">adaptDirectivePrologue</span>(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, &quot;Program&quot;)
};

var loopLabel = {kind: &quot;loop&quot;}, switchLabel = {kind: &quot;switch&quot;};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.afterTrailingComma" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.afterTrailingComma">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>afterTrailingComma
        <span class="apidocSignatureSpan">(tokType, notNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from &apos;...&apos;]
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
if (!first) {
  this.expect(types.comma);
  if (this.<span class="apidocCodeKeywordSpan">afterTrailingComma</span>(types.braceR)) { break }
} else { first = false; }

var node = this.startNode();
node.local = this.parseIdent(true);
node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdent(true) : node.local;
this.checkExport(exports, node.exported.name, node.exported.start);
nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.braceIsBlock" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.braceIsBlock">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>braceIsBlock
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon &amp;&amp; (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name &amp;&amp; exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name &amp;&amp; this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType ===
types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (out === types$1.b_stat &amp;&amp; this.curContext().token === &quot;function&quot;) {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.<span class="apidocCodeKeywordSpan">braceIsBlock</span>(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.buildBinary" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.buildBinary">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>buildBinary
        <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? &quot;LogicalExpression&quot; : &quot;BinaryExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (prec != null &amp;&amp; (!noIn || this.type !== types._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.<span class="apidocCodeKeywordSpan">buildBinary</span>(leftStartPos, leftStartLoc, left, right, op, logical
);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.canInsertSemicolon" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.canInsertSemicolon">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>canInsertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.<span class="apidocCodeKeywordSpan">canInsertSemicolon</span>()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExport
        <span class="apidocSignatureSpan">(exports, name, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, &quot;Duplicate export &apos;&quot; + name + &quot;&apos;&quot;); }
  exports[name] = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.expectContextual(&quot;from&quot;);
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
}
if (this.eat(types._default)) { // export default ...
  this.<span class="apidocCodeKeywordSpan">checkExport</span>(exports, &quot;default&quot;, this.lastTokStart);
  var isAsync;
  if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) { this.next(); }
    node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types._class) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExpressionErrors" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkExpressionErrors">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkExpressionErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign &gt;= 0 || doubleProto &gt;= 0 }
  if (shorthandAssign &gt;= 0)
    { this.raise(shorthandAssign, &quot;Shorthand property assignments are valid only in destructuring patterns&quot;); }
  if (doubleProto &gt;= 0)
    { this.raiseRecoverable(doubleProto, &quot;Redefinition of __proto__ property&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.<span class="apidocCodeKeywordSpan">checkExpressionErrors</span>(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLVal" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLVal">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLVal
        <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case &quot;Identifier&quot;:
    if (bindingType === BIND_LEXICAL &amp;&amp; expr.name === &quot;let&quot;)
      { this.raiseRecoverable(expr.start, &quot;let is disallowed as a lexically bound name&quot;); }
    if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in strict mode&quot;); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE &amp;&amp; bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case &quot;MemberExpression&quot;:
    if (bindingType) { this.raiseRecoverable(expr.start, &quot;Binding member expression&quot;); }
    break

  case &quot;ObjectPattern&quot;:
    for (var i = 0, list = expr.properties; i &lt; list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case &quot;Property&quot;:
    // AssignmentProperty has type === &quot;Property&quot;
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case &quot;ArrayPattern&quot;:
    for (var i$1 = 0, list$1 = expr.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case &quot;AssignmentPattern&quot;:
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case &quot;RestElement&quot;:
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case &quot;ParenthesizedExpression&quot;:
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? &quot;Binding&quot; : &quot;Assigning to&quot;) + &quot; rvalue&quot;);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.<span class="apidocCodeKeywordSpan">checkLVal</span>(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLocalExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkLocalExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkLocalExport
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &amp;&amp;
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  } else {
    for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
      // check for keywords used as local names
      var spec = list[i];

      this.checkUnreserved(spec.local);
      // check if export is defined
      this.<span class="apidocCodeKeywordSpan">checkLocalExport</span>(spec.local);
    }

    node.source = null;
  }
  this.semicolon();
}
return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkParams" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkParams">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkParams
        <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
var isExpression = isArrowFunction &amp;&amp; this.type !== types.braceL;
var oldStrict = this.strict, useStrict = false;

if (isExpression) {
  node.body = this.parseMaybeAssign();
  node.expression = true;
  this.<span class="apidocCodeKeywordSpan">checkParams</span>(node, false);
} else {
  var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params);
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end);
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternErrors" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternErrors">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma &gt; -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, &quot;Comma is not permitted after the rest element&quot;); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens &gt; -1) { this.raiseRecoverable(parens, &quot;Parenthesized pattern&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      case &quot;ObjectPattern&quot;:
      case &quot;ArrayPattern&quot;:
      case &quot;RestElement&quot;:
break

      case &quot;ObjectExpression&quot;:
node.type = &quot;ObjectPattern&quot;;
if (refDestructuringErrors) { this.<span class="apidocCodeKeywordSpan">checkPatternErrors</span>(refDestructuringErrors, true); }
for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
  var prop = list[i];

this.toAssignable(prop, isBinding);
  // Early error:
  //   AssignmentRestProperty[Yield, Await] :
  //     `...` DestructuringAssignmentTarget[Yield, Await]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPatternExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPatternExport
        <span class="apidocSignatureSpan">(exports, pat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, pat) {
  var type = pat.type;
  if (type === &quot;Identifier&quot;)
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === &quot;ObjectPattern&quot;)
    { for (var i = 0, list = pat.properties; i &lt; list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === &quot;ArrayPattern&quot;)
    { for (var i$1 = 0, list$1 = pat.elements; i$1 &lt; list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === &quot;Property&quot;)
    { this.checkPatternExport(exports, pat.value); }
  else if (type === &quot;AssignmentPattern&quot;)
    { this.checkPatternExport(exports, pat.left); }
  else if (type === &quot;RestElement&quot;)
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === &quot;ParenthesizedExpression&quot;)
    { this.checkPatternExport(exports, pat.expression); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (type === &quot;Identifier&quot;)
{ this.checkExport(exports, pat.name, pat.start); }
    else if (type === &quot;ObjectPattern&quot;)
{ for (var i = 0, list = pat.properties; i &lt; list.length; i += 1)
  {
    var prop = list[i];

    this.<span class="apidocCodeKeywordSpan">checkPatternExport</span>(exports, prop);
  } }
    else if (type === &quot;ArrayPattern&quot;)
{ for (var i$1 = 0, list$1 = pat.elements; i$1 &lt; list$1.length; i$1 += 1) {
  var elt = list$1[i$1];

    if (elt) { this.checkPatternExport(exports, elt); }
} }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPropClash" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkPropClash">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkPropClash
        <span class="apidocSignatureSpan">(prop, propHash, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; prop.type === &quot;SpreadElement&quot;)
    { return }
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case &quot;Identifier&quot;: name = key.name; break
  case &quot;Literal&quot;: name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion &gt;= 6) {
    if (name === &quot;__proto__&quot; &amp;&amp; kind === &quot;init&quot;) {
      if (propHash.proto) {
        if (refDestructuringErrors &amp;&amp; refDestructuringErrors.doubleProto &lt; 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, &quot;Redefinition of __proto__ property&quot;); }
      }
      propHash.proto = true;
    }
    return
  }
  name = &quot;$&quot; + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === &quot;init&quot;) {
      redefinition = this.strict &amp;&amp; other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, &quot;Redefinition of property&quot;); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.<span class="apidocCodeKeywordSpan">checkPropClash</span>(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkUnreserved" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkUnreserved">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkUnreserved
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator &amp;&amp; name === &quot;yield&quot;)
    { this.raiseRecoverable(start, &quot;Cannot use &apos;yield&apos; as identifier inside a generator&quot;); }
  if (this.inAsync &amp;&amp; name === &quot;await&quot;)
    { this.raiseRecoverable(start, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
  if (this.keywords.test(name))
    { this.raise(start, (&quot;Unexpected keyword &apos;&quot; + name + &quot;&apos;&quot;)); }
  if (this.options.ecmaVersion &lt; 6 &amp;&amp;
    this.input.slice(start, end).indexOf(&quot;\\&quot;) !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync &amp;&amp; name === &quot;await&quot;)
      { this.raiseRecoverable(start, &quot;Cannot use keyword &apos;await&apos; outside an async function&quot;); }
    this.raiseRecoverable(start, (&quot;The keyword &apos;&quot; + name + &quot;&apos; is reserved&quot;));
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
} else {
  for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
    // check for keywords used as local names
    var spec = list[i];

    this.<span class="apidocCodeKeywordSpan">checkUnreserved</span>(spec.local);
    // check if export is defined
    this.checkLocalExport(spec.local);
  }

  node.source = null;
}
this.semicolon();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkVariableExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkVariableExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkVariableExport
        <span class="apidocSignatureSpan">(exports, decls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i &lt; list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
}
// export var|const|let|function|class ...
if (this.shouldParseExportStatement()) {
  node.declaration = this.parseStatement(null);
  if (node.declaration.type === &quot;VariableDeclaration&quot;)
    { this.<span class="apidocCodeKeywordSpan">checkVariableExport</span>(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
} else { // export { x, y as z } [from &apos;...&apos;]
  node.declaration = null;
  node.specifiers = this.parseExportSpecifiers(exports);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkYieldAwaitInDefaultParams" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.checkYieldAwaitInDefaultParams">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>checkYieldAwaitInDefaultParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.yieldPos &amp;&amp; (!this.awaitPos || this.yieldPos &lt; this.awaitPos))
    { this.raise(this.yieldPos, &quot;Yield expression cannot be a default value&quot;); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, &quot;Await expression cannot be a default value&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.<span class="apidocCodeKeywordSpan">checkYieldAwaitInDefaultParams</span>();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.context[this.context.length - 1]
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
var parent = this.<span class="apidocCodeKeywordSpan">curContext</span>();
if (parent === types$1.f_expr || parent === types$1.f_stat)
  { return true }
if (prevType === types.colon &amp;&amp; (parent === types$1.b_stat || parent === types$1.b_expr))
  { return !parent.isExpr }

// The check for `tt.name &amp;&amp; exprAllowed` detects whether we are
// after a `yield` or `of` construct. See the `updateContext` for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curPosition" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.curPosition">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>curPosition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.type = types.eof;
// For tokens that include more information than their type, the value
this.value = null;
// Its start and end offset
this.start = this.end = this.pos;
// And, if locations are used, the {line, column} object
// corresponding to those offsets
this.startLoc = this.endLoc = this.<span class="apidocCodeKeywordSpan">curPosition</span>();

// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null;
this.lastTokStart = this.lastTokEnd = this.pos;

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.scopeStack[this.scopeStack.length - 1]
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.<span class="apidocCodeKeywordSpan
">currentScope</span>()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentThisScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentThisScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentThisScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags &amp; SCOPE_VAR &amp;&amp; !(scope.flags &amp; SCOPE_ARROW)) { return scope }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.<span class="apidocCodeKeywordSpan">currentThisScope</span>().flags
 &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentVarScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.currentVarScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>currentVarScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags &amp; SCOPE_VAR) { return scope }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.<span class="apidocCodeKeywordSpan">currentVarScope</span>().flags
 &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.declareName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.declareName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>declareName
        <span class="apidocSignatureSpan">(name, bindingType, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) &gt; -1 || scope.functions.indexOf(name) &gt; -1 || scope.var.indexOf(name) &gt; -1;
    scope.lexical.push(name);
    if (this.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) &gt; -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) &gt; -1 || scope$2.var.indexOf(name) &gt; -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i &gt;= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) &gt; -1 &amp;&amp; !((scope$3.flags &amp; SCOPE_SIMPLE_CATCH) &amp;&amp; scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) &amp;&amp; scope$3.functions.indexOf(name) &gt; -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule &amp;&amp; (scope$3.flags &amp; SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags &amp; SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, (&quot;Identifier &apos;&quot; + name + &quot;&apos; has already been declared&quot;)); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
    { this.raiseRecoverable(expr.start, (bindingType ? &quot;Binding &quot; : &quot;Assigning to &quot;) + expr.name + &quot; in
 strict mode&quot;); }
  if (checkClashes) {
    if (has(checkClashes, expr.name))
      { this.raiseRecoverable(expr.start, &quot;Argument name clash&quot;); }
    checkClashes[expr.name] = true;
  }
  if (bindingType !== BIND_NONE &amp;&amp; bindingType !== BIND_OUTSIDE) { this.<span class="apidocCodeKeywordSpan">declareName</
span>(expr.name, bindingType, expr.start); }
  break

case &quot;MemberExpression&quot;:
  if (bindingType) { this.raiseRecoverable(expr.start, &quot;Binding member expression&quot;); }
  break

case &quot;ObjectPattern&quot;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eat" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eat">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eat
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.<span class="apidocCodeKeywordSpan">eat</span>(types.semi) &amp;&amp; !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eatContextual" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.eatContextual">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>eatContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.<span class="apidocCodeKeywordSpan">eatContextual</span>(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.enterScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.enterScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>enterScope
        <span class="apidocSignatureSpan">(flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(flags) {
  this.scopeStack.push(new Scope(flags));
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.<span class="apidocCodeKeywordSpan">enterScope</span>(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.exitScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.exitScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>exitScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.scopeStack.pop();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.<span class="apidocCodeKeywordSpan">exitScope</span>();
  if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;)
};

pp$1.parseThrowStatement = function(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expect" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type) {
  this.eat(type) || this.unexpected();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.<span class="apidocCodeKeywordSpan">expect</span>(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expectContextual" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.expectContextual">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>expectContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
  if (this.eat(types.star)) {
    this.<span class="apidocCodeKeywordSpan">expectContextual</span>(&quot;from&quot;);
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNode" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNode">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined
&quot;));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.<span class="apidocCodeKeywordSpan">finishNode</span>(node, &quot;Program&quot;)
};

var loopLabel = {kind: &quot;loop&quot;}, switchLabel = {kind: &quot;switch&quot;};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion &lt; 6 || !this.isContextual(&quot;let&quot;)) { return false }
  skipWhiteSpace.lastIndex = this.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNodeAt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishNodeAt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishNodeAt
        <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.checkExpressionErrors(refDestructuringErrors, true);
  this.yieldPos = oldYieldPos || this.yieldPos;
  this.awaitPos = oldAwaitPos || this.awaitPos;

  if (exprList.length &gt; 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.<span class="apidocCodeKeywordSpan">finishNodeAt</span>(val, &quot;SequenceExpression&quot;, innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }
} else {
  val = this.parseParenExpression();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishOp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishOp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishOp
        <span class="apidocSignatureSpan">(type, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // &apos;/&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.<span class="apidocCodeKeywordSpan">finishOp</span>(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // &apos;%*&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.finishToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>finishToken
        <span class="apidocSignatureSpan">(type, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.<span class="apidocCodeKeywordSpan">finishToken</span>(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.fullCharCodeAtPos" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.fullCharCodeAtPos">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>fullCharCodeAtPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code &lt;&lt; 10) + next - 0x35fdc00
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.<span class="apidocCodeKeywordSpan">fullCharCodeAtPos</span>()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.next();
  return new Token(this)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// When `locations` is on, `loc` properties holding objects with
// `start` and `end` properties in `{line, column}` form (with
// line being 1-based and column 0-based) will be attached to the
// nodes.
locations: false,
// A function can be passed as `onToken` option, which will
// cause Acorn to call that function with object in the same
// format as tokens returned from `tokenizer().<span class="apidocCodeKeywordSpan">getToken</span>()`. Note
// that you are not allowed to call the parser from the
// callback—that will corrupt its internal state.
onToken: null,
// A function can be passed as `onComment` option, which will
// cause Acorn to call that function with `(block, text, start,
// end)` parameters whenever a comment is skipped. `block` is a
// boolean indicating whether this is a block (`/* */`) comment,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getTokenFromCode" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.getTokenFromCode">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>getTokenFromCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // &apos;.&apos;
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // &apos;`&apos;
    if (this.options.ecmaVersion &lt; 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // &apos;0&apos;
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // &apos;0x&apos;, &apos;0X&apos; - hex number
    if (this.options.ecmaVersion &gt;= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // &apos;0o&apos;, &apos;0O&apos; - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // &apos;0b&apos;, &apos;0B&apos; - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // &apos;&quot;&apos;, &quot;&apos;&quot;
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // &apos;/&apos;
    return this.readToken_slash()

  case 37: case 42: // &apos;%*&apos;
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // &apos;|&amp;&apos;
    return this.readToken_pipe_amp(code)

  case 94: // &apos;^&apos;
    return this.readToken_caret()

  case 43: case 45: // &apos;+-&apos;
    return this.readToken_plus_min(code)

  case 60: case 62: // &apos;&lt;&gt;&apos;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &apos;=!&apos;
    return this.readToken_eq_excl(code)

  case 126: // &apos;~&apos;
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &apos;&quot; + codePointToString$1(code) + &quot;&apos;&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }

  return this.<span class="apidocCodeKeywordSpan">getTokenFromCode</span>(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code &lt;&lt; 10) + next - 0x35fdc00
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inGeneratorContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inGeneratorContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inGeneratorContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (var i = this.context.length - 1; i &gt;= 1; i--) {
    var context = this.context[i];
    if (context.token === &quot;function&quot;)
      { return context.generator }
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; prevType !== types.dot) {
    if (this.value === &quot;of&quot; &amp;&amp; !this.exprAllowed ||
        this.value === &quot;yield&quot; &amp;&amp; this.<span class="apidocCodeKeywordSpan">inGeneratorContext</span>())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inNonArrowFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.inNonArrowFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>inNonArrowFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION) &gt; 0 }</pre></li>
    <li>example use<pre class="apidocCodePre">...
var meta = this.parseIdent(true);
if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(types.dot)) {
  node.meta = meta;
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== &quot;target&quot; || containsEsc)
    { this.raiseRecoverable(node.property.start, &quot;The only valid meta property for new is new.target&quot;); }
  if (!this.<span class="apidocCodeKeywordSpan">inNonArrowFunction</span>())
    { this.raiseRecoverable(node.start, &quot;new.target can only be used in functions&quot;); }
  return this.finishNode(node, &quot;MetaProperty&quot;)
}
var startPos = this.start, startLoc = this.startLoc;
node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
if (this.options.ecmaVersion &gt; 10 &amp;&amp; node.callee.type === &quot;Import&quot;) {
  this.raise(node.callee.start, &quot;Cannot use new with import(...)&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  node.id = null;
  if (this.options.ecmaVersion &gt;= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion &gt;= 8) { node.async = false; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement &amp; FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.<span class="apidocCodeKeywordSpan">initFunction</span>(node);
  if (this.options.ecmaVersion &gt;= 9 || this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync) {
    if (this.type === types.star &amp;&amp; (statement &amp; FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initialContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.initialContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>initialContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return [types$1.b_stat]
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null;
this.lastTokStart = this.lastTokEnd = this.pos;

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.<span class="apidocCodeKeywordSpan">initialContext</span>();
this.exprAllowed = true;

// Figure out if it&apos;s a module code.
this.inModule = options.sourceType === &quot;module&quot;;
this.strict = this.inModule || this.strictDirective(this.pos);

// Used to signify the start of a potential arrow function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.insertSemicolon" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.insertSemicolon">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>insertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) &amp;&amp; !this.<span class="apidocCodeKeywordSpan">insertSemicolon</span>()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.invalidStringToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.invalidStringToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>invalidStringToken
        <span class="apidocSignatureSpan">(position, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(position, message) {
  if (this.inTemplateElement &amp;&amp; this.options.ecmaVersion &gt;= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.<span class="apidocCodeKeywordSpan">invalidStringToken</span>(codePos, &quot;Code point out of
 bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.ecmaVersion &lt; 8 || !this.isContextual(&quot;async&quot;))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &amp;&amp;
    this.input.slice(next, next + 8) === &quot;function&quot; &amp;&amp;
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// If the statement does not start with a statement keyword or a
// brace, it&apos;s an ExpressionStatement or LabeledStatement. We
// simply start parsing an expression, and afterwards, if the
// next token is a colon and the expression was a simple
// Identifier node, we switch to interpreting it as a label.
    default:
if (this.<span class="apidocCodeKeywordSpan">isAsyncFunction</span>()) {
  if (context) { this.unexpected(); }
  this.next();
  return this.parseFunctionStatement(node, true, !context)
}

var maybeName = this.value, expr = this.parseExpression();
if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncProp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isAsyncProp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isAsyncProp
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop) {
  return !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp; prop.key.name === &quot;async&quot; &amp;&amp;
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type
.keyword || (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.type === types.star)) &amp;&amp;
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    startLoc = this.startLoc;
  }
  if (!isPattern)
    { isGenerator = this.eat(types.star); }
}
var containsEsc = this.containsEsc;
this.parsePropertyName(prop);
if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.<span
 class="apidocCodeKeywordSpan">isAsyncProp</span>(prop)) {
  isAsync = true;
  isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
  this.parsePropertyName(prop, refDestructuringErrors);
} else {
  isAsync = false;
}
this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isContextual" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isContextual">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name) {
  return this.type === types.name &amp;&amp; this.value === name &amp;&amp; !this.containsEsc
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp.isContextual = function(name) {
  return this.type === types.name &amp;&amp; this.value === name &amp;&amp; !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.<span class="apidocCodeKeywordSpan">isContextual</span>(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isDirectiveCandidate" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isDirectiveCandidate">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isDirectiveCandidate
        <span class="apidocSignatureSpan">(statement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(statement) {
  return (
    statement.type === &quot;ExpressionStatement&quot; &amp;&amp;
    statement.expression.type === &quot;Literal&quot; &amp;&amp;
    typeof statement.expression.value === &quot;string&quot; &amp;&amp;
    // Reject parenthesized strings.
    (this.input[statement.start] === &quot;\&quot;&quot; || this.input[statement.start] === &quot;&apos;&quot;)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    nodes.push(this.finishNode(node$2, &quot;ImportSpecifier&quot;));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i &lt; statements.length &amp;&amp; this.<span class="apidocCodeKeywordSpan">isDirectiveCandidate</span>(statements
[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === &quot;ExpressionStatement&quot; &amp;&amp;
    statement.expression.type === &quot;Literal&quot; &amp;&amp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isLet" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isLet">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isLet
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(context) {
  if (this.options.ecmaVersion &lt; 6 || !this.isContextual(&quot;let&quot;)) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // &apos;[&apos;
  if (context) { return false }

  if (nextCh === 123) { return true } // &apos;{&apos;
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function(context, topLevel, exports) {
var starttype = this.type, node = this.startNode(), kind;

if (this.<span class="apidocCodeKeywordSpan">isLet</span>(context)) {
  starttype = types._var;
  kind = &quot;let&quot;;
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleAssignTarget" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleAssignTarget">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleAssignTarget
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(expr) {
  if (expr.type === &quot;ParenthesizedExpression&quot;)
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === &quot;Identifier&quot; || expr.type === &quot;MemberExpression&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    { this.raise(this.yieldPos, &quot;Yield expression cannot be a default value&quot;); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, &quot;Await expression cannot be a default value&quot;); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === &quot;ParenthesizedExpression&quot;)
    { return this.<span class="apidocCodeKeywordSpan">isSimpleAssignTarget</span>(expr.expression) }
  return expr.type === &quot;Identifier&quot; || expr.type === &quot;MemberExpression&quot;
};

var pp$1 = Parser.prototype;

// ### Statement parsing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleParamList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.isSimpleParamList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>isSimpleParamList
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(params) {
  for (var i = 0, list = params; i &lt; list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== &quot;Identifier&quot;) { return false
  } }
  return true
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var oldStrict = this.strict, useStrict = false;

if (isExpression) {
  node.body = this.parseMaybeAssign();
  node.expression = true;
  this.checkParams(node, false);
} else {
  var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.<span class="apidocCodeKeywordSpan">isSimpleParamList</span>(
node.params);
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end);
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (useStrict &amp;&amp; nonSimple)
      { this.raiseRecoverable(node.start, &quot;Illegal &apos;use strict&apos; directive in function with non-simple parameter list
&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.next" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.next">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.<span class="apidocCodeKeywordSpan">next</span>();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.nextToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.nextToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.<span class="apidocCodeKeywordSpan">nextToken</span>();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parse" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseArrowExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseArrowExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseArrowExpression
        <span class="apidocSignatureSpan">(node, params, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, &quot;ArrowFunctionExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.checkPatternErrors(refDestructuringErrors, false);
  this.checkYieldAwaitInDefaultParams();
  if (this.awaitIdentPos &gt; 0)
    { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.<span class="apidocCodeKeywordSpan">parseArrowExpression</span>(this.startNodeAt(startPos, startLoc), exprList, true
)
}
this.checkExpressionErrors(refDestructuringErrors, true);
this.yieldPos = oldYieldPos || this.yieldPos;
this.awaitPos = oldAwaitPos || this.awaitPos;
this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
var node$1 = this.startNodeAt(startPos, startLoc);
node$1.callee = base;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseAwait" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseAwait">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseAwait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, &quot;AwaitExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual(&quot;await&quot;) &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction
))) {
    expr = this.<span class="apidocCodeKeywordSpan">parseAwait</span>();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingAtom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (this.options.ecmaVersion &gt;= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, &quot;ArrayPattern&quot;)

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.next();
node.block = this.parseBlock();
node.handler = null;
if (this.type === types._catch) {
  var clause = this.startNode();
  this.next();
  if (this.eat(types.parenL)) {
    clause.param = this.<span class="apidocCodeKeywordSpan">parseBindingAtom</span>();
    var simple = clause.param.type === &quot;Identifier&quot;;
    this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
    this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
    this.expect(types.parenR);
  } else {
    if (this.options.ecmaVersion &lt; 10) { this.unexpected(); }
    clause.param = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingList
        <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty &amp;&amp; this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.<span class="apidocCodeKeywordSpan">parseBindingList</span>(types.parenR, false, this.options.ecmaVersion &
gt;= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingListItem" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBindingListItem">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBindingListItem
        <span class="apidocSignatureSpan">(param)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(param) {
  return param
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
else { this.expect(types.comma); }
if (allowEmpty &amp;&amp; this.type === types.comma) {
  elts.push(null);
} else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
  break
} else if (this.type === types.ellipsis) {
  var rest = this.parseRestBinding();
  this.<span class="apidocCodeKeywordSpan">parseBindingListItem</span>(rest);
  elts.push(rest);
  if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
  this.expect(close);
  break
} else {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBlock" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBlock">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBlock
        <span class="apidocSignatureSpan">(createNewLexicalScope, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, &quot;BlockStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.<span class="apidocCodeKeywordSpan">parseBlock</span>(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBreakContinueStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseBreakContinueStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseBreakContinueStatement
        <span class="apidocSignatureSpan">(node, keyword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, keyword) {
  var isBreak = keyword === &quot;break&quot;;
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i &lt; this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &amp;&amp; (isBreak || lab.kind === &quot;loop&quot;)) { break }
      if (node.label &amp;&amp; isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, &quot;Unsyntactic &quot; + keyword); }
  return this.finishNode(node, isBreak ? &quot;BreakStatement&quot; : &quot;ContinueStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.<span class="apidocCodeKeywordSpan">parseBreakContinueStatement</span>(node
, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClass" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClass">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClass
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === &quot;MethodDefinition&quot; &amp;&amp; element.kind === &quot;constructor&quot;) {
        if (hadConstructor) { this.raise(element.start, &quot;Duplicate constructor in the same class&quot;); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, &quot;ClassBody&quot;);
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? &quot;ClassDeclaration&quot; : &quot;ClassExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseClass</span>(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassElement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassElement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassElement
        <span class="apidocSignatureSpan">(constructorAllowsSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL &amp;&amp; (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, &quot;Identifier&quot;);
    return false
  };

  method.kind = &quot;method&quot;;
  method.static = tryContextual(&quot;static&quot;);
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; tryContextual(&quot;async&quot;, true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    } else if (tryContextual(&quot;get&quot;)) {
      method.kind = &quot;get&quot;;
    } else if (tryContextual(&quot;set&quot;)) {
      method.kind = &quot;set&quot;;
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor&quot; ||
      key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
    if (method.kind !== &quot;method&quot;) { this.raise(key.start, &quot;Constructor can&apos;t have get/set modifier&quot;); }
    if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
    if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
    method.kind = &quot;constructor&quot;;
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot;) {
    this.raise(key.start, &quot;Classes may not have a static property named prototype&quot;);
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === &quot;get&quot; &amp;&amp; method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, &quot;getter should have no params&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
    { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
  return method
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.parseClassId(node, isStatement);
this.parseClassSuper(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.<span class="apidocCodeKeywordSpan">parseClassElement</span>(node.superClass !== null);
  if (element) {
    classBody.body.push(element);
    if (element.type === &quot;MethodDefinition&quot; &amp;&amp; element.kind === &quot;constructor&quot;) {
      if (hadConstructor) { this.raise(element.start, &quot;Duplicate constructor in the same class&quot;); }
      hadConstructor = true;
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassId" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassId">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassId
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.next();

// ecma-262 14.6 Class Definitions
// A class definition is always strict mode code.
var oldStrict = this.strict;
this.strict = true;

this.<span class="apidocCodeKeywordSpan">parseClassId</span>(node, isStatement);
this.parseClassSuper(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.parseClassElement(node.superClass !== null);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassMethod" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassMethod">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassMethod
        <span class="apidocSignatureSpan">(method, isGenerator, isAsync, allowsDirectSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, &quot;MethodDefinition&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
  if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
  method.kind = &quot;constructor&quot;;
  allowsDirectSuper = constructorAllowsSuper;
} else if (method.static &amp;&amp; key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;prototype&quot;) {
  this.raise(key.start, &quot;Classes may not have a static property named prototype&quot;);
}
this.<span class="apidocCodeKeywordSpan">parseClassMethod</span>(method, isGenerator, isAsync, allowsDirectSuper);
if (method.kind === &quot;get&quot; &amp;&amp; method.value.params.length !== 0)
  { this.raiseRecoverable(method.value.start, &quot;getter should have no params&quot;); }
if (method.kind === &quot;set&quot; &amp;&amp; method.value.params.length !== 1)
  { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
  { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
return method
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassSuper" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseClassSuper">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseClassSuper
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// ecma-262 14.6 Class Definitions
// A class definition is always strict mode code.
var oldStrict = this.strict;
this.strict = true;

this.parseClassId(node, isStatement);
this.<span class="apidocCodeKeywordSpan">parseClassSuper</span>(node);
var classBody = this.startNode();
var hadConstructor = false;
classBody.body = [];
this.expect(types.braceL);
while (!this.eat(types.braceR)) {
  var element = this.parseClassElement(node.superClass !== null);
  if (element) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDebuggerStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDebuggerStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDebuggerStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, &quot;DebuggerStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.<span class="apidocCodeKeywordSpan">parseDebuggerStatement</span>(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDoStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDoStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDoStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.<span class="apidocCodeKeywordSpan">parseDoStatement</span>(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDynamicImport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseDynamicImport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseDynamicImport
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  this.next();
  if (this.type !== types.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, &quot;Import&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return this.parseNew()

case types.backQuote:
  return this.parseTemplate()

case types._import:
  if (this.options.ecmaVersion &gt; 10) {
    return this.<span class="apidocCodeKeywordSpan">parseDynamicImport</span>()
  } else {
    return this.unexpected()
  }

default:
  this.unexpected();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseEmptyStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseEmptyStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseEmptyStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  return this.finishNode(node, &quot;EmptyStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.<span class="apidocCodeKeywordSpan">parseEmptyStatement</span>(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 40) // &apos;(&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExport
        <span class="apidocSignatureSpan">(node, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
  if (this.eat(types.star)) {
    this.expectContextual(&quot;from&quot;);
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, &quot;nullableID&quot;);
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === &quot;VariableDeclaration&quot;)
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from &apos;...&apos;]
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual(&quot;from&quot;)) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, &quot;ExportNamedDeclaration&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
    if (!this.inModule)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos
;&quot;); }
  }
  return starttype === types._import ? this.parseImport(node) : this.<span class="apidocCodeKeywordSpan">parseExport</span>(node
, exports)

  // If the statement does not start with a statement keyword or a
  // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExportSpecifiers" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExportSpecifiers">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExportSpecifiers
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from &apos;...&apos;]
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual(&quot;as&quot;) ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, &quot;ExportSpecifier&quot;));
  }
  return nodes
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    { this.checkVariableExport(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
} else { // export { x, y as z } [from &apos;...&apos;]
  node.declaration = null;
  node.specifiers = this.<span class="apidocCodeKeywordSpan">parseExportSpecifiers</span>(exports);
  if (this.eatContextual(&quot;from&quot;)) {
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
  } else {
    for (var i = 0, list = node.specifiers; i &lt; list.length; i += 1) {
      // check for keywords used as local names
      var spec = list[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprAtom
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, &quot;&apos;super&apos; keyword outside a method&quot;); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL &amp;&amp; !this.allowDirectSuper)
      { this.raise(node.start, &quot;super() call outside constructor of a subclass&quot;); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot &amp;&amp; this.type !== types.bracketL &amp;&amp; this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, &quot;Super&quot;)

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, &quot;ThisExpression&quot;)

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; !containsEsc &amp;&amp; id.name === &quot;async&quot; &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types._function
))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow &amp;&amp; !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion &gt;= 8 &amp;&amp; id.name === &quot;async&quot; &amp;&amp; this.type === types.name &amp;&amp; !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, &quot;Literal&quot;)

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind &lt; 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, &quot;ArrayExpression&quot;)

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion &gt; 10) {
      return this.parseDynamicImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  pp$1.parseExport = function(node, exports) {
this.next();
// export * from &apos;...&apos;
if (this.eat(types.star)) {
  this.expectContextual(&quot;from&quot;);
  if (this.type !== types.string) { this.unexpected(); }
  node.source = this.<span class="apidocCodeKeywordSpan">parseExprAtom</span>();
  this.semicolon();
  return this.finishNode(node, &quot;ExportAllDeclaration&quot;)
}
if (this.eat(types._default)) { // export default ...
  this.checkExport(exports, &quot;default&quot;, this.lastTokStart);
  var isAsync;
  if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprList
        <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty &amp;&amp; this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors &amp;&amp; this.type === types.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (computed) { this.expect(types.bracketR); }
  base = this.finishNode(node, &quot;MemberExpression&quot;);
} else if (!noCalls &amp;&amp; this.eat(types.parenL)) {
  var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos
 = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  var exprList = this.<span class="apidocCodeKeywordSpan">parseExprList</span>(types.parenR, this.options.ecmaVersion &gt;= 8 &amp
;&amp; base.type !== &quot;Import&quot;, false, refDestructuringErrors);
  if (maybeAsyncArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
    this.checkPatternErrors(refDestructuringErrors, false);
    this.checkYieldAwaitInDefaultParams();
    if (this.awaitIdentPos &gt; 0)
      { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOp
        <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null &amp;&amp; (!noIn || this.type !== types._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.<span class="apidocCodeKeywordSpan
">parseExprOp</span>(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOps" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprOps">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprOps
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.parseExprOp(expr, startPos, startLoc, -
1, noIn)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.<span class="apidocCodeKeywordSpan">parseExprOps</span>(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprSubscripts" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExprSubscripts">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExprSubscripts
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === &quot;ArrowFunctionExpression&quot; &amp;&amp; this.input.slice(this.lastTokStart, this.lastTokEnd) !== &quot;)&quot;;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors &amp;&amp; result.type === &quot;MemberExpression&quot;) {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.<span class="apidocCodeKeywordSpan">parseExprSubscripts</span>() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from &apos;...&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpression
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, &quot;SequenceExpression&quot;)
  }
  return expr
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.<span class="apidocCodeKeywordSpan">parseExpression</span>()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpressionStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseExpressionStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseExpressionStatement
        <span class="apidocSignatureSpan">(node, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, &quot;ExpressionStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    case types._export:
    case types._import:
if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 40) // &apos;(&apos;
    { return this.<span class="apidocCodeKeywordSpan">parseExpressionStatement</span>(node, this.parseExpression()) }
}

if (!this.options.allowImportExportEverywhere) {
  if (!topLevel)
    { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
  if (!this.inModule)
    { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos;&
quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFor" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFor">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFor
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, &quot;ForStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.next();
var awaitAt = (this.options.ecmaVersion &gt;= 9 &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction
)) &amp;&amp; this.eatContextual(&quot;await&quot;)) ? this.lastTokStart : -1;
this.labels.push(loopLabel);
this.enterScope(0);
this.expect(types.parenL);
if (this.type === types.semi) {
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.<span class="apidocCodeKeywordSpan">parseFor</span>(node, null)
}
var isLet = this.isLet();
if (this.type === types._var || this.type === types._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
  this.next();
  this.parseVar(init$1, true, kind);
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForIn" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForIn">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForIn
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === &quot;VariableDeclaration&quot; &amp;&amp;
    init.declarations[0].init != null &amp;&amp;
    (
      !isForIn ||
      this.options.ecmaVersion &lt; 8 ||
      this.strict ||
      init.kind !== &quot;var&quot; ||
      init.declarations[0].id.type !== &quot;Identifier&quot;
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? &quot;for-in&quot; : &quot;for-of&quot;) + &quot; loop variable declaration may not have an initializer&quot;)
    );
  } else if (init.type === &quot;AssignmentPattern&quot;) {
    this.raise(init.start, &quot;Invalid left-hand side in for-loop&quot;);
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
  if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init
$1.declarations.length === 1) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    return this.<span class="apidocCodeKeywordSpan">parseForIn</span>(node, init$1)
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init$1)
}
var refDestructuringErrors = new DestructuringErrors;
var init = this.parseExpression(true, refDestructuringErrors);
if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseForStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseForStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion &gt;= 9 &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction)) &amp;&amp;
this.eatContextual(&quot;await&quot;)) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, &quot;VariableDeclaration&quot;);
    if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init$1.declarations.length ===
1) {
      if (this.options.ecmaVersion &gt;= 9) {
        if (this.type === types._in) {
          if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt &gt; -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case types._debugger: return this.parseDebuggerStatement(node)
case types._do: return this.parseDoStatement(node)
case types._for: return this.<span class="apidocCodeKeywordSpan">parseForStatement</span>(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunction
        <span class="apidocSignatureSpan">(node, statement, allowExpressionBody, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 9 || this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync) {
    if (this.type === types.star &amp;&amp; (statement &amp; FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  if (statement &amp; FUNC_STATEMENT) {
    node.id = (statement &amp; FUNC_NULLABLE_ID) &amp;&amp; this.type !== types.name ? null : this.parseIdent();
    if (node.id &amp;&amp; !(statement &amp; FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL
 : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.<span class="apidocCodeKeywordSpan">parseFunction</span>(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT
), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(&quot;if&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionBody" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionBody">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionBody
        <span class="apidocSignatureSpan">(node, isArrowFunction, isMethod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction &amp;&amp; this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict &amp;&amp; nonSimple)
        { this.raiseRecoverable(node.start, &quot;Illegal &apos;use strict&apos; directive in function with non-simple parameter list&quot;); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict &amp;&amp; !useStrict &amp;&amp; !isArrowFunction &amp;&amp; !isMethod &amp;&amp; this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn&apos;t a forbidden identifier in strict mode, e.g. &apos;eval&apos;
  if (this.strict &amp;&amp; node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.<span class="apidocCodeKeywordSpan">parseFunctionBody</span>(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionParams" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionParams">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionParams
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement &amp; FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.<span class="apidocCodeKeywordSpan">parseFunctionParams</span>(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement &amp; FUNC_STATEMENT) ? &quot;FunctionDeclaration&quot; : &quot;FunctionExpression&quot
;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseFunctionStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseFunctionStatement
        <span class="apidocSignatureSpan">(node, isAsync, declarationPosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._do: return this.parseDoStatement(node)
case types._for: return this.parseForStatement(node)
case types._function:
  // Function as sole body of either an if statement or a labeled statement
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseFunctionStatement</span>(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIdent" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIdent">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIdent
        <span class="apidocSignatureSpan">(liberal, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === &quot;class&quot; || node.name === &quot;function&quot;) &amp;&amp;
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, &quot;Identifier&quot;);
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === &quot;await&quot; &amp;&amp; !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  pp$1.parseBreakContinueStatement = function(node, keyword) {
var isBreak = keyword === &quot;break&quot;;
this.next();
if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
else if (this.type !== types.name) { this.unexpected(); }
else {
  node.label = this.<span class="apidocCodeKeywordSpan">parseIdent</span>();
  this.semicolon();
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0;
for (; i &lt; this.labels.length; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIfStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseIfStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseIfStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(&quot;if&quot;);
  node.alternate = this.eat(types._else) ? this.parseStatement(&quot;if&quot;) : null;
  return this.finishNode(node, &quot;IfStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // works, but not when it is part of a labeled statement that is the sole
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.<span class="apidocCodeKeywordSpan">parseIfStatement</span>(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImport" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImport">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImport
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  // import &apos;...&apos;
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual(&quot;from&quot;);
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
    if (!this.inModule)
      { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos
;&quot;); }
  }
  return starttype === types._import ? this.<span class="apidocCodeKeywordSpan">parseImport</span>(node) : this.parseExport(node
, exports)

  // If the statement does not start with a statement keyword or a
  // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImportSpecifiers" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseImportSpecifiers">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseImportSpecifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from &apos;...&apos;
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, &quot;ImportDefaultSpecifier&quot;));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual(&quot;as&quot;);
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, &quot;ImportNamespaceSpecifier&quot;));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual(&quot;as&quot;)) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, &quot;ImportSpecifier&quot;));
  }
  return nodes
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$1.parseImport = function(node) {
  this.next();
  // import &apos;...&apos;
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.<span class="apidocCodeKeywordSpan">parseImportSpecifiers</span>();
    this.expectContextual(&quot;from&quot;);
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, &quot;ImportDeclaration&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLabeledStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLabeledStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLabeledStatement
        <span class="apidocSignatureSpan">(node, maybeName, expr, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 &lt; list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, &quot;Label &apos;&quot; + maybeName + &quot;&apos; is already declared&quot;);
  } }
  var kind = this.type.isLoop ? &quot;loop&quot; : this.type === types._switch ? &quot;switch&quot; : null;
  for (var i = this.labels.length - 1; i &gt;= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf(&quot;label&quot;) === -1 ? context + &quot;label&quot; : context : &quot;label&quot;);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, &quot;LabeledStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
      { return this.<span class="apidocCodeKeywordSpan">parseLabeledStatement</span>(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === &quot;break&quot;;
  this.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLiteral" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseLiteral">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseLiteral
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, &quot;Literal&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
    }
  }
  return id

case types.regexp:
  var value = this.value;
  node = this.<span class="apidocCodeKeywordSpan">parseLiteral</span>(value.value);
  node.regex = {pattern: value.pattern, flags: value.flags};
  return node

case types.num: case types.string:
  return this.parseLiteral(this.value)

case types._null: case types._true: case types._false:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeAssign" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeAssign">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeAssign
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual(&quot;yield&quot;)) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn&apos;t that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -
1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;AssignmentExpression&quot;)
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign &gt; -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma &gt; -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign &gt; -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      init.start,
      ((isForIn ? &quot;for-in&quot; : &quot;for-of&quot;) + &quot; loop variable declaration may not have an initializer&quot;)
    );
  } else if (init.type === &quot;AssignmentPattern&quot;) {
    this.raise(init.start, &quot;Invalid left-hand side in for-loop&quot;);
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.<span class="apidocCodeKeywordSpan">parseMaybeAssign</span>();
  this.expect(types.parenR);
  node.body = this.parseStatement(&quot;for&quot;);
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? &quot;ForInStatement&quot; : &quot;ForOfStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeConditional" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeConditional">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeConditional
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, &quot;ConditionalExpression&quot;)
  }
  return expr
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  refDestructuringErrors = new DestructuringErrors;
  ownDestructuringErrors = true;
}

var startPos = this.start, startLoc = this.startLoc;
if (this.type === types.parenL || this.type === types.name)
  { this.potentialArrowAt = this.start; }
var left = this.<span class="apidocCodeKeywordSpan">parseMaybeConditional</span>(noIn, refDestructuringErrors);
if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
if (this.type.isAssign) {
  var node = this.startNodeAt(startPos, startLoc);
  node.operator = this.value;
  node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
  if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
  refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeDefault" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeDefault">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeDefault
        <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion &lt; 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, &quot;AssignmentPattern&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
      this.expect(close);
      break
    } else {
      var elem = this.<span class="apidocCodeKeywordSpan">parseMaybeDefault</span>(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeUnary" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMaybeUnary">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMaybeUnary
        <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual(&quot;await&quot;) &amp;&amp; (this.inAsync || (!this.inFunction &amp;&amp; this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict &amp;&amp; node.operator === &quot;delete&quot; &amp;&amp;
             node.argument.type === &quot;Identifier&quot;)
      { this.raiseRecoverable(node.start, &quot;Deleting local variable in strict mode&quot;); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? &quot;UpdateExpression&quot; : &quot;UnaryExpression&quot;);
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix &amp;&amp; !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, &quot;UpdateExpression&quot;);
    }
  }

  if (!sawUnary &amp;&amp; this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), &quot;**&quot;, false) }
  else
    { return expr }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.<span class="apidocCodeKeywordSpan">parseMaybeUnary</span>(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos &amp;&amp; expr.type === &quot;ArrowFunctionExpression&quot; ? expr : this.parseExprOp(expr, startPos
, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMethod" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseMethod">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseMethod
        <span class="apidocSignatureSpan">(isGenerator, isAsync, allowDirectSuper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion &gt;= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion &gt;= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion &gt;= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, &quot;FunctionExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    { this.raiseRecoverable(method.value.start, &quot;setter should have exactly one param&quot;); }
  if (method.kind === &quot;set&quot; &amp;&amp; method.value.params[0].type === &quot;RestElement&quot;)
    { this.raiseRecoverable(method.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.<span class="apidocCodeKeywordSpan">parseMethod</span>(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, &quot;MethodDefinition&quot;)
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseNew" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseNew">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseNew
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== &quot;target&quot; || containsEsc)
      { this.raiseRecoverable(node.property.start, &quot;The only valid meta property for new is new.target&quot;); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, &quot;new.target can only be used in functions&quot;); }
    return this.finishNode(node, &quot;MetaProperty&quot;)
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; node.callee.type === &quot;Import&quot;) {
    this.raise(node.callee.start, &quot;Cannot use new with import(...)&quot;);
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion &gt;= 8 &amp;&amp; node.callee.type
 !== &quot;Import&quot;, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, &quot;NewExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  return this.parseFunction(node, 0)

case types._class:
  return this.parseClass(this.startNode(), false)

case types._new:
  return this.<span class="apidocCodeKeywordSpan">parseNew</span>()

case types.backQuote:
  return this.parseTemplate()

case types._import:
  if (this.options.ecmaVersion &gt; 10) {
    return this.parseDynamicImport()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseObj" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseObj">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseObj
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, &quot;ArrayPattern&quot;)

    case types.braceL:
      return this.<span class="apidocCodeKeywordSpan">parseObj</span>(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenAndDistinguishExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenAndDistinguishExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenAndDistinguishExpression
        <span class="apidocSignatureSpan">(canBeArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion &gt;= 8;
  if (this.options.ecmaVersion &gt;= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma &amp;&amp; this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length &gt; 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, &quot;SequenceExpression&quot;, innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, &quot;ParenthesizedExpression&quot;)
  } else {
    return val
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  node = this.startNode();
  node.value = this.type === types._null ? null : this.type === types._true;
  node.raw = this.type.keyword;
  this.next();
  return this.finishNode(node, &quot;Literal&quot;)

case types.parenL:
  var start = this.start, expr = this.<span class="apidocCodeKeywordSpan">parseParenAndDistinguishExpression</span>(canBeArrow);
  if (refDestructuringErrors) {
    if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
      { refDestructuringErrors.parenthesizedAssign = start; }
    if (refDestructuringErrors.parenthesizedBind &lt; 0)
      { refDestructuringErrors.parenthesizedBind = start; }
  }
  return expr
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenArrowList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenArrowList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenArrowList
        <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.expect(types.parenR);

if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
  this.checkPatternErrors(refDestructuringErrors, false);
  this.checkYieldAwaitInDefaultParams();
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  return this.<span class="apidocCodeKeywordSpan">parseParenArrowList</span>(startPos, startLoc, exprList)
}

if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
if (spreadStart) { this.unexpected(spreadStart); }
this.checkExpressionErrors(refDestructuringErrors, true);
this.yieldPos = oldYieldPos || this.yieldPos;
this.awaitPos = oldAwaitPos || this.awaitPos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;do&quot;);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.<span class="apidocCodeKeywordSpan">parseParenExpression</span>();
  if (this.options.ecmaVersion &gt;= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, &quot;DoWhileStatement&quot;)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenItem" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseParenItem">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseParenItem
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(item) {
  return item
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
while (this.type !== types.parenR) {
  first ? first = false : this.expect(types.comma);
  if (allowTrailingComma &amp;&amp; this.afterTrailingComma(types.parenR, true)) {
    lastIsComma = true;
    break
  } else if (this.type === types.ellipsis) {
    spreadStart = this.start;
    exprList.push(this.<span class="apidocCodeKeywordSpan">parseParenItem</span>(this.parseRestBinding()));
    if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
    break
  } else {
    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
  }
}
var innerEndPos = this.start, innerEndLoc = this.startLoc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseProperty" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseProperty">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseProperty
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;);
      }
      return this.finishNode(prop, &quot;RestElement&quot;)
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind &lt; 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma &amp;&amp; refDestructuringErrors &amp;&amp; refDestructuringErrors.trailingComma &lt; 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, &quot;SpreadElement&quot;)
  }
  if (this.options.ecmaVersion &gt;= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, &quot;Property&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.<span class="apidocCodeKeywordSpan">parseProperty</span>(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? &quot;ObjectPattern&quot; : &quot;ObjectExpression&quot;)
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyName
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop) {
  if (this.options.ecmaVersion &gt;= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.
allowReserved !== &quot;never&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
  } else if (tryContextual(&quot;get&quot;)) {
    method.kind = &quot;get&quot;;
  } else if (tryContextual(&quot;set&quot;)) {
    method.kind = &quot;set&quot;;
  }
}
if (!method.key) { this.<span class="apidocCodeKeywordSpan">parsePropertyName</span>(method); }
var key = method.key;
var allowsDirectSuper = false;
if (!method.computed &amp;&amp; !method.static &amp;&amp; (key.type === &quot;Identifier&quot; &amp;&amp; key.name === &quot;constructor
&quot; ||
    key.type === &quot;Literal&quot; &amp;&amp; key.value === &quot;constructor&quot;)) {
  if (method.kind !== &quot;method&quot;) { this.raise(key.start, &quot;Constructor can&apos;t have get/set modifier&quot;); }
  if (isGenerator) { this.raise(key.start, &quot;Constructor can&apos;t be a generator&quot;); }
  if (isAsync) { this.raise(key.start, &quot;Constructor can&apos;t be an async method&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parsePropertyValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parsePropertyValue
        <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors
);
    prop.kind = &quot;init&quot;;
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = &quot;init&quot;;
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern &amp;&amp; !containsEsc &amp;&amp;
             this.options.ecmaVersion &gt;= 5 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot; &amp;&amp;
             (prop.key.name === &quot;get&quot; || prop.key.name === &quot;set&quot;) &amp;&amp;
             (this.type !== types.comma &amp;&amp; this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === &quot;get&quot; ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === &quot;get&quot;)
        { this.raiseRecoverable(start, &quot;getter should have no params&quot;); }
      else
        { this.raiseRecoverable(start, &quot;setter should have exactly one param&quot;); }
    } else {
      if (prop.kind === &quot;set&quot; &amp;&amp; prop.value.params[0].type === &quot;RestElement&quot;)
        { this.raiseRecoverable(prop.value.params[0].start, &quot;Setter cannot use rest params&quot;); }
    }
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === &quot;Identifier&quot;) {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === &quot;await&quot; &amp;&amp; !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = &quot;init&quot;;
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign &lt; 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (!isPattern &amp;&amp; !containsEsc &amp;&amp; this.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; this.isAsyncProp
(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion &gt;= 9 &amp;&amp; this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.<span class="apidocCodeKeywordSpan">parsePropertyValue</span>(prop, isPattern, isGenerator, isAsync, startPos, startLoc,
refDestructuringErrors, containsEsc);
  return this.finishNode(prop, &quot;Property&quot;)
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc
) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === types.colon)
    { this.unexpected(); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseRestBinding" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseRestBinding">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseRestBinding
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 &amp;&amp; this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, &quot;RestElement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (first) { first = false; }
else { this.expect(types.comma); }
if (allowEmpty &amp;&amp; this.type === types.comma) {
  elts.push(null);
} else if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) {
  break
} else if (this.type === types.ellipsis) {
  var rest = this.<span class="apidocCodeKeywordSpan">parseRestBinding</span>();
  this.parseBindingListItem(rest);
  elts.push(rest);
  if (this.type === types.comma) { this.raise(this.start, &quot;Comma is not permitted after the rest element&quot;); }
  this.expect(close);
  break
} else {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseReturnStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseReturnStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseReturnStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  if (!this.inFunction &amp;&amp; !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, &quot;&apos;return&apos; outside of function&quot;); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, &quot;ReturnStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // body of an if statement.
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.<span class="apidocCodeKeywordSpan">parseReturnStatement</span>(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSpread" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSpread">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSpread
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, &quot;SpreadElement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    if (allowTrailingComma &amp;&amp; this.afterTrailingComma(close)) { break }
  } else { first = false; }

  var elt = (void 0);
  if (allowEmpty &amp;&amp; this.type === types.comma)
    { elt = null; }
  else if (this.type === types.ellipsis) {
    elt = this.<span class="apidocCodeKeywordSpan">parseSpread</span>(refDestructuringErrors);
    if (refDestructuringErrors &amp;&amp; this.type === types.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
      { refDestructuringErrors.trailingComma = this.start; }
  } else {
    elt = this.parseMaybeAssign(false, refDestructuringErrors);
  }
  elts.push(elt);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseStatement
        <span class="apidocSignatureSpan">(context, topLevel, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = &quot;let&quot;;
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.options.ecmaVersion &gt;= 6) { this.unexpected
(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // &apos;(&apos;
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may only appear at the top level&quot;); }
      if (!this.inModule)
        { this.raise(this.start, &quot;&apos;import&apos; and &apos;export&apos; may appear only with &apos;sourceType: module&apos;&quot;); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it&apos;s an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name &amp;&amp; expr.type === &quot;Identifier&quot; &amp;&amp; this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.<span class="apidocCodeKeywordSpan">parseStatement</span>(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscript" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscript">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscript
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls, maybeAsyncArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== &quot;never&quot;);
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, &quot;MemberExpression&quot;);
  } else if (!noCalls &amp;&amp; this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos
 = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type !== &quot;Import&quot;, false, refDestructuringErrors
);
    if (maybeAsyncArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos &gt; 0)
        { this.raise(this.awaitIdentPos, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (node$1.callee.type === &quot;Import&quot;) {
      if (node$1.arguments.length !== 1) {
        this.raise(node$1.start, &quot;import() requires exactly one argument&quot;);
      }

      var importArg = node$1.arguments[0];
      if (importArg &amp;&amp; importArg.type === &quot;SpreadElement&quot;) {
        this.raise(importArg.start, &quot;... is not allowed in import()&quot;);
      }
    }
    base = this.finishNode(node$1, &quot;CallExpression&quot;);
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, &quot;TaggedTemplateExpression&quot;);
  }
  return base
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === &quot;Identifier&quot; &amp;&amp; base.name === &
quot;async&quot; &amp;&amp;
      this.lastTokEnd === base.end &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.input.slice(base.start, base.end) === &
quot;async&quot;;
  while (true) {
    var element = this.<span class="apidocCodeKeywordSpan">parseSubscript</span>(base, startPos, startLoc, noCalls, maybeAsyncArrow
);
    if (element === base || element.type === &quot;ArrowFunctionExpression&quot;) { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscripts" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSubscripts">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSubscripts
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === &quot;Identifier&quot; &amp;&amp; base.name === &quot;async&quot; &amp;&amp;
      this.lastTokEnd === base.end &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.input.slice(base.start, base.end) === &quot;async&quot;;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === &quot;ArrowFunctionExpression&quot;) { return element }
    base = element;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === &quot;ArrowFunctionExpression&quot; &amp;&amp; this.input.slice(this.lastTokStart, this
.lastTokEnd) !== &quot;)&quot;;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.<span class="apidocCodeKeywordSpan">parseSubscripts</span>(expr, startPos, startLoc);
  if (refDestructuringErrors &amp;&amp; result.type === &quot;MemberExpression&quot;) {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSwitchStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseSwitchStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseSwitchStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, &quot;Multiple default clauses&quot;); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, &quot;SwitchCase&quot;); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, &quot;SwitchStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if ((context &amp;&amp; (this.strict || context !== &quot;if&quot; &amp;&amp; context !== &quot;label&quot;)) &amp;&amp; this.
options.ecmaVersion &gt;= 6) { this.unexpected(); }
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.<span class="apidocCodeKeywordSpan">parseSwitchStatement</span>(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplate" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplate">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplate
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, &quot;Unterminated template literal&quot;); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, &quot;TemplateLiteral&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        this.raise(importArg.start, &quot;... is not allowed in import()&quot;);
      }
    }
    base = this.finishNode(node$1, &quot;CallExpression&quot;);
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.<span class="apidocCodeKeywordSpan">parseTemplate</span>({isTagged: true});
    base = this.finishNode(node$2, &quot;TaggedTemplateExpression&quot;);
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplateElement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTemplateElement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTemplateElement
        <span class="apidocSignatureSpan">(ref)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, &quot;Bad escape sequence in untagged template literal&quot;);
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, &quot;\n&quot;),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, &quot;TemplateElement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$3.parseTemplate = function(ref) {
if ( ref === void 0 ) ref = {};
var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

var node = this.startNode();
this.next();
node.expressions = [];
var curElt = this.<span class="apidocCodeKeywordSpan">parseTemplateElement</span>({isTagged: isTagged});
node.quasis = [curElt];
while (!curElt.tail) {
  if (this.type === types.eof) { this.raise(this.pos, &quot;Unterminated template literal&quot;); }
  this.expect(types.dollarBraceL);
  node.expressions.push(this.parseExpression());
  this.expect(types.braceR);
  node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseThrowStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseThrowStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseThrowStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, &quot;Illegal newline after throw&quot;); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, &quot;ThrowStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return this.parseFunctionStatement(node, false, !context)
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.<span class="apidocCodeKeywordSpan">parseThrowStatement</span>(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTopLevel" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTopLevel">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTopLevel
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i &lt; list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, (&quot;Export &apos;&quot; + name + &quot;&apos; is not defined&quot;));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, &quot;Program&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.<span class="apidocCodeKeywordSpan">parseTopLevel</span>(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTryStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseTryStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseTryStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === &quot;Identifier&quot;;
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion &lt; 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, &quot;CatchClause&quot;);
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler &amp;&amp; !node.finalizer)
    { this.raise(node.start, &quot;Missing catch or finally clause&quot;); }
  return this.finishNode(node, &quot;TryStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._class:
  if (context) { this.unexpected(); }
  return this.parseClass(node, true)
case types._if: return this.parseIfStatement(node)
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.<span class="apidocCodeKeywordSpan">parseTryStatement</span>(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVar" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVar
        <span class="apidocSignatureSpan">(node, isFor, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === &quot;const&quot; &amp;&amp; !(this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;)))) {
      this.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.type === types._in || this.isContextual(&quot;of&quot;)))) {
      this.raise(this.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, &quot;VariableDeclarator&quot;));
    if (!this.eat(types.comma)) { break }
  }
  return node
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, null)
}
var isLet = this.isLet();
if (this.type === types._var || this.type === types._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &quot;let&quot; : this.value;
  this.next();
  this.<span class="apidocCodeKeywordSpan">parseVar</span>(init$1, true, kind);
  this.finishNode(init$1, &quot;VariableDeclaration&quot;);
  if ((this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) &amp;&amp; init
$1.declarations.length === 1) {
    if (this.options.ecmaVersion &gt;= 9) {
      if (this.type === types._in) {
        if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt &gt; -1; }
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarId" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarId">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarId
        <span class="apidocSignatureSpan">(decl, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === &quot;var&quot; ? BIND_VAR : BIND_LEXICAL, false);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.<span class="apidocCodeKeywordSpan">parseVarId</span>(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === &quot;const&quot; &amp;&amp; !(this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this
.isContextual(&quot;of&quot;)))) {
      this.unexpected();
    } else if (decl.id.type !== &quot;Identifier&quot; &amp;&amp; !(isFor &amp;&amp; (this.type === types._in || this.isContextual
(&quot;of&quot;)))) {
      this.raise(this.lastTokEnd, &quot;Complex binding patterns require an initialization value&quot;);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseVarStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseVarStatement
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, &quot;VariableDeclaration&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._return: return this.parseReturnStatement(node)
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.<span class="apidocCodeKeywordSpan">parseVarStatement</span>(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWhileStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWhileStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWhileStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(&quot;while&quot;);
  this.labels.pop();
  return this.finishNode(node, &quot;WhileStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._switch: return this.parseSwitchStatement(node)
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.<span class="apidocCodeKeywordSpan">parseWhileStatement</span>(node)
case types._with: return this.parseWithStatement(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWithStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseWithStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseWithStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node) {
  if (this.strict) { this.raise(this.start, &quot;&apos;with&apos; in strict mode&quot;); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(&quot;with&quot;);
  return this.finishNode(node, &quot;WithStatement&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case types._throw: return this.parseThrowStatement(node)
case types._try: return this.parseTryStatement(node)
case types._const: case types._var:
  kind = kind || this.value;
  if (context &amp;&amp; kind !== &quot;var&quot;) { this.unexpected(); }
  return this.parseVarStatement(node, kind)
case types._while: return this.parseWhileStatement(node)
case types._with: return this.<span class="apidocCodeKeywordSpan">parseWithStatement</span>(node)
case types.braceL: return this.parseBlock(true, node)
case types.semi: return this.parseEmptyStatement(node)
case types._export:
case types._import:
  if (this.options.ecmaVersion &gt; 10 &amp;&amp; starttype === types._import) {
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseYield" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.parseYield">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>parseYield
        <span class="apidocSignatureSpan">(noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star &amp;&amp; !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, &quot;YieldExpression&quot;)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
if (this.isContextual(&quot;yield&quot;)) {
  if (this.inGenerator) { return this.<span class="apidocCodeKeywordSpan">parseYield</span>(noIn) }
  // The tokenizer will assume an expression is allowed after
  // `yield`, but this isn&apos;t that kind of yield
  else { this.exprAllowed = false; }
}

var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
if (refDestructuringErrors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raise" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raise">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raise
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += &quot; (&quot; + loc.line + &quot;:&quot; + loc.column + &quot;)&quot;;
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.<span class="apidocCodeKeywordSpan">raise</span>(pos != null ? pos : this.start, &quot;Unexpected token&quot;);
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raiseRecoverable" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.raiseRecoverable">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>raiseRecoverable
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += &quot; (&quot; + loc.line + &quot;:&quot; + loc.column + &quot;)&quot;;
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma &gt; -1)
    { this.<span class="apidocCodeKeywordSpan">raiseRecoverable</span>(refDestructuringErrors.trailingComma, &quot;Comma is not
permitted after the rest element&quot;); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens &gt; -1) { this.raiseRecoverable(parens, &quot;Parenthesized pattern&quot;); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readCodePoint" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readCodePoint">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readCodePoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.invalidStringToken(codePos, &quot;Code point out of bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$9.readEscapedChar = function(inTemplate) {
var ch = this.input.charCodeAt(++this.pos);
++this.pos;
switch (ch) {
case 110: return &quot;\n&quot; // &apos;n&apos; -&gt; &apos;\n&apos;
case 114: return &quot;\r&quot; // &apos;r&apos; -&gt; &apos;\r&apos;
case 120: return String.fromCharCode(this.readHexChar(2)) // &apos;x&apos;
case 117: return codePointToString$1(this.<span class="apidocCodeKeywordSpan">readCodePoint</span>()) // &apos;u&apos;
case 116: return &quot;\t&quot; // &apos;t&apos; -&gt; &apos;\t&apos;
case 98: return &quot;\b&quot; // &apos;b&apos; -&gt; &apos;\b&apos;
case 118: return &quot;\u000b&quot; // &apos;v&apos; -&gt; &apos;\u000b&apos;
case 102: return &quot;\f&quot; // &apos;f&apos; -&gt; &apos;\f&apos;
case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // &apos;\r\n&apos;
case 10: // &apos; \n&apos;
  if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readEscapedChar" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readEscapedChar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readEscapedChar
        <span class="apidocSignatureSpan">(inTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return &quot;\n&quot; // &apos;n&apos; -&gt; &apos;\n&apos;
  case 114: return &quot;\r&quot; // &apos;r&apos; -&gt; &apos;\r&apos;
  case 120: return String.fromCharCode(this.readHexChar(2)) // &apos;x&apos;
  case 117: return codePointToString$1(this.readCodePoint()) // &apos;u&apos;
  case 116: return &quot;\t&quot; // &apos;t&apos; -&gt; &apos;\t&apos;
  case 98: return &quot;\b&quot; // &apos;b&apos; -&gt; &apos;\b&apos;
  case 118: return &quot;\u000b&quot; // &apos;v&apos; -&gt; &apos;\u000b&apos;
  case 102: return &quot;\f&quot; // &apos;f&apos; -&gt; &apos;\f&apos;
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // &apos;\r\n&apos;
  case 10: // &apos; \n&apos;
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return &quot;&quot;
  default:
    if (ch &gt;= 48 &amp;&amp; ch &lt;= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal &gt; 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== &quot;0&quot; || ch === 56 || ch === 57) &amp;&amp; (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? &quot;Octal literal in template string&quot;
            : &quot;Octal literal in strict mode&quot;
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return &quot;&quot;
    }
    return String.fromCharCode(ch)
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var out = &quot;&quot;, chunkStart = ++this.pos;
for (;;) {
  if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
  var ch = this.input.charCodeAt(this.pos);
  if (ch === quote) { break }
  if (ch === 92) { // &apos;\&apos;
    out += this.input.slice(chunkStart, this.pos);
    out += this.<span class="apidocCodeKeywordSpan">readEscapedChar</span>(false);
    chunkStart = this.pos;
  } else {
    if (isNewLine(ch, this.options.ecmaVersion &gt;= 10)) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
    ++this.pos;
  }
}
out += this.input.slice(chunkStart, this.pos++);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readHexChar" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readHexChar">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readHexChar
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, &quot;Bad character escape sequence&quot;); }
  return n
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // &apos;{&apos;
    if (this.options.ecmaVersion &lt; 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.<span class="apidocCodeKeywordSpan">readHexChar</span>(this.input.indexOf(&quot;}&quot;, this.pos) - this.pos);
    ++this.pos;
    if (code &gt; 0x10FFFF) { this.invalidStringToken(codePos, &quot;Code point out of bounds&quot;); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInt
        <span class="apidocSignatureSpan">(radix, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i &lt; e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code &gt;= 97) { val = code - 97 + 10; } // a
    else if (code &gt;= 65) { val = code - 65 + 10; } // A
    else if (code &gt;= 48 &amp;&amp; code &lt;= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val &gt;= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null &amp;&amp; this.pos - start !== len) { return null }

  return total
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.<span class="apidocCodeKeywordSpan">readInt</span>(radix);
  if (val == null) { this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix); }
  if (this.options.ecmaVersion &gt;= 11 &amp;&amp; this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== &quot;undefined&quot; ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
  return this.finishToken(types.num, val)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInvalidTemplateToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readInvalidTemplateToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readInvalidTemplateToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  for (; this.pos &lt; this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case &quot;\\&quot;:
      ++this.pos;
      break

    case &quot;$&quot;:
      if (this.input[this.pos + 1] !== &quot;{&quot;) {
        break
      }
    // falls through

    case &quot;`&quot;:
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, &quot;Unterminated template&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.<span class="apidocCodeKeywordSpan">readInvalidTemplateToken</span>();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readNumber" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readNumber">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readNumber
        <span class="apidocSignatureSpan">(startsWithDot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot &amp;&amp; this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  var octal = this.pos - start &gt;= 2 &amp;&amp; this.input.charCodeAt(start) === 48;
  if (octal &amp;&amp; this.strict) { this.raise(start, &quot;Invalid number&quot;); }
  if (octal &amp;&amp; /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal &amp;&amp; !startsWithDot &amp;&amp; this.options.ecmaVersion &gt;= 11 &amp;&amp; next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== &quot;undefined&quot; ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 &amp;&amp; !octal) { // &apos;.&apos;
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) &amp;&amp; !octal) { // &apos;eE&apos;
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // &apos;+-&apos;
    if (this.readInt(10) === null) { this.raise(start, &quot;Invalid number&quot;); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) { return this.<span class="apidocCodeKeywordSpan">readNumber</span>(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &apos;.&apos;
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRadixNumber" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRadixNumber">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRadixNumber
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, &quot;Expected number in radix &quot; + radix); }
  if (this.options.ecmaVersion &gt;= 11 &amp;&amp; this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== &quot;undefined&quot; ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, &quot;Identifier directly after number&quot;); }
  return this.finishToken(types.num, val)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 96: // &apos;`&apos;
  if (this.options.ecmaVersion &lt; 6) { break }
  ++this.pos;
  return this.finishToken(types.backQuote)

case 48: // &apos;0&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 120 || next === 88) { return this.<span class="apidocCodeKeywordSpan">readRadixNumber</span>(16) } // &apos;0x&apos
;, &apos;0X&apos; - hex number
  if (this.options.ecmaVersion &gt;= 6) {
    if (next === 111 || next === 79) { return this.readRadixNumber(8) } // &apos;0o&apos;, &apos;0O&apos; - octal number
    if (next === 98 || next === 66) { return this.readRadixNumber(2) } // &apos;0b&apos;, &apos;0B&apos; - binary number
  }

// Anything else beginning with a digit is an integer, octal
// number, or float.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRegexp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readRegexp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readRegexp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(start, &quot;Unterminated regular expression&quot;); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, &quot;Unterminated regular expression&quot;); }
    if (!escaped) {
      if (ch === &quot;[&quot;) { inClass = true; }
      else if (ch === &quot;]&quot; &amp;&amp; inClass) { inClass = false; }
      else if (ch === &quot;/&quot; &amp;&amp; !inClass) { break }
      escaped = ch === &quot;\\&quot;;
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function(refDestructuringErrors) {
// If a division operator appears in an expression position, the
// tokenizer got confused, and we force it to read a regexp instead.
if (this.type === types.slash) { this.<span class="apidocCodeKeywordSpan">readRegexp</span>(); }

var node, canBeArrow = this.potentialArrowAt === this.start;
switch (this.type) {
case types._super:
  if (!this.allowSuper)
    { this.raise(this.start, &quot;&apos;super&apos; keyword outside a method&quot;); }
  node = this.startNode();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readString" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readString">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readString
        <span class="apidocSignatureSpan">(quote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(quote) {
  var out = &quot;&quot;, chunkStart = ++this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // &apos;\&apos;
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion &gt;= 10)) { this.raise(this.start, &quot;Unterminated string constant&quot;); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Anything else beginning with a digit is an integer, octal
// number, or float.
case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
  return this.readNumber(false)

// Quotes produce strings.
case 34: case 39: // &apos;&quot;&apos;, &quot;&apos;&quot;
  return this.<span class="apidocCodeKeywordSpan">readString</span>(code)

// Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readTmplToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readTmplToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readTmplToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var out = &quot;&quot;, chunkStart = this.pos;
  for (;;) {
    if (this.pos &gt;= this.input.length) { this.raise(this.start, &quot;Unterminated template&quot;); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 &amp;&amp; this.input.charCodeAt(this.pos + 1) === 123) { // &apos;`&apos;, &apos;${&apos;
      if (this.pos === this.start &amp;&amp; (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // &apos;\&apos;
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += &quot;\n&quot;;
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.<span class="apidocCodeKeywordSpan">readTmplToken</span>();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.<span class="apidocCodeKeywordSpan">readToken</span>(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.readWord() }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_caret" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_caret">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_caret
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() { // &apos;^&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_caret</span>()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.readToken_lt_gt(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_dot" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_dot">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot &apos;.&apos;
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  };

  pp$9.getTokenFromCode = function(code) {
switch (code) {
// The interpretation of a dot depends on whether it is followed
// by a digit or another two dots.
case 46: // &apos;.&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_dot</span>()

// Punctuation tokens.
case 40: ++this.pos; return this.finishToken(types.parenL)
case 41: ++this.pos; return this.finishToken(types.parenR)
case 59: ++this.pos; return this.finishToken(types.semi)
case 44: ++this.pos; return this.finishToken(types.comma)
case 91: ++this.pos; return this.finishToken(types.bracketL)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_eq_excl" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_eq_excl">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_eq_excl
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;=!&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 &amp;&amp; next === 62 &amp;&amp; this.options.ecmaVersion &gt;= 6) { // &apos;=&gt;&apos;
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  case 43: case 45: // &apos;+-&apos;
    return this.readToken_plus_min(code)

  case 60: case 62: // &apos;&lt;&gt;&apos;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &apos;=!&apos;
    return this.<span class="apidocCodeKeywordSpan">readToken_eq_excl</span>(code)

  case 126: // &apos;~&apos;
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, &quot;Unexpected character &apos;&quot; + codePointToString$1(code) + &quot;&apos;&quot;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_lt_gt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_lt_gt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_lt_gt
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;&lt;&gt;&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 &amp;&amp; code === 60 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 45 &amp;&amp;
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `&lt;!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_lt_gt</span>(code)

case 61: case 33: // &apos;=!&apos;
  return this.readToken_eq_excl(code)

case 126: // &apos;~&apos;
  return this.finishOp(types.prefix, 1)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_mult_modulo_exp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_mult_modulo_exp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_mult_modulo_exp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;%*&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion &gt;= 7 &amp;&amp; code === 42 &amp;&amp; next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
  return this.readToken_slash()

case 37: case 42: // &apos;%*&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_mult_modulo_exp</span>(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_pipe_amp" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_pipe_amp">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_pipe_amp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;|&amp;&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 47: // &apos;/&apos;
  return this.readToken_slash()

case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_pipe_amp</span>(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.readToken_plus_min(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_plus_min" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_plus_min">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_plus_min
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(code) { // &apos;+-&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 &amp;&amp; !this.inModule &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 &amp;&amp;
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `--&gt;` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)

case 94: // &apos;^&apos;
  return this.readToken_caret()

case 43: case 45: // &apos;+-&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_plus_min</span>(code)

case 60: case 62: // &apos;&lt;&gt;&apos;
  return this.readToken_lt_gt(code)

case 61: case 33: // &apos;=!&apos;
  return this.readToken_eq_excl(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_slash" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readToken_slash">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readToken_slash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() { // &apos;/&apos;
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// Operators are parsed inline in tiny state machines. &apos;=&apos; (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.

case 47: // &apos;/&apos;
  return this.<span class="apidocCodeKeywordSpan">readToken_slash</span>()

case 37: case 42: // &apos;%*&apos;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &apos;|&amp;&apos;
  return this.readToken_pipe_amp(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, &quot;Escape sequence in keyword &quot; + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. &apos;\uXXXX&apos; sequences are allowed in
  // identifiers, so &apos;\&apos; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* &apos;\&apos; */)
    { return this.<span class="apidocCodeKeywordSpan">readWord</span>() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) { return code }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord1" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.readWord1">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>readWord1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.containsEsc = false;
  var word = &quot;&quot;, first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion &gt;= 6;
  while (this.pos &lt; this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch &lt;= 0xffff ? 1 : 2;
    } else if (ch === 92) { // &quot;\&quot;
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // &quot;u&quot;
        { this.invalidStringToken(this.pos, &quot;Expecting Unicode escape sequence \\uXXXX&quot;); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, &quot;Invalid Unicode escape&quot;); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    escaped = ch === &quot;\\&quot;;
  } else { escaped = false; }
  ++this.pos;
}
var pattern = this.input.slice(start, this.pos);
++this.pos;
var flagsStart = this.pos;
var flags = this.<span class="apidocCodeKeywordSpan">readWord1</span>();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.validateRegExpFlags(state);
this.validateRegExpPattern(state);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_alternative" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_alternative">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_alternative
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.regexp_eatTerm(state))
    { }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    state.raise(&quot;Invalid named capture referenced&quot;);
  }
}
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function(state) {
this.<span class="apidocCodeKeywordSpan">regexp_alternative</span>(state);
while (state.eat(0x7C /* | */)) {
  this.regexp_alternative(state);
}

// Make the same message as V8.
if (this.regexp_eatQuantifier(state, true)) {
  state.raise(&quot;Nothing to repeat&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_classRanges" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_classRanges">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_classRanges
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) &amp;&amp; this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU &amp;&amp; (left === -1 || right === -1)) {
        state.raise(&quot;Invalid character class&quot;);
      }
      if (left !== -1 &amp;&amp; right !== -1 &amp;&amp; left &gt; right) {
        state.raise(&quot;Range out of order in character class&quot;);
      }
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.<span class="apidocCodeKeywordSpan">regexp_classRanges</span>(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw &quot;unterminated regular expression&quot; error before.
    state.raise(&quot;Unterminated character class&quot;);
  }
  return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_disjunction" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_disjunction">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_disjunction
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
state.lastStringValue = &quot;&quot;;
state.lastAssertionIsQuantifiable = false;
state.numCapturingParens = 0;
state.maxBackReference = 0;
state.groupNames.length = 0;
state.backReferenceNames.length = 0;

this.<span class="apidocCodeKeywordSpan">regexp_disjunction</span>(state);

if (state.pos !== state.source.length) {
  // Make the same messages as V8.
  if (state.eat(0x29 /* ) */)) {
    state.raise(&quot;Unmatched &apos;)&apos;&quot;);
  }
  if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAssertion" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAssertion">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAssertion
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) &amp;&amp; state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion &gt;= 9) {
      lookbehind = state.eat(0x3C /* &lt; */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise(&quot;Unterminated group&quot;);
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_alternative = function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatAssertion</span>(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable &amp;&amp; this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.<span class="apidocCodeKeywordSpan">regexp_eatAtom</span>(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtomEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatAtomEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatAtomEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.raise(&quot;Invalid escape&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatAtomEscape</span>(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBackReference" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBackReference">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBackReference
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n &gt; state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n &lt;= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* &lt;ZWNJ&gt; */ || ch ===
0x200D /* &lt;ZWJ&gt; */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.<span class="apidocCodeKeywordSpan">regexp_eatBackReference</span>(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBracedQuantifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatBracedQuantifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatBracedQuantifier
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) &amp;&amp; this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 &amp;&amp; max &lt; min &amp;&amp; !noError) {
          state.raise(&quot;numbers out of order in {} quantifier&quot;);
        }
        return true
      }
    }
    if (state.switchU &amp;&amp; !noError) {
      state.raise(&quot;Incomplete quantifier&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatBracedQuantifier</span>(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCControlLetter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCControlLetter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCControlLetter</span>(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCapturingGroup" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCapturingGroup">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCapturingGroup
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion &gt;= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise(&quot;Invalid group&quot;);
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise(&quot;Unterminated group&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCapturingGroup</span>(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClass" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClass">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClass
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw &quot;unterminated regular expression&quot; error before.
    state.raise(&quot;Unterminated character class&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterClass</span>(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClassEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterClassEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterClassEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &amp;&amp;
    this.options.ecmaVersion &gt;= 9 &amp;&amp;
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatUnicodePropertyValueExpression(state) &amp;&amp;
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise(&quot;Invalid property name&quot;);
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* &lt;ZWNJ&gt; */ || ch ===
0x200D /* &lt;ZWJ&gt; */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterClassEscape</span>(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatCharacterEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatCharacterEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatCharacterEscape</span>(state) ||
    (state.switchN &amp;&amp; this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise(&quot;Invalid class escape&quot;);
      }
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.<span class="apidocCodeKeywordSpan">regexp_eatClassAtom</span>(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) &amp;&amp; this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU &amp;&amp; (left === -1 || right === -1)) {
        state.raise(&quot;Invalid character class&quot;);
      }
      if (left !== -1 &amp;&amp; right !== -1 &amp;&amp; left &gt; right) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassControlLetter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassControlLetter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

if (state.switchU &amp;&amp; state.eat(0x2D /* - */)) {
  state.lastIntValue = 0x2D; /* - */
  return true
}

if (!state.switchU &amp;&amp; state.eat(0x63 /* c */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatClassControlLetter</span>(state)) {
    return true
  }
  state.pos = start;
}

return (
  this.regexp_eatCharacterClassEscape(state) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatClassEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatClassEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x62<span class="apidocCodeCommentSpan"> /* b */)) {
    state.lastIntValue = 0x08; /* &lt;BS&gt; */
</span>    return true
  }

  if (state.switchU &amp;&amp; state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU &amp;&amp; state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function(state) {
var start = state.pos;

if (state.eat(0x5C /* \ */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatClassEscape</span>(state)) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    var ch$1 = state.current();
    if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
      state.raise(&quot;Invalid class escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (ch === 0x74<span class="apidocCodeCommentSpan"> /* t */) {
    state.lastIntValue = 0x09; /* \t */
</span>    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.<span class="apidocCodeKeywordSpan">regexp_eatControlEscape</span>(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlLetter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatControlLetter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatControlLetter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatControlLetter</span>(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalDigits" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalDigits">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalDigits
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatDecimalDigits</span>(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) &amp;&amp; this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 &amp;&amp; max &lt; min &amp;&amp; !noError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatDecimalEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatDecimalEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch &gt;= 0x31 /* 1 */ &amp;&amp; ch &lt;= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) &gt;= 0x30 /* 0 */ &amp;&amp; ch &lt;= 0x39 /* 9 */)
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }
    state.raise(&quot;Invalid escape&quot;);
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatDecimalEscape</span>(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n &gt; state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedAtom" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedAtom">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedAtom
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.<span class="apidocCodeKeywordSpan">regexp_eatExtendedAtom</span>(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatExtendedPatternCharacter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatExtendedPatternCharacter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (
    ch !== -1 &amp;&amp;
    ch !== 0x24<span class="apidocCodeCommentSpan"> /* $ */ &amp;&amp;
    !(ch &gt;= 0x28 /* ( */ &amp;&amp; ch &lt;= 0x2B /* + */) &amp;&amp;
    ch !== 0x2E /* . */ &amp;&amp;
    ch !== 0x3F /* ? */ &amp;&amp;
    ch !== 0x5B /* [ */ &amp;&amp;
    ch !== 0x5E /* ^ */ &amp;&amp;
    ch !== 0x7C /* | */
</span>  ) {
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatExtendedPatternCharacter</span>(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatFixedHexDigits" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatFixedHexDigits">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatFixedHexDigits
        <span class="apidocSignatureSpan">(state, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i &lt; length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
var start = state.pos;

if (state.eat(0x75 /* u */)) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatFixedHexDigits</span>(state, 4)) {
    var lead = state.lastIntValue;
    if (state.switchU &amp;&amp; lead &gt;= 0xD800 &amp;&amp; lead &lt;= 0xDBFF) {
      var leadSurrogateEnd = state.pos;
      if (state.eat(0x5C /* \ */) &amp;&amp; state.eat(0x75 /* u */) &amp;&amp; this.regexp_eatFixedHexDigits(state, 4)) {
        var trail = state.lastIntValue;
        if (trail &gt;= 0xDC00 &amp;&amp; trail &lt;= 0xDFFF) {
          state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatGroupName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatGroupName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatGroupName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastStringValue = &quot;&quot;;
  if (state.eat(0x3C /* &lt; */)) {
    if (this.regexp_eatRegExpIdentifierName(state) &amp;&amp; state.eat(0x3E /* &gt; */)) {
      return true
    }
    state.raise(&quot;Invalid capture group name&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatGroupName</span>(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise(&quot;Duplicate capture group name&quot;);
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise(&quot;Invalid group&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexDigits" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexDigits">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexDigits
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    state.lastIntValue = lead;
  }
  return true
}
if (
  state.switchU &amp;&amp;
  state.eat(0x7B /* { */) &amp;&amp;
  this.<span class="apidocCodeKeywordSpan">regexp_eatHexDigits</span>(state) &amp;&amp;
  state.eat(0x7D /* } */) &amp;&amp;
  isValidUnicode(state.lastIntValue)
) {
  return true
}
if (state.switchU) {
  state.raise(&quot;Invalid unicode escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexEscapeSequence" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatHexEscapeSequence">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatHexEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid escape&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatHexEscapeSequence</span>(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatIdentityEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatIdentityEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatIdentityEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F<span class="apidocCodeCommentSpan"> /* / */)) {
      state.lastIntValue = 0x2F; /* / */
</span>      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ &amp;&amp; (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatIdentityEscape</span>(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatInvalidBracedQuantifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatInvalidBracedQuantifier
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatInvalidBracedQuantifier</span>(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatKGroupName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatKGroupName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatKGroupName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise(&quot;Invalid named reference&quot;);
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatKGroupName</span>(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise(&quot;Invalid unicode escape&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLegacyOctalEscapeSequence">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLegacyOctalEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 &lt;= 3 &amp;&amp; this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatLegacyOctalEscapeSequence</span>(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatLoneUnicodePropertyNameOrValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatLoneUnicodePropertyNameOrValue
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatLoneUnicodePropertyNameOrValue</span>(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatOctalDigit" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatOctalDigit">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatOctalDigit
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30;<span class="apidocCodeCommentSpan"> /* 0 */
</span>    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatOctalDigit</span>(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 &lt;= 3 &amp;&amp; this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatPatternCharacters" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatPatternCharacters">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatPatternCharacters
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 &amp;&amp; !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.<span class="apidocCodeKeywordSpan">regexp_eatPatternCharacters</span>(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifier
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatQuantifier</span>(state, true)) {
    state.raise(&quot;Nothing to repeat&quot;);
  }
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifierPrefix" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatQuantifierPrefix">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatQuantifierPrefix
        <span class="apidocSignatureSpan">(state, noError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.<span class="apidocCodeKeywordSpan">regexp_eatQuantifierPrefix</span>(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// GroupName[U] ::
//   `&lt;` RegExpIdentifierName[?U] `&gt;`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (state.eat(0x3C /* &lt; */)) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierName</span>(state) &amp;&amp; state.eat(0x3E /* &gt; */)) {
      return true
    }
    state.raise(&quot;Invalid capture group name&quot;);
  }
  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierPart">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierPart
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierPart</span>(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpIdentifierStart">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpIdentifierStart
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ &amp;&amp; this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = &quot;&quot;;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpIdentifierStart</span>(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatRegExpUnicodeEscapeSequence">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatRegExpUnicodeEscapeSequence
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU &amp;&amp; lead &gt;= 0xD800 &amp;&amp; lead &lt;= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) &amp;&amp; state.eat(0x75 /* u */) &amp;&amp; this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail &gt;= 0xDC00 &amp;&amp; trail &lt;= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &amp;&amp;
      state.eat(0x7B /* { */) &amp;&amp;
      this.regexp_eatHexDigits(state) &amp;&amp;
      state.eat(0x7D /* } */) &amp;&amp;
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise(&quot;Invalid unicode escape&quot;);
    }
    state.pos = start;
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[?U]
  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
var start = state.pos;
var ch = state.current();
state.advance();

if (ch === 0x5C /* \ */ &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatRegExpUnicodeEscapeSequence</span>(state)) {
  ch = state.lastIntValue;
}
if (isRegExpIdentifierStart(ch)) {
  state.lastIntValue = ch;
  return true
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatReverseSolidusAtomEscape">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatReverseSolidusAtomEscape
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatReverseSolidusAtomEscape</span>(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatSyntaxCharacter" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatSyntaxCharacter">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatSyntaxCharacter
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
function isValidUnicode(ch) {
  return ch &gt;= 0 &amp;&amp; ch &lt;= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.<span class="apidocCodeKeywordSpan">regexp_eatSyntaxCharacter</span>(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatTerm" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatTerm">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatTerm
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable &amp;&amp; this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise(&quot;Invalid quantifier&quot;);
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (state.eat(0x7B /* { */)) {
    state.raise(&quot;Lone quantifier brackets&quot;);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos &lt; state.source.length &amp;&amp; this.<span class="apidocCodeKeywordSpan">regexp_eatTerm</span>(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUncapturingGroup" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUncapturingGroup">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUncapturingGroup
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) &amp;&amp; state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise(&quot;Unterminated group&quot;);
    }
    state.pos = start;
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatUncapturingGroup</span>(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyName" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyName">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyName
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyName</span>(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.regexp_eatUnicodePropertyValue(state)) {
    var value = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
    return true
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValue
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var ch = 0;
  state.lastStringValue = &quot;&quot;;
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== &quot;&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyValue</span>(state)) {
    var value = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
    return true
  }
}
state.pos = start;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatUnicodePropertyValueExpression">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatUnicodePropertyValueExpression
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.options.ecmaVersion &gt;= 9 &amp;&amp;
  (ch === 0x50 /* P */ || ch === 0x70 /* p */)
) {
  state.lastIntValue = -1;
  state.advance();
  if (
    state.eat(0x7B /* { */) &amp;&amp;
    this.<span class="apidocCodeKeywordSpan">regexp_eatUnicodePropertyValueExpression</span>(state) &amp;&amp;
    state.eat(0x7D /* } */)
  ) {
    return true
  }
  state.raise(&quot;Invalid property name&quot;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatZero" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_eatZero">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_eatZero
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.current() === 0x30 /* 0 */ &amp;&amp; !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.<span class="apidocCodeKeywordSpan">regexp_eatZero</span>(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU &amp;&amp; this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_groupSpecifier" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_groupSpecifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_groupSpecifier
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise(&quot;Duplicate capture group name&quot;);
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise(&quot;Invalid group&quot;);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion &gt;= 9) {
      this.<span class="apidocCodeKeywordSpan">regexp_groupSpecifier</span>(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise(&quot;Invalid group&quot;);
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_pattern" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_pattern">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_pattern
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = &quot;&quot;;
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise(&quot;Unmatched &apos;)&apos;&quot;);
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise(&quot;Lone quantifier brackets&quot;);
    }
  }
  if (state.maxBackReference &gt; state.numCapturingParens) {
    state.raise(&quot;Invalid escape&quot;);
  }
  for (var i = 0, list = state.backReferenceNames; i &lt; list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise(&quot;Invalid named capture referenced&quot;);
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function(state) {
this.<span class="apidocCodeKeywordSpan">regexp_pattern</span>(state);

// The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
// parsing contains a |GroupName|, reparse with the goal symbol
// |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
// exception if _P_ did not conform to the grammar, if any elements of _P_
// were not matched by the parse, or if any Early Error conditions exist.
if (!state.switchN &amp;&amp; this.options.ecmaVersion &gt;= 9 &amp;&amp; state.groupNames.length &gt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameAndValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameAndValue
        <span class="apidocSignatureSpan">(state, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise(&quot;Invalid property name&quot;); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise(&quot;Invalid property value&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var start = state.pos;

// UnicodePropertyName `=` UnicodePropertyValue
if (this.regexp_eatUnicodePropertyName(state) &amp;&amp; state.eat(0x3D /* = */)) {
  var name = state.lastStringValue;
  if (this.regexp_eatUnicodePropertyValue(state)) {
    var value = state.lastStringValue;
    this.<span class="apidocCodeKeywordSpan">regexp_validateUnicodePropertyNameAndValue</span>(state, name, value);
    return true
  }
}
state.pos = start;

// LoneUnicodePropertyNameOrValue
if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.regexp_validateUnicodePropertyNameOrValue">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>regexp_validateUnicodePropertyNameOrValue
        <span class="apidocSignatureSpan">(state, nameOrValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise(&quot;Invalid property name&quot;); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.<span class="apidocCodeKeywordSpan">regexp_validateUnicodePropertyNameOrValue</span>(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise(&quot;Invalid property name&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.semicolon" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.semicolon">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  if (!this.eat(types.semi) &amp;&amp; !this.insertSemicolon()) { this.unexpected(); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  pp$1.parseBreakContinueStatement = function(node, keyword) {
var isBreak = keyword === &quot;break&quot;;
this.next();
if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
else if (this.type !== types.name) { this.unexpected(); }
else {
  node.label = this.parseIdent();
  this.<span class="apidocCodeKeywordSpan">semicolon</span>();
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0;
for (; i &lt; this.labels.length; ++i) {
  var lab = this.labels[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.shouldParseExportStatement" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.shouldParseExportStatement">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>shouldParseExportStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return this.type.keyword === &quot;var&quot; ||
    this.type.keyword === &quot;const&quot; ||
    this.type.keyword === &quot;class&quot; ||
    this.type.keyword === &quot;function&quot; ||
    this.isLet() ||
    this.isAsyncFunction()
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  } else {
    node.declaration = this.parseMaybeAssign();
    this.semicolon();
  }
  return this.finishNode(node, &quot;ExportDefaultDeclaration&quot;)
}
// export var|const|let|function|class ...
if (this.<span class="apidocCodeKeywordSpan">shouldParseExportStatement</span>()) {
  node.declaration = this.parseStatement(null);
  if (node.declaration.type === &quot;VariableDeclaration&quot;)
    { this.checkVariableExport(exports, node.declaration.declarations); }
  else
    { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
  node.specifiers = [];
  node.source = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipBlockComment" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipBlockComment">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipBlockComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var start = this.pos, end = this.input.indexOf(&quot;*/&quot;, this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, &quot;Unterminated comment&quot;); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) &amp;&amp; match.index &lt; this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    ++this.curLine;
    this.lineStart = this.pos;
  }
  break
case 47: // &apos;/&apos;
  switch (this.input.charCodeAt(this.pos + 1)) {
  case 42: // &apos;*&apos;
    this.<span class="apidocCodeKeywordSpan">skipBlockComment</span>();
    break
  case 47:
    this.skipLineComment(2);
    break
  default:
    break loop
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipLineComment" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipLineComment">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipLineComment
        <span class="apidocSignatureSpan">(startSkip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment &amp;&amp; this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos &lt; this.input.length &amp;&amp; !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// Labels in scope.
this.labels = [];
// Thus-far undefined exports.
this.undefinedExports = {};

// If enabled, skip leading hashbang line.
if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === &quot;#!&quot;)
  { this.<span class="apidocCodeKeywordSpan">skipLineComment</span>(2); }

// Scope tracking for duplicate variable names (see scope.js)
this.scopeStack = [];
this.enterScope(SCOPE_TOP);

// For RegExp validation
this.regexpState = null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipSpace" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.skipSpace">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>skipSpace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  loop: while (this.pos &lt; this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // &apos; &apos;
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // &apos;/&apos;
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // &apos;*&apos;
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch &gt; 8 &amp;&amp; ch &lt; 14 || ch &gt;= 5760 &amp;&amp; nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  };

  // Read a single token, updating the parser object&apos;s token-related
  // properties.

  pp$9.nextToken = function() {
var curContext = this.curContext();
if (!curContext || !curContext.preserveSpace) { this.<span class="apidocCodeKeywordSpan">skipSpace</span>(); }

this.start = this.pos;
if (this.options.locations) { this.startLoc = this.curPosition(); }
if (this.pos &gt;= this.input.length) { return this.finishToken(types.eof) }

if (curContext.override) { return curContext.override(this) }
else { this.readToken(this.fullCharCodeAtPos()); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNode" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNode">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  return new Node(this, this.start, this.startLoc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },
allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.<span class="apidocCodeKeywordSpan">startNode</span>();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNodeAt" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.startNodeAt">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>startNodeAt
        <span class="apidocSignatureSpan">(pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos, loc) {
  return new Node(this, pos, loc)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if ( noLineBreak === void 0 ) noLineBreak = false;

  var start = this$1.start, startLoc = this$1.startLoc;
  if (!this$1.eatContextual(k)) { return false }
  if (this$1.type !== types.parenL &amp;&amp; (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
  if (method.key) { this$1.unexpected(); }
  method.computed = false;
  method.key = this$1.<span class="apidocCodeKeywordSpan">startNodeAt</span>(start, startLoc);
  method.key.name = k;
  this$1.finishNode(method.key, &quot;Identifier&quot;);
  return false
};

method.kind = &quot;method&quot;;
method.static = tryContextual(&quot;static&quot;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.strictDirective" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.strictDirective">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>strictDirective
        <span class="apidocSignatureSpan">(start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === &quot;use strict&quot;) { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === &quot;;&quot;)
      { start++; }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.initialContext();
this.exprAllowed = true;

// Figure out if it&apos;s a module code.
this.inModule = options.sourceType === &quot;module&quot;;
this.strict = this.inModule || this.<span class="apidocCodeKeywordSpan">strictDirective</span>(this.pos);

// Used to signify the start of a potential arrow function
this.potentialArrowAt = -1;

// Positions to delayed-check that yield/await does not exist in default parameters.
this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
// Labels in scope.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignable" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignable">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignable
        <span class="apidocSignatureSpan">(node, isBinding, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; node) {
    switch (node.type) {
    case &quot;Identifier&quot;:
      if (this.inAsync &amp;&amp; node.name === &quot;await&quot;)
        { this.raise(node.start, &quot;Cannot use &apos;await&apos; as identifier inside an async function&quot;); }
      break

    case &quot;ObjectPattern&quot;:
    case &quot;ArrayPattern&quot;:
    case &quot;RestElement&quot;:
      break

    case &quot;ObjectExpression&quot;:
      node.type = &quot;ObjectPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i &lt; list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === &quot;RestElement&quot; &amp;&amp;
          (prop.argument.type === &quot;ArrayPattern&quot; || prop.argument.type === &quot;ObjectPattern&quot;)
        ) {
          this.raise(prop.argument.start, &quot;Unexpected token&quot;);
        }
      }
      break

    case &quot;Property&quot;:
      // AssignmentProperty has type === &quot;Property&quot;
      if (node.kind !== &quot;init&quot;) { this.raise(node.key.start, &quot;Object pattern can&apos;t contain getter or setter&quot;); }
      this.toAssignable(node.value, isBinding);
      break

    case &quot;ArrayExpression&quot;:
      node.type = &quot;ArrayPattern&quot;;
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case &quot;SpreadElement&quot;:
      node.type = &quot;RestElement&quot;;
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === &quot;AssignmentPattern&quot;)
        { this.raise(node.argument.start, &quot;Rest elements cannot have a default value&quot;); }
      break

    case &quot;AssignmentExpression&quot;:
      if (node.operator !== &quot;=&quot;) { this.raise(node.left.end, &quot;Only &apos;=&apos; operator can be used for specifying default value.&quot;); }
      node.type = &quot;AssignmentPattern&quot;;
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case &quot;AssignmentPattern&quot;:
      break

    case &quot;ParenthesizedExpression&quot;:
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case &quot;MemberExpression&quot;:
      if (!isBinding) { break }

    default:
      this.raise(node.start, &quot;Assigning to rvalue&quot;);
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var init = this.parseExpression(true, refDestructuringErrors);
if (this.type === types._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual(&quot;of&quot;))) {
  if (this.options.ecmaVersion &gt;= 9) {
    if (this.type === types._in) {
      if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
    } else { node.await = awaitAt &gt; -1; }
  }
  this.<span class="apidocCodeKeywordSpan">toAssignable</span>(init, false, refDestructuringErrors);
  this.checkLVal(init);
  return this.parseForIn(node, init)
} else {
  this.checkExpressionErrors(refDestructuringErrors, true);
}
if (awaitAt &gt; -1) { this.unexpected(awaitAt); }
return this.parseFor(node, init)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignableList" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.toAssignableList">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>toAssignableList
        <span class="apidocSignatureSpan">(exprList, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i &lt; end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 &amp;&amp; isBinding &amp;&amp; last &amp;&amp; last.type === &quot;RestElement&quot; &amp;&amp; last.argument.type !== &quot;Identifier
&quot;)
      { this.unexpected(last.argument.start); }
  }
  return exprList
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  if (node.kind !== &quot;init&quot;) { this.raise(node.key.start, &quot;Object pattern can&apos;t contain getter or setter&quot
;); }
  this.toAssignable(node.value, isBinding);
  break

case &quot;ArrayExpression&quot;:
  node.type = &quot;ArrayPattern&quot;;
  if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  this.<span class="apidocCodeKeywordSpan">toAssignableList</span>(node.elements, isBinding);
  break

case &quot;SpreadElement&quot;:
  node.type = &quot;RestElement&quot;;
  this.toAssignable(node.argument, isBinding);
  if (node.argument.type === &quot;AssignmentPattern&quot;)
    { this.raise(node.argument.start, &quot;Rest elements cannot have a default value&quot;); }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.treatFunctionsAsVarInScope" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.treatFunctionsAsVarInScope">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>treatFunctionsAsVarInScope
        <span class="apidocSignatureSpan">(scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(scope) {
  return (scope.flags &amp; SCOPE_FUNCTION) || !this.inModule &amp;&amp; (scope.flags &amp; SCOPE_TOP)
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags &amp; SCOPE_FUNCTION) &gt; 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags &amp; SCOPE_GENERATOR) &gt; 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags &amp; SCOPE_ASYNC) &gt; 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_SUPER) &gt; 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags &amp; SCOPE_DIRECT_SUPER) &gt; 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.<span class="apidocCodeKeywordSpan">treatFunctionsAsVarInScope
</span>(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags &amp; SCOPE_FUNCTION
) &gt; 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.tryReadTemplateToken" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.tryReadTemplateToken">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>tryReadTemplateToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

var types$1 = {
  b_stat: new TokContext(&quot;{&quot;, false),
  b_expr: new TokContext(&quot;{&quot;, true),
  b_tmpl: new TokContext(&quot;${&quot;, false),
  p_stat: new TokContext(&quot;(&quot;, false),
  p_expr: new TokContext(&quot;(&quot;, true),
  q_tmpl: new TokContext(&quot;`&quot;, true, true, function (p) { return p.<span class="apidocCodeKeywordSpan">tryReadTemplateToken
</span>(); }),
  f_stat: new TokContext(&quot;function&quot;, false),
  f_expr: new TokContext(&quot;function&quot;, true),
  f_expr_gen: new TokContext(&quot;function&quot;, true, false, null, true),
  f_gen: new TokContext(&quot;function&quot;, false, false, null, true)
};

var pp$7 = Parser.prototype;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.unexpected" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.unexpected">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>unexpected
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(pos) {
  this.raise(pos != null ? pos : this.start, &quot;Unexpected token&quot;);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.<span class="apidocCodeKeywordSpan">unexpected</span>(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.updateContext" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.updateContext">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>updateContext
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(prevType) {
  var update, type = this.type;
  if (type.keyword &amp;&amp; prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.<span class="apidocCodeKeywordSpan">updateContext</span>(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpFlags" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpFlags">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpFlags
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i &lt; flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, &quot;Invalid regular expression flag&quot;);
    }
    if (flags.indexOf(flag, i + 1) &gt; -1) {
      this.raise(state.start, &quot;Duplicate regular expression flag&quot;);
    }
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var flagsStart = this.pos;
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.<span class="apidocCodeKeywordSpan">validateRegExpFlags</span>(state);
this.validateRegExpPattern(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
} catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpPattern" id="apidoc.elem.utility2.istanbul.esprima.Parser.prototype.validateRegExpPattern">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Parser.prototype.</span>validateRegExpPattern
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN &amp;&amp; this.options.ecmaVersion &gt;= 9 &amp;&amp; state.groupNames.length &gt; 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var flags = this.readWord1();
if (this.containsEsc) { this.unexpected(flagsStart); }

// Validate pattern
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags);
this.validateRegExpFlags(state);
this.<span class="apidocCodeKeywordSpan">validateRegExpPattern</span>(state);

// Create Literal#value property value.
var value = null;
try {
  value = new RegExp(pattern, flags);
} catch (e) {
  // ESTree requires null if it failed to instantiate RegExp object.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.esprima.Position.prototype" id="apidoc.module.utility2.istanbul.esprima.Position.prototype">module utility2.istanbul.esprima.Position.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.esprima.Position.prototype.offset" id="apidoc.elem.utility2.istanbul.esprima.Position.prototype.offset">
        function <span class="apidocSignatureSpan">utility2.istanbul.esprima.Position.prototype.</span>offset
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function offset (n) {
  return new Position(this.line, this.column + n)
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.estraverse" id="apidoc.module.utility2.istanbul.estraverse">module utility2.istanbul.estraverse</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller" id="apidoc.elem.utility2.istanbul.estraverse.Controller">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>Controller
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Controller() { }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.attachComments" id="apidoc.elem.utility2.istanbul.estraverse.attachComments">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>attachComments
        <span class="apidocSignatureSpan">(tree, providedComments, tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [], comment, len, i, cursor;

    if (!tree.range) {
        throw new Error(&apos;attachComments needs range information&apos;);
    }

    // tokens array is empty, we attach comments to tree as &apos;leadingComments&apos;
    if (!tokens.length) {
        if (providedComments.length) {
            for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
                comment = deepCopy(providedComments[i]);
                comment.extendedRange = [0, tree.range[0]];
                comments.push(comment);
            }
            tree.leadingComments = comments;
        }
        return tree;
    }

    for (i = 0, len = providedComments.length; i &lt; len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman&apos;s implementation.
    cursor = 0;
    traverse(tree, {
        enter: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (comment.extendedRange[1] &gt; node.range[0]) {
                    break;
                }

                if (comment.extendedRange[1] === node.range[0]) {
                    if (!node.leadingComments) {
                        node.leadingComments = [];
                    }
                    node.leadingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    cursor = 0;
    traverse(tree, {
        leave: function (node) {
            var comment;

            while (cursor &lt; comments.length) {
                comment = comments[cursor];
                if (node.range[1] &lt; comment.extendedRange[0]) {
                    break;
                }

                if (node.range[1] === comment.extendedRange[0]) {
                    if (!node.trailingComments) {
                        node.trailingComments = [];
                    }
                    node.trailingComments.push(comment);
                    comments.splice(cursor, 1);
                } else {
                    cursor += 1;
                }
            }

            // already out of owned node
            if (cursor === comments.length) {
                return VisitorOption.Break;
            }

            if (comments[cursor].extendedRange[0] &gt; node.range[1]) {
                return VisitorOption.Skip;
            }
        }
    });

    return tree;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.cloneEnvironment" id="apidoc.elem.utility2.istanbul.estraverse.cloneEnvironment">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>cloneEnvironment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneEnvironment = function () { return clone({}); }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.replace" id="apidoc.elem.utility2.istanbul.estraverse.replace">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.<span class="apidocCodeKeywordSpan">replace</span>(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
};
local.identity = function (val) {
/*
 * this function will return &lt;val&gt;
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.traverse" id="apidoc.elem.utility2.istanbul.estraverse.traverse">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }

    return outer.root;
};

function traverse(root, visitor) {
    var controller = new Controller();
    return controller.<span class="apidocCodeKeywordSpan">traverse</span>(root, visitor);
}

function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.estraverse.Controller.prototype" id="apidoc.module.utility2.istanbul.estraverse.Controller.prototype">module utility2.istanbul.estraverse.Controller.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__execute" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__execute">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__execute
        <span class="apidocSignatureSpan">(callback, element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function __execute(callback, element) {
    var previous, result;

    result = undefined;

    previous  = this.__current;
    this.__current = element;
    this.__state = null;
    if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }
    this.__current = previous;

    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

        while (worklist.length) {
element = worklist.pop();

if (element === sentinel) {
    element = leavelist.pop();

    ret = this.<span class="apidocCodeKeywordSpan">__execute</span>(visitor.leave, element);

    if (this.__state === BREAK || ret === BREAK) {
        return;
    }
    continue;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__initialize" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.__initialize">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>__initialize
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;
    if (visitor.fallback === &apos;iteration&apos;) {
        this.__fallback = objectKeys;
    } else if (typeof visitor.fallback === &apos;function&apos;) {
        this.__fallback = visitor.fallback;
    }

    this.__keys = VisitorKeys;
    if (visitor.keys) {
        this.__keys = extend(objectCreate(this.__keys), visitor.keys);
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    key,
    current,
    current2,
    candidates,
    candidate,
    sentinel;

this.<span class="apidocCodeKeywordSpan">__initialize</span>(root, visitor);

sentinel = {};

// reference
worklist = this.__worklist;
leavelist = this.__leavelist;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.break" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.break">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>break
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">break = function () {
    this.notify(BREAK);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.current" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.current">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>current
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function current() {
    return this.__current.node;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.<span class="apidocCodeKeywordSpan">current</span>() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.notify" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.notify">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>notify
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notify(flag) {
    this.__state = flag;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
};

// API:
// skip child nodes of current node
Controller.prototype.skip = function () {
    this.<span class="apidocCodeKeywordSpan">notify</span>(SKIP);
};

// API:
// break traversals
Controller.prototype[&apos;break&apos;] = function () {
    this.notify(BREAK);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.parents" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.parents">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>parents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parents() {
    var i, iz, result;

    // first node is sentinel
    result = [];
    for (i = 1, iz = this.__leavelist.length; i &lt; iz; ++i) {
        result.push(this.__leavelist[i].node);
    }

    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.path" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.path">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>path
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function path() {
    var i, iz, j, jz, result, element;

    function addToPath(result, path) {
        if (isArray(path)) {
            for (j = 0, jz = path.length; j &lt; jz; ++j) {
                result.push(path[j]);
            }
        } else {
            result.push(path);
        }
    }

    // root node
    if (!this.__current.path) {
        return null;
    }

    // first node is sentinel, second node is root element
    result = [];
    for (i = 2, iz = this.__leavelist.length; i &lt; iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
    }
    addToPath(result, this.__current.path);
    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.remove" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.remove">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>remove
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function () {
    this.notify(REMOVE);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...

        function removeElem(element) {
            var i,
key,
nextElem,
parent;

            if (element.ref.<span class="apidocCodeKeywordSpan">remove</span>()) {
// When the reference is an element of an array.
key = element.ref.key;
parent = element.ref.parent;

// If removed from array, then decrease following items&apos; keys.
i = worklist.length;
while (i--) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.replace" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.replace">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>replace
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(root, visitor) {
    var worklist,
        leavelist,
        node,
        nodeType,
        target,
        element,
        current,
        current2,
        candidates,
        candidate,
        sentinel,
        outer,
        key;

    function removeElem(element) {
        var i,
            key,
            nextElem,
            parent;

        if (element.ref.remove()) {
            // When the reference is an element of an array.
            key = element.ref.key;
            parent = element.ref.parent;

            // If removed from array, then decrease following items&apos; keys.
            i = worklist.length;
            while (i--) {
                nextElem = worklist[i];
                if (nextElem.ref &amp;&amp; nextElem.ref.parent === parent) {
                    if  (nextElem.ref.key &lt; key) {
                        break;
                    }
                    --nextElem.ref.key;
                }
            }
        }
    }

    this.__initialize(root, visitor);

    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    outer = {
        root: root
    };
    element = new Element(root, null, null, new Reference(outer, &apos;root&apos;));
    worklist.push(element);
    leavelist.push(element);

    while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
            element = leavelist.pop();

            target = this.__execute(visitor.leave, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined &amp;&amp; target !== BREAK &amp;&amp; target !== SKIP &amp;&amp; target !== REMOVE) {
                // replace
                element.ref.replace(target);
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }
            continue;
        }

        target = this.__execute(visitor.enter, element);

        // node may be replaced with null,
        // so distinguish between undefined and null in this place
        if (target !== undefined &amp;&amp; target !== BREAK &amp;&amp; target !== SKIP &amp;&amp; target !== REMOVE) {
            // replace
            element.ref.replace(target);
            element.node = target;
        }

        if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
        }

        if (this.__state === BREAK || target === BREAK) {
            return outer.root;
        }

        // node may be null
        node = element.node;
        if (!node) {
            continue;
        }

        worklist.push(sentinel);
        leavelist.push(element);

        if (this.__state === SKIP || target === SKIP) {
            continue;
        }

        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
            if (this.__fallback) {
                candidates = this.__fallback(node);
            } else {
                throw new Error(&apos;Unknown node type &apos; + nodeType + &apos;.&apos;);
            }
        }

        current = candidates.length;
        while ((current -= 1) &gt;= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
                continue;
            }

            if (isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) &gt;= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (isProperty(nodeType, candidates[current])) {
                        element = new Element(candidate[current2], [key, current2], &apos;Property&apos;, new Reference(candidate, current2
));
                    } else if (isNode(candidat...</pre></li>
    <li>example use<pre class="apidocCodePre">...
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.<span class="apidocCodeKeywordSpan">replace</span>(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
};
local.identity = function (val) {
/*
 * this function will return &lt;val&gt;
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.skip" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.skip">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>skip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function () {
    this.notify(SKIP);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.traverse" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.traverse">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>traverse
        <span class="apidocSignatureSpan">(root, visitor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(root, visitor) {
    var worklist,
        leavelist,
        element,
        node,
        nodeType,
        ret,
        key,
        current,
        current2,
        candidates,
        candidate,
        sentinel;

    this.__initialize(root, visitor);

    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));

    while (worklist.length) {
        element = worklist.pop();

        if (element === sentinel) {
            element = leavelist.pop();

            ret = this.__execute(visitor.leave, element);

            if (this.__state === BREAK || ret === BREAK) {
                return;
            }
            continue;
        }

        if (element.node) {

            ret = this.__execute(visitor.enter, element);

            if (this.__state === BREAK || ret === BREAK) {
                return;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || ret === SKIP) {
                continue;
            }

            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = this.__fallback(node);
                } else {
                    throw new Error(&apos;Unknown node type &apos; + nodeType + &apos;.&apos;);
                }
            }

            current = candidates.length;
            while ((current -= 1) &gt;= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) &gt;= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], &apos;Property&apos;, null);
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, null));
                }
            }
        }
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    }

    return outer.root;
};

function traverse(root, visitor) {
    var controller = new Controller();
    return controller.<span class="apidocCodeKeywordSpan">traverse</span>(root, visitor);
}

function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.type" id="apidoc.elem.utility2.istanbul.estraverse.Controller.prototype.type">
        function <span class="apidocSignatureSpan">utility2.istanbul.estraverse.Controller.prototype.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    token = tokenStream.token();
    endChar = token.endChar;
    value = token.value + this._expr(inFunction).text;
    if (unary === null) {
        line = tokenStream.token().startLine;
        col = tokenStream.token().startCol;
    }
    tokenStream.mustMatch(Tokens.<span class="apidocCodeKeywordSpan">type</span>(endChar));
    value += endChar;
    this._readWhitespace();

//see if there&apos;s a simple match
} else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
        Tokens.ANGLE, Tokens.TIME,
        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.process" id="apidoc.module.utility2.istanbul.process">module utility2.istanbul.process</a></h1>




    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._debugEnd" id="apidoc.elem.utility2.istanbul.process._debugEnd">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _debugEnd() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._debugProcess" id="apidoc.elem.utility2.istanbul.process._debugProcess">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_debugProcess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _debugProcess() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._fatalException" id="apidoc.elem.utility2.istanbul.process._fatalException">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_fatalException
        <span class="apidocSignatureSpan">(er, fromPromise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(er, fromPromise) =&gt; {
  // It&apos;s possible that defaultTriggerAsyncId was set for a constructor
  // call that threw and was never cleared. So clear it now.
  clearDefaultTriggerAsyncId();

  // If diagnostic reporting is enabled, call into its handler to see
  // whether it is interested in handling the situation.
  // Ignore if the error is scoped inside a domain.
  // use == in the checks as we want to allow for null and undefined
  if (er == null || er.domain == null) {
    try {
      const report = internalBinding(&apos;report&apos;);
      if (report != null &amp;&amp; report.shouldReportOnUncaughtException()) {
        report.writeReport(er ? er.message : &apos;Exception&apos;,
                           &apos;Exception&apos;,
                           null,
                           er ? er.stack : undefined);
      }
    } catch {}  // Ignore the exception. Diagnostic reporting is unavailable.
  }

  const type = fromPromise ? &apos;unhandledRejection&apos; : &apos;uncaughtException&apos;;
  process.emit(&apos;uncaughtExceptionMonitor&apos;, er, type);
  if (exceptionHandlerState.captureFn !== null) {
    exceptionHandlerState.captureFn(er);
  } else if (!process.emit(&apos;uncaughtException&apos;, er, type)) {
    // If someone handled it, then great. Otherwise, die in C++ land
    // since that means that we&apos;ll exit the process, emit the &apos;exit&apos; event.
    try {
      if (!process._exiting) {
        process._exiting = true;
        process.exitCode = 1;
        process.emit(&apos;exit&apos;, 1);
      }
    } catch {
      // Nothing to be done about it at this point.
    }
    return false;
  }

  // If we handled an error, then make sure any ticks get processed
  // by ensuring that the next Immediate cycle isn&apos;t empty.
  require(&apos;timers&apos;).setImmediate(noop);

  // Emit the after() hooks now that the exception has been handled.
  if (afterHooksExist()) {
    do {
      emitAfter(executionAsyncId());
    } while (hasAsyncIdStack());
  // Or completely empty the id stack.
  } else {
    clearAsyncIdStack();
  }

  return true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._getActiveHandles" id="apidoc.elem.utility2.istanbul.process._getActiveHandles">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveHandles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getActiveHandles() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._getActiveRequests" id="apidoc.elem.utility2.istanbul.process._getActiveRequests">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_getActiveRequests
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getActiveRequests() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._kill" id="apidoc.elem.utility2.istanbul.process._kill">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_kill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _kill() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._linkedBinding" id="apidoc.elem.utility2.istanbul.process._linkedBinding">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_linkedBinding
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _linkedBinding(module) {
  module = String(module);
  let mod = bindingObj[module];
  if (typeof mod !== &apos;object&apos;)
    mod = bindingObj[module] = getLinkedBinding(module);
  return mod;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._rawDebug" id="apidoc.elem.utility2.istanbul.process._rawDebug">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_rawDebug
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _rawDebug(...args) {
  binding._rawDebug(format.apply(null, args));
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._startProfilerIdleNotifier" id="apidoc.elem.utility2.istanbul.process._startProfilerIdleNotifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_startProfilerIdleNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _startProfilerIdleNotifier() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._stopProfilerIdleNotifier" id="apidoc.elem.utility2.istanbul.process._stopProfilerIdleNotifier">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_stopProfilerIdleNotifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _stopProfilerIdleNotifier() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process._tickCallback" id="apidoc.elem.utility2.istanbul.process._tickCallback">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>_tickCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runNextTicks() {
  if (!hasTickScheduled() &amp;&amp; !hasRejectionToWarn())
    runMicrotasks();
  if (!hasTickScheduled() &amp;&amp; !hasRejectionToWarn())
    return;

  processTicksAndRejections();
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.abort" id="apidoc.elem.utility2.istanbul.process.abort">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abort() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">...
xhrInit();
// init timerTimeout
xhr.timerTimeout = setTimeout(function () {
    xhr.err = xhr.err || new Error(
        &quot;onTimeout - &quot;
        + timeout + &quot; ms - &quot; + &quot;ajax &quot; + xhr.method + &quot; &quot; + xhr.url
    );
    xhr.<span class="apidocCodeKeywordSpan">abort</span>();
    // cleanup reqStream and resStream
    streamCleanup(xhr.reqStream);
    streamCleanup(xhr.resStream);
}, timeout);
// increment cnt
ajaxProgressUpdate.cnt |= 0;
ajaxProgressUpdate.cnt += 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.assert" id="apidoc.elem.utility2.istanbul.process.assert">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated(...args) {
  if (!warned) {
    warned = true;
    if (code !== undefined) {
      if (!codesWarned.has(code)) {
        process.emitWarning(msg, &apos;DeprecationWarning&apos;, code, deprecated);
        codesWarned.add(code);
      }
    } else {
      process.emitWarning(msg, &apos;DeprecationWarning&apos;, deprecated);
    }
  }
  if (new.target) {
    return ReflectConstruct(fn, args, new.target);
  }
  return fn.apply(this, args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.binding" id="apidoc.elem.utility2.istanbul.process.binding">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>binding
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function binding(module) {
  module = String(module);
  // Deprecated specific process.binding() modules, but not all, allow
  // selective fallback to internalBinding for the deprecated ones.
  if (internalBindingWhitelist.has(module)) {
    return internalBinding(module);
  }
  // eslint-disable-next-line no-restricted-syntax
  throw new Error(`No such module: ${module}`);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
                &amp;&amp; typeof dict[key] === &quot;function&quot;
            ) {
                local[tmp][key] = local[tmp][key] || String(dict[key]);
            }
        });
    });
    Object.keys(local[tmp]).forEach(function (key) {
        if (process.<span class="apidocCodeKeywordSpan">binding</span>(&quot;natives&quot;)[key]) {
            local[tmp][key] = undefined;
        }
    });
});
// autofix - local-function
dictFnc = {};
dictProp = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.chdir" id="apidoc.elem.utility2.istanbul.process.chdir">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>chdir
        <span class="apidocSignatureSpan">(directory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrappedChdir(directory) {
  validateString(directory, &apos;directory&apos;);
  rawMethods.chdir(directory);
  // Mark cache that it requires an update.
  cachedCwd = &apos;&apos;;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.cpuUsage" id="apidoc.elem.utility2.istanbul.process.cpuUsage">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cpuUsage
        <span class="apidocSignatureSpan">(prevValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuUsage(prevValue) {
  // If a previous value was passed in, ensure it has the correct shape.
  if (prevValue) {
    if (!previousValueIsValid(prevValue.user)) {
      if (typeof prevValue !== &apos;object&apos;)
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue&apos;, &apos;object&apos;, prevValue);

      if (typeof prevValue.user !== &apos;number&apos;) {
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue.user&apos;,
                                       &apos;number&apos;, prevValue.user);
      }
      throw new ERR_INVALID_OPT_VALUE.RangeError(&apos;prevValue.user&apos;,
                                                 prevValue.user);
    }

    if (!previousValueIsValid(prevValue.system)) {
      if (typeof prevValue.system !== &apos;number&apos;) {
        throw new ERR_INVALID_ARG_TYPE(&apos;prevValue.system&apos;,
                                       &apos;number&apos;, prevValue.system);
      }
      throw new ERR_INVALID_OPT_VALUE.RangeError(&apos;prevValue.system&apos;,
                                                 prevValue.system);
    }
  }

  // Call the native function to get the current values.
  const errmsg = _cpuUsage(cpuValues);
  if (errmsg) {
    throw new ERR_CPU_USAGE(errmsg);
  }

  // If a previous value was passed in, return diff of current from previous.
  if (prevValue) {
    return {
      user: cpuValues[0] - prevValue.user,
      system: cpuValues[1] - prevValue.system
    };
  }

  // If no previous value passed in, return current value.
  return {
    user: cpuValues[0],
    system: cpuValues[1]
  };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.cwd" id="apidoc.elem.utility2.istanbul.process.cwd">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>cwd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrappedCwd() {
  if (cachedCwd === &apos;&apos;)
    cachedCwd = rawMethods.cwd();
  return cachedCwd;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
let code2;
let dictFnc;
let dictProp;
let tmp;
if (local.isBrowser) {
    return code;
}
file = local.path.resolve(file).replace(process.<span class="apidocCodeKeywordSpan">cwd</span>() + local.path.sep, &quot;&quot;);
switch (file) {
case &quot;README.md&quot;:
case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.js&quot;:
case &quot;lib.&quot; + process.env.npm_package_nameLib + &quot;.sh&quot;:
case &quot;lib.apidoc.js&quot;:
case &quot;lib.github_crud.js&quot;:
case &quot;lib.istanbul.js&quot;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.dlopen" id="apidoc.elem.utility2.istanbul.process.dlopen">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>dlopen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dlopen() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.emitWarning" id="apidoc.elem.utility2.istanbul.process.emitWarning">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>emitWarning
        <span class="apidocSignatureSpan">(warning, type, code, ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emitWarning(warning, type, code, ctor) {
  let detail;
  if (type !== null &amp;&amp; typeof type === &apos;object&apos; &amp;&amp; !ArrayIsArray(type)) {
    ctor = type.ctor;
    code = type.code;
    if (typeof type.detail === &apos;string&apos;)
      detail = type.detail;
    type = type.type || &apos;Warning&apos;;
  } else if (typeof type === &apos;function&apos;) {
    ctor = type;
    code = undefined;
    type = &apos;Warning&apos;;
  }
  if (type !== undefined &amp;&amp; typeof type !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_TYPE(&apos;type&apos;, &apos;string&apos;, type);
  }
  if (typeof code === &apos;function&apos;) {
    ctor = code;
    code = undefined;
  } else if (code !== undefined &amp;&amp; typeof code !== &apos;string&apos;) {
    throw new ERR_INVALID_ARG_TYPE(&apos;code&apos;, &apos;string&apos;, code);
  }
  if (typeof warning === &apos;string&apos;) {
    warning = createWarningObject(warning, type, code, ctor, detail);
  } else if (!(warning instanceof Error)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;warning&apos;, [&apos;Error&apos;, &apos;string&apos;], warning);
  }
  if (warning.name === &apos;DeprecationWarning&apos;) {
    if (process.noDeprecation)
      return;
    if (process.throwDeprecation)
      throw warning;
  }
  process.nextTick(doEmitWarning, warning);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.exit" id="apidoc.elem.utility2.istanbul.process.exit">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>exit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exit = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
* &lt;fileRemote|dirRemote&gt; &lt;commitMessage&gt;
* will delete from github &lt;fileRemote|dirRemote&gt;
*/
   local.github_crud.githubCrudContentDelete({
       message: process.argv[4],
       url: process.argv[3]
   }, function (err) {
       process.<span class="apidocCodeKeywordSpan">exit</span>(Boolean(err));
   });
};

local.cliDict.get = function () {
/*
* &lt;fileRemote&gt;
* will get from github &lt;fileRemote&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getegid" id="apidoc.elem.utility2.istanbul.process.getegid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getegid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getegid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.geteuid" id="apidoc.elem.utility2.istanbul.process.geteuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>geteuid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function geteuid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getgid" id="apidoc.elem.utility2.istanbul.process.getgid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getgid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getgroups" id="apidoc.elem.utility2.istanbul.process.getgroups">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getgroups
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getgroups() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.getuid" id="apidoc.elem.utility2.istanbul.process.getuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>getuid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getuid() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.hasUncaughtExceptionCaptureCallback" id="apidoc.elem.utility2.istanbul.process.hasUncaughtExceptionCaptureCallback">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hasUncaughtExceptionCaptureCallback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasUncaughtExceptionCaptureCallback() {
  return exceptionHandlerState.captureFn !== null;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.hrtime" id="apidoc.elem.utility2.istanbul.process.hrtime">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>hrtime
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hrtime(time) {
  _hrtime(hrValues);

  if (time !== undefined) {
    if (!ArrayIsArray(time)) {
      throw new ERR_INVALID_ARG_TYPE(&apos;time&apos;, &apos;Array&apos;, time);
    }
    if (time.length !== 2) {
      throw new ERR_OUT_OF_RANGE(&apos;time&apos;, 2, time.length);
    }

    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];
    const nsec = hrValues[2] - time[1];
    const needsBorrow = nsec &lt; 0;
    return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];
  }

  return [
    hrValues[0] * 0x100000000 + hrValues[1],
    hrValues[2]
  ];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.initgroups" id="apidoc.elem.utility2.istanbul.process.initgroups">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>initgroups
        <span class="apidocSignatureSpan">(user, extraGroup)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initgroups(user, extraGroup) {
  validateId(user, &apos;user&apos;);
  validateId(extraGroup, &apos;extraGroup&apos;);
  // Result is 0 on success, 1 if user is unknown, 2 if group is unknown.
  const result = _initgroups(user, extraGroup);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;User&apos;, user);
  } else if (result === 2) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;Group&apos;, extraGroup);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.kill" id="apidoc.elem.utility2.istanbul.process.kill">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>kill
        <span class="apidocSignatureSpan">(pid, sig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kill(pid, sig) {
  let err;

  // eslint-disable-next-line eqeqeq
  if (pid != (pid | 0)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;pid&apos;, &apos;number&apos;, pid);
  }

  // Preserve null signal
  if (sig === (sig | 0)) {
    // XXX(joyeecheung): we have to use process._kill here because
    // it&apos;s monkey-patched by tests.
    err = process._kill(pid, sig);
  } else {
    sig = sig || &apos;SIGTERM&apos;;
    if (constants[sig]) {
      err = process._kill(pid, constants[sig]);
    } else {
      throw new ERR_UNKNOWN_SIGNAL(sig);
    }
  }

  if (err)
    throw errnoException(err, &apos;kill&apos;);

  return true;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    stdio = [&apos;ignore&apos;, &apos;ignore&apos;, &apos;ignore&apos;, &apos;pipe&apos;, &apos;pipe&apos;];
}
const chromeProcess = childProcess.spawn(
    chromeExecutable,
    chromeArguments,
    {
      // On non-windows platforms, `detached: false` makes child process a leader of a new
      // process group, making it possible to kill child process tree with `.<span class="apidocCodeKeywordSpan">kill</span>(-pid
)` command.
      // @see https://nodejs.org/api/child_process.html#child_process_options_detached
      detached: process.platform !== &apos;win32&apos;,
      env,
      stdio
    }
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.memoryUsage" id="apidoc.elem.utility2.istanbul.process.memoryUsage">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>memoryUsage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoryUsage() {
  _memoryUsage(memValues);
  return {
    rss: memValues[0],
    heapTotal: memValues[1],
    heapUsed: memValues[2],
    external: memValues[3],
    arrayBuffers: memValues[4]
  };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.nextTick" id="apidoc.elem.utility2.istanbul.process.nextTick">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>nextTick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextTick(callback) {
  if (typeof callback !== &apos;function&apos;)
    throw new ERR_INVALID_CALLBACK(callback);

  if (process._exiting)
    return;

  let args;
  switch (arguments.length) {
    case 1: break;
    case 2: args = [arguments[1]]; break;
    case 3: args = [arguments[1], arguments[2]]; break;
    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;
    default:
      args = new Array(arguments.length - 1);
      for (let i = 1; i &lt; arguments.length; i++)
        args[i - 1] = arguments[i];
  }

  if (queue.isEmpty())
    setHasTickScheduled(true);
  const asyncId = newAsyncId();
  const triggerAsyncId = getDefaultTriggerAsyncId();
  const tickObject = {
    [async_id_symbol]: asyncId,
    [trigger_async_id_symbol]: triggerAsyncId,
    callback,
    args
  };
  if (initHooksExist())
    emitInit(asyncId, &apos;TickObject&apos;, triggerAsyncId, tickObject);
  queue.push(tickObject);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    //
    if (this.options.port != null) {
      server.close(() =&gt; this.emit(&apos;close&apos;));
      return;
    }
  }

  process.<span class="apidocCodeKeywordSpan">nextTick</span>(emitClose, this);
}

/**
 * See if a given request should be handled by this server instance.
 *
 * @param {http.IncomingMessage} req Request object to inspect
 * @return {Boolean} `true` if the request is valid, else `false`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.openStdin" id="apidoc.elem.utility2.istanbul.process.openStdin">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>openStdin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
  process.stdin.resume();
  return process.stdin;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.reallyExit" id="apidoc.elem.utility2.istanbul.process.reallyExit">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>reallyExit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reallyExit() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.resourceUsage" id="apidoc.elem.utility2.istanbul.process.resourceUsage">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>resourceUsage
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resourceUsage() {
  _resourceUsage(resourceValues);
  return {
    userCPUTime: resourceValues[0],
    systemCPUTime: resourceValues[1],
    maxRSS: resourceValues[2],
    sharedMemorySize: resourceValues[3],
    unsharedDataSize: resourceValues[4],
    unsharedStackSize: resourceValues[5],
    minorPageFault: resourceValues[6],
    majorPageFault: resourceValues[7],
    swappedOut: resourceValues[8],
    fsRead: resourceValues[9],
    fsWrite: resourceValues[10],
    ipcSent: resourceValues[11],
    ipcReceived: resourceValues[12],
    signalsCount: resourceValues[13],
    voluntaryContextSwitches: resourceValues[14],
    involuntaryContextSwitches: resourceValues[15]
  };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setUncaughtExceptionCaptureCallback" id="apidoc.elem.utility2.istanbul.process.setUncaughtExceptionCaptureCallback">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setUncaughtExceptionCaptureCallback
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(fn) {
  const err = new ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE();
  err.stack = err.stack + &apos;\n&apos; + &apos;-&apos;.repeat(40) + &apos;\n&apos; + domainRequireStack;
  throw err;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setegid" id="apidoc.elem.utility2.istanbul.process.setegid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setegid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.seteuid" id="apidoc.elem.utility2.istanbul.process.seteuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>seteuid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setgid" id="apidoc.elem.utility2.istanbul.process.setgid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setgroups" id="apidoc.elem.utility2.istanbul.process.setgroups">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setgroups
        <span class="apidocSignatureSpan">(groups)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setgroups(groups) {
  if (!ArrayIsArray(groups)) {
    throw new ERR_INVALID_ARG_TYPE(&apos;groups&apos;, &apos;Array&apos;, groups);
  }
  for (let i = 0; i &lt; groups.length; i++) {
    validateId(groups[i], `groups[${i}]`);
  }
  // Result is 0 on success. A positive integer indicates that the
  // corresponding group was not found.
  const result = _setgroups(groups);
  if (result &gt; 0) {
    throw new ERR_UNKNOWN_CREDENTIAL(&apos;Group&apos;, groups[result - 1]);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.setuid" id="apidoc.elem.utility2.istanbul.process.setuid">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>setuid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(id) {
  validateId(id, &apos;id&apos;);
  // Result is 0 on success, 1 if credential is unknown.
  const result = method(id);
  if (result === 1) {
    throw new ERR_UNKNOWN_CREDENTIAL(type, id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.umask" id="apidoc.elem.utility2.istanbul.process.umask">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>umask
        <span class="apidocSignatureSpan">(mask)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrappedUmask(mask) {
  if (mask !== undefined) {
    mask = parseFileMode(mask, &apos;mask&apos;);
  }
  return rawMethods.umask(mask);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.process.uptime" id="apidoc.elem.utility2.istanbul.process.uptime">
        function <span class="apidocSignatureSpan">utility2.istanbul.process.</span>uptime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uptime() { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.istanbul.require" id="apidoc.module.utility2.istanbul.require">module utility2.istanbul.require</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require.require" id="apidoc.elem.utility2.istanbul.require.require">
        function <span class="apidocSignatureSpan">utility2.istanbul.</span>require
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function require(path) {
  return mod.require(path);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
}).slice(0, 256).map(readExample);
// init moduleMain
local.tryCatchOnError(function () {
    console.error(&quot;apidocCreate - requiring &quot; + opt.dir + &quot; ...&quot;);
    moduleMain = {};
    moduleMain = (
        opt.moduleDict[opt.env.npm_package_name]
        || opt.<span class="apidocCodeKeywordSpan">require</span>(opt.dir)
        || opt.require(
            opt.dir + &quot;/&quot;
            + (opt.packageJson.bin)[Object.keys(opt.packageJson.bin)[0]]
        ) || {}
    );
    opt.circularSet.add(moduleMain);
    console.error(&quot;apidocCreate - ... required &quot; + opt.dir);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.istanbul.require.resolve" id="apidoc.elem.utility2.istanbul.require.resolve">
        function <span class="apidocSignatureSpan">utility2.istanbul.require.</span>resolve
        <span class="apidocSignatureSpan">(request, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(request, options) {
  validateString(request, &apos;request&apos;);
  return Module._resolveFilename(request, mod, false, options);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
let fs;
// do nothing if module does not exist
try {
    fs = require(&quot;fs&quot;);
} catch (ignore) {
    return dflt;
}
pathname = require(&quot;path&quot;).<span class="apidocCodeKeywordSpan">resolve</span>(pathname);
// try to read pathname
try {
    return (
        type === &quot;json&quot;
        ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
        : fs.readFileSync(pathname, type)
    );
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint" id="apidoc.module.utility2.jslint">module utility2.jslint</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.jslint.assert" id="apidoc.elem.utility2.jslint.assert">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.assertOrThrow" id="apidoc.elem.utility2.jslint.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;msg&gt; if &lt;passed&gt; is falsy
 */
</span>    if (passed) {
        return;
    }
    throw (
        (
            msg
            &amp;&amp; typeof msg.message === &quot;string&quot;
            &amp;&amp; typeof msg.stack === &quot;string&quot;
        )
        // if msg is err, then leave as is
        ? msg
        : new Error(
            typeof msg === &quot;string&quot;
            // if msg is a string, then leave as is
            ? msg
            // else JSON.stringify msg
            : JSON.stringify(msg, undefined, 4)
        )
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(str).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.cliRun" id="apidoc.elem.utility2.jslint.cliRun">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let str;
        let strDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            str = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(str);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(str).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        str = &quot;&quot;;
        str += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        str += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file
                + &quot;  &quo...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.coalesce" id="apidoc.elem.utility2.jslint.coalesce">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(str);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.events" id="apidoc.elem.utility2.jslint.events">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>events
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.fsReadFileOrDefaultSync" id="apidoc.elem.utility2.jslint.fsReadFileOrDefaultSync">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>fsReadFileOrDefaultSync
        <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrDefaultSync = function (pathname, type, dflt) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync-read &lt;pathname&gt; with given &lt;type&gt; and &lt;dflt&gt;
 */
</span>    let fs;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;ignore&quot;, &quot;ignore&quot;, 2
        ]
    });
}
if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
    // init assets index.html
    local.assetsDict[&quot;/index.html&quot;] = (
        local.<span class="apidocCodeKeywordSpan">fsReadFileOrDefaultSync</span>(&quot;index.html&quot;, &quot;utf8&quot;, &quot
;&quot;)
        || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
    );
    local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
    local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
        __filename,
        &quot;utf8&quot;
    ).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.fsRmrfSync" id="apidoc.elem.utility2.jslint.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(pathname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (pathname) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;pathname&gt;
 */
</span>    let child_process;
    // do nothing if module does not exist
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    if (process.platform !== &quot;win32&quot;) {
        child_process.spawnSync(&quot;rm&quot;, [
            &quot;-rf&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        });
        return;
    }
    try {
        child_process.spawnSync(&quot;rd&quot;, [
            &quot;/s&quot;, &quot;/q&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, &quot;ignore&quot;
            ]
        });
    } catch (ignore) {}
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.jslint.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(pathname, data, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (pathname, data, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;pathname&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    let success;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
        success = true;
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require(&quot;path&quot;).dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    || local.env.npm_config_mode_test_case
    !== &quot;testCase_buildApidoc_default&quot;
) {
    onError(undefined, opt);
    return;
}
// save apidoc.html
local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
    &quot;tmp/build/apidoc.html&quot;,
    local.apidocCreate(local.objectAssignDefault(opt, {
        blacklistDict: local,
        require: require2
    })),
    &quot;wrote file apidoc - {{pathname}}&quot;
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.identity" id="apidoc.elem.utility2.jslint.identity">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintAndPrint" id="apidoc.elem.utility2.jslint.jslintAndPrint">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrint
        <span class="apidocSignatureSpan">(code = &quot;&quot;, file = &quot;undefined&quot;, opt = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAndPrint = function (code = &quot;&quot;, file = &quot;undefined&quot;, opt = {}) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint/csslint &lt;code&gt; and print any errors to stderr
 */
</span>    let ii;
    let tmp;
    if (!(opt &amp;&amp; opt.gotoState)) {
        local.jslintResult = {
            gotoState: 0
        };
    }
    opt = Object.assign(local.jslintResult, opt);
    opt.gotoState += 1;
    switch (opt.gotoState) {
    // jslint - init
    case 1:
        // cleanup
        opt.errList = [];
        opt.errMsg = &quot;&quot;;
        // preserve lineno
        if (opt.iiStart) {
            opt.lineOffset |= 0;
            ii = 0;
            while (true) {
                ii = code.indexOf(&quot;\n&quot;, ii);
                if (ii === 0 || ii &gt; opt.iiStart) {
                    break;
                }
                ii += 1;
                opt.lineOffset += 1;
            }
            code = code.slice(opt.iiStart, opt.iiEnd || code.length);
        }
        switch (opt.fileType0) {
        // de-embed-js - &apos;\\n\\\n...\\n\\\n&apos;
        case &quot;.\\n\\&quot;:
            // rgx - remove \\n\\
            code = code.replace((
                /\\n\\$|\\(.)/gm
            ), function (ignore, match1) {
                return match1 || &quot;&quot;;
            });
            break;
        // de-embed-js - &apos;\n...\n&apos;
        case &quot;.sh&quot;:
            // rgx - convert &apos;&quot;&apos;&quot;&apos; to &apos;
            code = code.replace((
                /&apos;&quot;&apos;&quot;&apos;/g
            ), &quot;&apos;&quot;);
            break;
        }
        // init
        opt = Object.assign(opt, {
            &quot;.css&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.html&quot;: (
                /^\/\*csslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.js&quot;: (
                /^\/\*jslint\b|(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.json&quot;: (
                /^\s*?(?:\[|\{)/
            ),
            &quot;.md&quot;: (
                /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/$)/m
            ),
            &quot;.sh&quot;: (
                /(^#\u0020jslint\u0020utility2:true$)/m
            ),
            code0: code,
            fileType: (
                /\.\w+?$|$/m
            ).exec(file)[0]
        });
        // jslint - .json
        if (opt.fileType === &quot;.js&quot; &amp;&amp; opt[&quot;.json&quot;].test(code)) {
            opt.fileType = &quot;.json&quot;;
        }
        try {
            opt.conditionalPassed = opt[opt.fileType].exec(code);
        } catch (ignore) {}
        opt.utility2 = (
            opt.conditionalPassed &amp;&amp; opt.conditionalPassed[1]
        ) || opt.autofix;
        if (
            opt.conditional
            &amp;&amp; (!opt.conditionalPassed || opt.coverage)
        ) {
            break;
        }
        opt.gotoState = 10;
        break;
    // jslint - autofix
    case 11:
        code = local.jslintAutofix(code, file, opt);
        local.jslintResult = opt;
        break;
    // jslint - csslint and jslint
    case 12:
        // restore lineOffset
        code = &quot;\n&quot;.repeat(opt.lineOffset | 0) + code;
        switch (opt.fileType) {
        case &quot;.css&quot;:
            // csslint
            Object.assign(opt, local.CSSLint.verify(code));
            // init errList
            opt.errList = opt.messages.map(function (err) {
                err.column = err.col;
                err.message = (
                    err.type + &quot; - &quot; + err.rule.id + &quot; - &quot; + err.message
                    + &quot;\n    &quot; + err.rule.desc
                );
                return err;
            });
            break;
        case &quot;.html&quot;:
        case &quot;.md&quot;:
        case &quot;.sh&quot;:
            break;
        default:
            // jslint - .js...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return;
    }
    // read file
    local.fs.readFile(opt.file, &quot;utf8&quot;, opt.gotoNext);
    break;
case 2:
    // jslint
    local.jslint.<span class="apidocCodeKeywordSpan">jslintAndPrint</span>(data, opt.file);
    local.assertOrThrow(
        !local.jslint.jslintResult.errMsg,
        local.jslint.jslintResult.errMsg.replace((
            /\u001b\[\d*m/g
        ), &quot;&quot;)
    );
    // validate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintAndPrintDir" id="apidoc.elem.utility2.jslint.jslintAndPrintDir">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAndPrintDir
        <span class="apidocSignatureSpan">(dir, opt, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAndPrintDir = function (dir, opt, onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint files in shallow &lt;dir&gt;
 */
</span>    let onParallel;
    onParallel = local.onParallel(onError);
    local.fs.readdirSync(dir).forEach(function (file) {
        let timeStart;
        file = local.path.resolve(file);
        switch ((
            /\.\w+?$|$/m
        ).exec(file)[0]) {
        case &quot;.css&quot;:
        case &quot;.html&quot;:
        case &quot;.js&quot;:
        case &quot;.json&quot;:
        case &quot;.md&quot;:
        case &quot;.sh&quot;:
            if ((
                /\b(?:assets\.app\.js|lock|min|raw|rollup)\b/
            ).test(file)) {
                return;
            }
            onParallel.cnt += 1;
            // jslint file
            local.fs.readFile(file, &quot;utf8&quot;, function (err, data) {
                // handle err
                local.assertOrThrow(!err, err);
                timeStart = Date.now();
                local.jslintAndPrint(data, file, opt);
                console.error(
                    &quot;jslint - &quot; + (Date.now() - timeStart) + &quot;ms &quot; + file
                );
                onParallel();
            });
            break;
        }
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
});
// jslint process.cwd()
if (!local.env.npm_config_mode_library) {
    local.child_process.spawn(&quot;node&quot;, [
        &quot;-e&quot;, (
            &quot;require(&quot;
            + JSON.stringify(__filename)
            + &quot;).jslint.<span class="apidocCodeKeywordSpan">jslintAndPrintDir</span>(&quot;
            + JSON.stringify(process.cwd())
            + &quot;, {autofix:true,conditional:true}, process.exit);&quot;
        )
    ], {
        env: Object.assign({}, local.env, {
            npm_config_mode_library: &quot;1&quot;
        }),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintAutofix" id="apidoc.elem.utility2.jslint.jslintAutofix">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintAutofix
        <span class="apidocSignatureSpan">(code, file, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintAutofix = function (code, file, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint-autofix &lt;code&gt;
 */
</span>    let code0;
    let code2;
    let dataList;
    let ignoreList;
    let ii;
    let rgx1;
    let rgx2;
    let tmp;
    // autofix-all
    if (opt.autofix) {
        // autofix-all - normalize local-function
        if (
            globalThis.utility2
            &amp;&amp; typeof globalThis.utility2.jslintAutofixLocalFunction
            === &quot;function&quot;
        ) {
            code = globalThis.utility2.jslintAutofixLocalFunction(code, file);
        }
        // autofix-all - remove trailing-whitespace
        code = code.replace((
            /\u0020+$/gm
        ), &quot;&quot;);
        // autofix-all - remove leading-whitespace before )]}
        code = code.replace((
            /\n+?(\n\u0020*?[)\]}])/g
        ), &quot;$1&quot;);
        // autofix-all - normalize newlines to \n\n
        code = code.replace((
            /([^\n])\n{3}([^\n])/g
        ), &quot;$1\n\n$2&quot;);
        // autofix-all - normalize newlines to \n\n\n\n
        code = code.replace((
            /\n{5,}/g
        ), &quot;\n\n\n\n&quot;);
        // autofix-all - recurse &lt;script&gt;...&lt;/script&gt;, &lt;style&gt;...&lt;/style&gt;
        code = code.replace((
            /(^\/\*\u0020jslint\u0020utility2:true\u0020\*\/\\n\\\n(?:^.*?\\n\\\n)*?)(&apos;;$|&lt;\/script&gt;\\n\\$|&lt;\/style&gt;\\n\\$)/gm
        ), function (ignore, match1, match2, ii) {
            return local.jslintAndPrint(
                code,
                file + (
                    match2.indexOf(&quot;style&quot;) &gt; -1
                    ? &quot;.&lt;style&gt;.css&quot;
                    : &quot;.&lt;script&gt;.js&quot;
                ),
                Object.assign({}, opt, {
                    fileType0: &quot;.\\n\\&quot;,
                    iiEnd: ii + match1.length,
                    iiStart: ii,
                    gotoState: 0
                })
            ) + match2;
        });
    }
    switch (opt.autofix &amp;&amp; opt.fileType) {
    case &quot;.css&quot;:
        break;
    case &quot;.html&quot;:
        // autofix-html - recurse &lt;script&gt;...&lt;/script&gt;, &lt;style&gt;...&lt;/style&gt;
        code = code.replace((
            /^(\/\*\u0020jslint\u0020utility2:true\u0020\*\/\n[\S\s]*?\n)(&lt;\/(?:script|style)&gt;)$/gm
        ), function (ignore, match1, match2, ii) {
            return local.jslintAndPrint(
                code,
                file + (
                    match2.indexOf(&quot;style&quot;) &gt;= 0
                    ? &quot;.&lt;style&gt;.css&quot;
                    : &quot;.&lt;script&gt;.js&quot;
                ),
                Object.assign({}, opt, {
                    fileType0: opt.fileType,
                    iiEnd: ii + match1.length,
                    iiStart: ii,
                    gotoState: 0
                })
            ) + match2;
        });
        break;
    case &quot;.js&quot;:
    case &quot;.json&quot;:
        // autofix-js - demux code to [code, ignoreList]
        ignoreList = [];
        code = code.replace((
            /^\u0020*?\/\*\u0020jslint\u0020ignore:start\u0020\*\/$[\S\s]*?^\/\*\u0020jslint\u0020ignore:end\u0020\*\/$/gm
        ), function (match0) {
            ignoreList.push(match0);
            return &quot;/* jslint ignore:start:end */&quot;;
        });
        // autofix-js - escape non-ascii
        code = code.replace((
            /[^\n\r\t\u0020-\u007e]/g
        ), function (match0) {
            return &quot;\\u&quot; + (
                &quot;0000&quot;
                + match0.charCodeAt(0).toString(16)
            ).slice(-4);
        });
        // autofix-js - demux code2 to [code2, ignoreList]
        code2 = &quot;&quot;;
        dataList = [];
        ii = 0;
        rgx1 = (
            /\\.|\/\*|\*\/|\/\/!!|\/\/|[&quot;&apos;\/`]|$/gm
        );
        // parse rgx
        // https://github.com/douglascrockford/JSLint/blob/557afd32bcaa35480d31a86f02d3a8c06a4e5b5c/jslin...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintGetColumnLine" id="apidoc.elem.utility2.jslint.jslintGetColumnLine">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintGetColumnLine
        <span class="apidocSignatureSpan">(code, ii)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintGetColumnLine = function (code, ii) {
<span class="apidocCodeCommentSpan">/*
 * this function will transform &lt;code&gt; and &lt;ii&gt; to {column, line, evidence}
 */
</span>    let column;
    let evidence;
    let line;
    evidence = code.slice(0, ii).split(&quot;\n&quot;);
    line = evidence.length - 1;
    column = evidence[line].length;
    evidence = evidence[line] + code.slice(ii, ii + 100).split(&quot;\n&quot;)[0];
    return {
        column,
        evidence,
        line
    };
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslintUtility2" id="apidoc.elem.utility2.jslint.jslintUtility2">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslintUtility2
        <span class="apidocSignatureSpan">(code, ignore, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslintUtility2 = function (code, ignore, opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will jslint &lt;code&gt; with utiity2-specific rules
 */
</span>    let code2;
    let err;
    let indent;
    let previous;
    // jslintUtility2 - all
    if (opt.utility2) {
        code2 = code;
        // ignore start to end
        code2 = code2.replace((
            /^\/\*\u0020jslint\u0020ignore:start\u0020\*\/$[\S\s]+?^\/\*\u0020jslint\u0020ignore:end\u0020\*\/$/gm
        ), function (match0) {
            // preserve lineno
            return match0.replace((
                /.+/g
            ), &quot;&quot;);
        });
        // lint whitespace
        code2.replace((
            /^\u0020+?(?:\*|\/\/!!)|^\u0020+|[\r\t]/gm
        ), function (match0, ii) {
            switch (match0.slice(-1)) {
            case &quot; &quot;:
                if (match0.length % 4 === 0) {
                    return &quot;&quot;;
                }
                err = {
                    message: &quot;non 4-space indent&quot;
                };
                break;
            case &quot;\r&quot;:
                err = {
                    message: &quot;unexpected \\r&quot;
                };
                break;
            case &quot;\t&quot;:
                err = {
                    message: &quot;unexpected \\t&quot;
                };
                break;
            default:
                return &quot;&quot;;
            }
            Object.assign(err, local.jslintGetColumnLine(code2, ii));
            opt.errList.push({
                column: err.column + 1,
                evidence: JSON.stringify(err.evidence),
                line: err.line + 1,
                message: err.message
            });
            return &quot;&quot;;
        });
    }
    switch (opt.utility2 &amp;&amp; opt.fileType) {
    // jslintUtility2 - .css
    case &quot;.css&quot;:
        // ignore comment
        code2 = code2.replace((
            /^\u0020*?\/\*[\S\s]*?\*\/\u0020*?$/gm
        ), function (match0) {
            // preserve lineno
            return match0.replace((
                /.+/g
            ), &quot;&quot;);
        });
        code2.replace((
            /\S\u0020{2}|\u0020,|^\S.*?[,;{}]./gm
        ), function (match0, ii) {
            switch (match0.slice(-2)) {
            case &quot;  &quot;:
                err = {
                    colOffset: 2,
                    message: &quot;unexpected multi-whitespace&quot;
                };
                break;
            case &quot; ,&quot;:
                err = {
                    colOffset: 1,
                    message: &quot;unexpected whitespace before comma&quot;
                };
                break;
            default:
                err = {
                    colOffset: match0.length,
                    message: &quot;unexpected multiline-statement&quot;
                };
            }
            Object.assign(err, local.jslintGetColumnLine(code2, ii));
            opt.errList.push({
                column: err.column + err.colOffset,
                evidence: JSON.stringify(err.evidence),
                line: err.line + 1,
                message: err.message
            });
            return &quot;&quot;;
        });
        // validate line-sorted - css-selector
        previous = &quot;&quot;;
        code2 = code2.replace((
            /^.|[#.&gt;]|[,}]$|\u0020\{$|\b\w/gm
        ), function (match0) {
            switch (match0) {
            case &quot; &quot;:
                return match0;
            case &quot; {&quot;:
                return &quot;\u0001&quot; + match0;
            case &quot;#&quot;:
                return &quot;\u0002&quot; + match0;
            case &quot;,&quot;:
                return &quot;\u0000&quot; + match0;
            case &quot;.&quot;:
                return &quot;\u0001&quot; + match0;
            case &quot;&gt;&quot;:
                return &quot;\u0003&quot; + match0;
            case &quot;}&quot;:
                return match0;
            default:...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jslint_export" id="apidoc.elem.utility2.jslint.jslint_export">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jslint_export
        <span class="apidocSignatureSpan">( source = &quot;&quot;, option_object = empty()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jslint_export = function ( source = &quot;&quot;, option_object = empty(),
    global_array = []
) {
    // hack-jslint - init lines_extra
    line_ignore = undefined;
    lines = (
        Array.isArray(source)
        ? source
        : source.split(
            /\n|\r\n?/
        )
    );
    lines_extra = lines.map(function () {
        return {};
    });
    try {
        warnings = [];
        option = Object.assign(empty(), option_object);
        anon = &quot;anonymous&quot;;
        block_stack = [];
        declared_globals = empty();
        directive_mode = true;
        directives = [];
        early_stop = true;
        exports = empty();
        froms = [];
        fudge = (
            option.fudge
            ? 1
            : 0
        );
        functions = [];
        global = {
            id: &quot;(global)&quot;,
            body: true,
            context: empty(),
            from: 0,
            level: 0,
            line: 0,
            live: [],
            loop: 0,
            switch: 0,
            thru: 0
        };
        blockage = global;
        functionage = global;
        json_mode = false;
        mega_mode = false;
        module_mode = false;
        next_token = global;
        property = empty();
        shebang = false;
        stack = [];
        tenure = undefined;
        token = global;
        token_nr = 0;
        var_mode = undefined;
        populate(standard, declared_globals, false);
        populate(global_array, declared_globals, false);
        Object.keys(option).forEach(function (name) {
            if (option[name] === true) {
                const allowed = allowed_option[name];
                if (Array.isArray(allowed)) {
                    populate(allowed, declared_globals, false);
                }
            }
        });
        tokenize(source);
        advance();
        if (json_mode) {
            tree = json_value();
            advance(&quot;(end)&quot;);
        } else {

// Because browsers encourage combining of script files, the first token might
// be a semicolon to defend against a missing semicolon in the preceding file.

            if (option.browser) {
                if (next_token.id === &quot;;&quot;) {
                    advance(&quot;;&quot;);
                }
            } else {

// If we are not in a browser, then the file form of strict pragma may be used.

                if (
                    next_token.value === &quot;use strict&quot;
                ) {
                    advance(&quot;(string)&quot;);
                    advance(&quot;;&quot;);
                }
            }
            tree = statements();
            advance(&quot;(end)&quot;);
            functionage = global;
            walk_statement(tree);
            if (warnings.length === 0) {
                uninitialized_and_unused();
                if (!option.white) {
                    whitage();
                }
            }
        }
        if (!option.browser) {
            directives.forEach(function (comment) {
                if (comment.directive === &quot;global&quot;) {
                    warn(&quot;missing_browser&quot;, comment);
                }
            });
        }
        early_stop = false;
    } catch (e) {
        // hack-jslint - early_stop
        e.early_stop = true;
        e.column = e.column || -1;
        e.line = e.line || -1;
        if (e.name !== &quot;JSLintError&quot;) {
            warnings.push(e);
        }
    }
    // hack-jslint - autofix
    warnings = warnings.filter(function (warning) {
        let indent;
        warning.source = warning.source || &quot;&quot;;
        warning.a = warning.a || warning.source.trim();
        switch (option.autofix &amp;&amp; warning.code) {
        // expected_a_at_b_c: &quot;Expected &apos;{a}&apos; at column {b}, not column {c}.&quot;,
        case &quot;expected_a_at_b_c&quot;:
            // autofix indent - increment
            indent = warning.b - warning.c;
            if (indent &gt;= 0) {
                lines_extra[warning.line].source_autofixed = (...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.jsonStringifyOrdered" id="apidoc.elem.utility2.jslint.jsonStringifyOrdered">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>jsonStringifyOrdered
        <span class="apidocSignatureSpan">(obj, replacer, space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsonStringifyOrdered = function (obj, replacer, space) {
<span class="apidocCodeCommentSpan">/*
 * this function will JSON.stringify &lt;obj&gt;,
 * with object-keys sorted and circular-references removed
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Syntax
 */
</span>    let circularSet;
    let stringify;
    let tmp;
    stringify = function (obj) {
    /*
     * this function will recursively JSON.stringify obj,
     * with object-keys sorted and circular-references removed
     */
        // if obj is not an object or function,
        // then JSON.stringify as normal
        if (!(
            obj
            &amp;&amp; typeof obj === &quot;object&quot;
            &amp;&amp; typeof obj.toJSON !== &quot;function&quot;
        )) {
            return JSON.stringify(obj);
        }
        // ignore circular-reference
        if (circularSet.has(obj)) {
            return;
        }
        circularSet.add(obj);
        // if obj is an array, then recurse items
        if (Array.isArray(obj)) {
            tmp = &quot;[&quot; + obj.map(function (obj) {
                // recurse
                tmp = stringify(obj);
                return (
                    typeof tmp === &quot;string&quot;
                    ? tmp
                    : &quot;null&quot;
                );
            }).join(&quot;,&quot;) + &quot;]&quot;;
            circularSet.delete(obj);
            return tmp;
        }
        // if obj is not an array,
        // then recurse its items with object-keys sorted
        tmp = &quot;{&quot; + Object.keys(obj).sort().map(function (key) {
            // recurse
            tmp = stringify(obj[key]);
            if (typeof tmp === &quot;string&quot;) {
                return JSON.stringify(key) + &quot;:&quot; + tmp;
            }
        }).filter(function (obj) {
            return typeof obj === &quot;string&quot;;
        }).join(&quot;,&quot;) + &quot;}&quot;;
        circularSet.delete(obj);
        return tmp;
    };
    circularSet = new Set();
    return JSON.stringify((
        (typeof obj === &quot;object&quot; &amp;&amp; obj)
        // recurse
        ? JSON.parse(stringify(obj))
        : obj
    ), replacer, space);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
&lt;!-- swgg-script-extra-end --&gt;\n\
&lt;/body&gt;\n\
&lt;/html&gt;\n\
&apos;);
/* jslint ignore:end */
local.assetsDict[
&quot;/assets.swgg.swagger.schema.json&quot;
] = local.<span class="apidocCodeKeywordSpan">jsonStringifyOrdered</span>(
local.objectAssignRecurse(
    JSON.parse(local.assetsDict[&quot;/assets.swgg.json-schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
    JSON.parse(local.assetsDict[&quot;/assets.swgg.schema.json&quot;].replace((
        /&quot;\$ref&quot;:&quot;.*?#/g
    ), &quot;\&quot;$ref\&quot;:\&quot;http://json-schema.org/draft-04/schema#&quot;)),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.nop" id="apidoc.elem.utility2.jslint.nop">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - function
(function () {
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(require);
globalThis.__coverageInclude__ = local.coalesce(
globalThis.__coverageInclude__,
{}
);
// mock builtins
process = local.process || {
cwd: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.objectAssignDefault" id="apidoc.elem.utility2.jslint.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (tgt = {}, src = {}, depth = 0) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;tgt&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;src&gt;
 */
</span>    let recurse;
    recurse = function (tgt, src, depth) {
        Object.entries(src).forEach(function ([
            key, bb
        ]) {
            let aa;
            aa = tgt[key];
            if (aa === undefined || aa === null || aa === &quot;&quot;) {
                tgt[key] = bb;
                return;
            }
            if (
                depth !== 0
                &amp;&amp; typeof aa === &quot;object&quot; &amp;&amp; aa &amp;&amp; !Array.isArray(aa)
                &amp;&amp; typeof bb === &quot;object&quot; &amp;&amp; bb &amp;&amp; !Array.isArray(bb)
            ) {
                recurse(aa, bb, depth - 1);
            }
        });
    };
    recurse(tgt, src, depth | 0);
    return tgt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return str;
};
// init opt
opt.dir = local.moduleDirname(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.parse(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.onErrorWithStack" id="apidoc.elem.utility2.jslint.onErrorWithStack">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>onErrorWithStack
        <span class="apidocSignatureSpan">(onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onErrorWithStack = function (onError) {
<span class="apidocCodeCommentSpan">/*
 * this function will wrap &lt;onError&gt; with wrapper preserving current-stack
 */
</span>    let onError2;
    let stack;
    stack = new Error().stack;
    onError2 = function (err, data, meta) {
        // append current-stack to err.stack
        if (
            err
            &amp;&amp; typeof err.stack === &quot;string&quot;
            &amp;&amp; err !== local.errorDefault
        ) {
            err.stack += &quot;\n&quot; + stack;
        }
        onError(err, data, meta);
    };
    // debug onError
    onError2.toString = function () {
        return String(onError);
    };
    return onError2;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

local.gotoNext = function (opt, onError) {
/*
* this function will wrap onError inside recursive-function &lt;opt&gt;.gotoNext,
* and append current-stack to any err
*/
   opt.gotoNext = local.<span class="apidocCodeKeywordSpan">onErrorWithStack</span>(function (err, data, meta) {
       try {
           opt.gotoState += (
               (err &amp;&amp; !opt.modeErrorIgnore)
               ? 1000
               : 1
           );
           if (opt.modeDebug) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.onParallel" id="apidoc.elem.utility2.jslint.onParallel">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>onParallel
        <span class="apidocSignatureSpan">(onError, onEach, onRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParallel = function (onError, onEach, onRetry) {
<span class="apidocCodeCommentSpan">/*
 * this function will create a function that will
 * 1. run async tasks in parallel
 * 2. if cnt === 0 or err occurred, then call onError(err)
 */
</span>    let onParallel;
    onError = local.onErrorWithStack(onError);
    onEach = onEach || local.nop;
    onRetry = onRetry || local.nop;
    onParallel = function (err, data) {
        if (onRetry(err, data)) {
            return;
        }
        // decrement cnt
        onParallel.cnt -= 1;
        // validate cnt
        if (!(onParallel.cnt &gt;= 0 || err || onParallel.err)) {
            err = new Error(
                &quot;invalid onParallel.cnt = &quot; + onParallel.cnt
            );
        // ensure onError is run only once
        } else if (onParallel.cnt &lt; 0) {
            return;
        }
        // handle err
        if (err) {
            onParallel.err = err;
            // ensure cnt &lt;= 0
            onParallel.cnt = -Math.abs(onParallel.cnt);
        }
        // call onError when isDone
        if (onParallel.cnt &lt;= 0) {
            onError(err, data);
            return;
        }
        onEach();
    };
    // init cnt
    onParallel.cnt = 0;
    // return callback
    return onParallel;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            elem: opt.list[onParallel.ii],
            ii: onParallel.ii,
            list: opt.list,
            retry: 0
        }, onParallel);
    }
};
onParallel = local.<span class="apidocCodeKeywordSpan">onParallel</span>(onError, onEach2, function (err, data) {
    if (err &amp;&amp; data &amp;&amp; data.retry &lt; opt.retryLimit) {
        local.onErrorDefault(err);
        data.retry += 1;
        setTimeout(function () {
            onParallel.cnt -= 1;
            onEach(data, onParallel);
        }, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.stream" id="apidoc.elem.utility2.jslint.stream">
        function <span class="apidocSignatureSpan">utility2.jslint.</span>stream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream(opts) {
  EE.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint.CSSLint" id="apidoc.module.utility2.jslint.CSSLint">module utility2.jslint.CSSLint</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter" id="apidoc.elem.utility2.jslint.CSSLint._Reporter">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>_Reporter
        <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reporter(lines, ruleset, allow, ignore) {
    &quot;use strict&quot;;

<span class="apidocCodeCommentSpan">    /**
     * List of messages being reported.
     * @property messages
     * @type String[]
     */
</span>    this.messages = [];

    /**
     * List of statistics being reported.
     * @property stats
     * @type String[]
     */
    this.stats = [];

    /**
     * Lines of code being reported on. Used to provide contextual information
     * for messages.
     * @property lines
     * @type String[]
     */
    this.lines = lines;

    /**
     * Information about the rules. Used to determine whether an issue is an
     * error or warning.
     * @property ruleset
     * @type Object
     */
    this.ruleset = ruleset;

    /**
     * Lines with specific rule messages to leave out of the report.
     * @property allow
     * @type Object
     */
    this.allow = allow;
    if (!this.allow) {
        this.allow = {};
    }

    /**
     * Linesets not to include in the report.
     * @property ignore
     * @type [][]
     */
    this.ignore = ignore;
    if (!this.ignore) {
        this.ignore = [];
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.addFormatter" id="apidoc.elem.utility2.jslint.CSSLint.addFormatter">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addFormatter
        <span class="apidocSignatureSpan">(formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(formatter) {
    // formatters.push(formatter);
    formatters[formatter.id] = formatter;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.addRule" id="apidoc.elem.utility2.jslint.CSSLint.addRule">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>addRule
        <span class="apidocSignatureSpan">(rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(rule) {
    rules.push(rule);
    rules[rule.id] = rule;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.clearRules" id="apidoc.elem.utility2.jslint.CSSLint.clearRules">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>clearRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
    rules = [];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.format" id="apidoc.elem.utility2.jslint.CSSLint.format">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>format
        <span class="apidocSignatureSpan">(results, filename, formatId, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(results, filename, formatId, options) {
    var formatter = api.getFormatter(formatId),
        result = null;

    if (formatter) {
        result = formatter.startFormat();
        result += formatter.formatResults(results, filename, options || {});
        result += formatter.endFormat();
    }

    return result;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
    ws.protocol = protocol;
  }
}

if (extensions[PerMessageDeflate.extensionName]) {
  const params = extensions[PerMessageDeflate.extensionName].params;
  const value = extension.<span class="apidocCodeKeywordSpan">format</span>({
    [PerMessageDeflate.extensionName]: [params]
  });
  headers.push(`Sec-WebSocket-Extensions: ${value}`);
  ws._extensions = extensions;
}

//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.getFormatter" id="apidoc.elem.utility2.jslint.CSSLint.getFormatter">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getFormatter
        <span class="apidocSignatureSpan">(formatId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(formatId) {
    return formatters[formatId];
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.getRules" id="apidoc.elem.utility2.jslint.CSSLint.getRules">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
    return [].concat(rules).sort(function(a, b) {
        return a.id &gt; b.id ? 1 : 0;
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.getRuleset" id="apidoc.elem.utility2.jslint.CSSLint.getRuleset">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>getRuleset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function() {
    var ruleset = {},
        i = 0,
        len = rules.length;

    while (i &lt; len) {
        ruleset[rules[i++].id] = 1;    // by default, everything is a warning
    }

    return ruleset;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.hasFormat" id="apidoc.elem.utility2.jslint.CSSLint.hasFormat">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>hasFormat
        <span class="apidocSignatureSpan">(formatId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(formatId) {
    return formatters.hasOwnProperty(formatId);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint.verify" id="apidoc.elem.utility2.jslint.CSSLint.verify">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint.</span>verify
        <span class="apidocSignatureSpan">(text, ruleset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(text, ruleset) {

    var i = 0,
        reporter,
        lines,
        allow = {},
        ignore = [],
        report,
        parser = new parserlib.css.Parser({
            starHack: true,
            ieFilters: true,
            underscoreHack: true,
            strict: false
        });

    // normalize line endings
    lines = text.replace(/\n\r?/g, &quot;$split$&quot;).split(&quot;$split$&quot;);

    // find &apos;allow&apos; comments
    CSSLint.Util.forEach(lines, function (line, lineno) {
        var allowLine = line &amp;&amp; line.match(/\/\*[ \t]*csslint[ \t]+allow:[ \t]*([^\*]*)\*\//i),
            allowRules = allowLine &amp;&amp; allowLine[1],
            allowRuleset = {};

        if (allowRules) {
            allowRules.toLowerCase().split(&quot;,&quot;).forEach(function(allowRule) {
                allowRuleset[allowRule.trim()] = true;
            });
            if (Object.keys(allowRuleset).length &gt; 0) {
                allow[lineno + 1] = allowRuleset;
            }
        }
    });

    var ignoreStart = null,
        ignoreEnd = null;
    CSSLint.Util.forEach(lines, function (line, lineno) {
        // Keep oldest, &quot;unclosest&quot; ignore:start
        if (ignoreStart === null &amp;&amp; line.match(/\/\*[ \t]*csslint[ \t]+ignore:start[ \t]*\*\//i)) {
            ignoreStart = lineno;
        }

        if (line.match(/\/\*[ \t]*csslint[ \t]+ignore:end[ \t]*\*\//i)) {
            ignoreEnd = lineno;
        }

        if (ignoreStart !== null &amp;&amp; ignoreEnd !== null) {
            ignore.push([ignoreStart, ignoreEnd]);
            ignoreStart = ignoreEnd = null;
        }
    });

    // Close remaining ignore block, if any
    if (ignoreStart !== null) {
        ignore.push([ignoreStart, lines.length]);
    }

    if (!ruleset) {
        ruleset = api.getRuleset();
    }

    if (embeddedRuleset.test(text)) {
        // defensively copy so that caller&apos;s version does not get modified
        ruleset = clone(ruleset);
        ruleset = applyEmbeddedRuleset(text, ruleset);
    }

    reporter = new Reporter(lines, ruleset, allow, ignore);

    ruleset.errors = 2;       // always report parsing errors as errors
    for (i in ruleset) {
        if (ruleset.hasOwnProperty(i) &amp;&amp; ruleset[i]) {
            if (rules[i]) {
                rules[i].init(parser, reporter);
            }
        }
    }

    // capture most horrible error type
    try {
        parser.parse(text);
    } catch (ex) {
        reporter.error(&quot;Fatal error, cannot continue: &quot; + ex.message, ex.line, ex.col, {});
    }

    report = {
        messages    : reporter.messages,
        stats       : reporter.stats,
        ruleset     : reporter.ruleset,
        allow       : reporter.allow,
        ignore      : reporter.ignore
    };

    // sort by line numbers, rollups at the bottom
    report.messages.sort(function (a, b) {
        if (a.rollup &amp;&amp; !b.rollup) {
            return 1;
        } else if (!a.rollup &amp;&amp; b.rollup) {
            return -1;
        } else {
            return a.line - b.line;
        }
    });

    return report;
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint.CSSLint._Reporter.prototype" id="apidoc.module.utility2.jslint.CSSLint._Reporter.prototype">module utility2.jslint.CSSLint._Reporter.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.constructor" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.constructor">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>constructor
        <span class="apidocSignatureSpan">(lines, ruleset, allow, ignore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reporter(lines, ruleset, allow, ignore) {
    &quot;use strict&quot;;

<span class="apidocCodeCommentSpan">    /**
     * List of messages being reported.
     * @property messages
     * @type String[]
     */
</span>    this.messages = [];

    /**
     * List of statistics being reported.
     * @property stats
     * @type String[]
     */
    this.stats = [];

    /**
     * Lines of code being reported on. Used to provide contextual information
     * for messages.
     * @property lines
     * @type String[]
     */
    this.lines = lines;

    /**
     * Information about the rules. Used to determine whether an issue is an
     * error or warning.
     * @property ruleset
     * @type Object
     */
    this.ruleset = ruleset;

    /**
     * Lines with specific rule messages to leave out of the report.
     * @property allow
     * @type Object
     */
    this.allow = allow;
    if (!this.allow) {
        this.allow = {};
    }

    /**
     * Linesets not to include in the report.
     * @property ignore
     * @type [][]
     */
    this.ignore = ignore;
    if (!this.ignore) {
        this.ignore = [];
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.error" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.error">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>error
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;error&quot;,
        line    : line,
        col     : col,
        message : message,
        evidence: this.lines[line-1],
        rule    : rule || {}
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.<span class="apidocCodeKeywordSpan">error</span>(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
};
local.identity = function (val) {
/*
 * this function will return &lt;val&gt;
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.info" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.info">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>info
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;info&quot;,
        line    : line,
        col     : col,
        message : message,
        evidence: this.lines[line-1],
        rule    : rule
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.report" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.report">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>report
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;

    // Check if rule violation should be allowed
    if (this.allow.hasOwnProperty(line) &amp;&amp; this.allow[line].hasOwnProperty(rule.id)) {
        return;
    }

    var ignore = false;
    CSSLint.Util.forEach(this.ignore, function (range) {
        if (range[0] &lt;= line &amp;&amp; line &lt;= range[1]) {
            ignore = true;
        }
    });
    if (ignore) {
        return;
    }

    this.messages.push({
        type    : this.ruleset[rule.id] === 2 ? &quot;error&quot; : &quot;warning&quot;,
        line    : line,
        col     : col,
        message : message,
        evidence: this.lines[line-1],
        rule    : rule
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupError" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupError">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupError
        <span class="apidocSignatureSpan">(message, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;error&quot;,
        rollup  : true,
        message : message,
        rule    : rule
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupWarn" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.rollupWarn">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>rollupWarn
        <span class="apidocSignatureSpan">(message, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, rule) {
    &quot;use strict&quot;;
    this.messages.push({
        type    : &quot;warning&quot;,
        rollup  : true,
        message : message,
        rule    : rule
    });
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.stat" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.stat">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>stat
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(name, value) {
    &quot;use strict&quot;;
    this.stats[name] = value;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
let onParallel;
if (local.isBrowser) {
    onError(undefined, opt);
    return;
}
onParallel = local.onParallel(onError);
onParallel.cnt += 1;
local.fs.<span class="apidocCodeKeywordSpan">stat</span>(__filename, function (err, stat) {
    // test default watchFile handling-behavior
    onParallel.cnt += 1;
    local.fs.utimes(__filename, stat.atime, new Date(), onParallel);
    // test nop watchFile handling-behavior
    onParallel.cnt += 1;
    setTimeout(function () {
        local.fs.utimes(__filename, stat.atime, stat.mtime, onParallel);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.warn" id="apidoc.elem.utility2.jslint.CSSLint._Reporter.prototype.warn">
        function <span class="apidocSignatureSpan">utility2.jslint.CSSLint._Reporter.prototype.</span>warn
        <span class="apidocSignatureSpan">(message, line, col, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(message, line, col, rule) {
    &quot;use strict&quot;;
    this.report(message, line, col, rule);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    options.source_map.add(
        mapping.token.file,
        mapping.line, mapping.col,
        mapping.token.line, mapping.token.col,
        !mapping.name &amp;&amp; mapping.token.type == &quot;name&quot; ? mapping.token.value : mapping.name
    );
} catch(ex) {
    mapping.token.file != null &amp;&amp; AST_Node.<span class="apidocCodeKeywordSpan">warn</span>(&quot;Couldn&apos;t figure out
 mapping for {file}:{line},{col} → {cline},{ccol} [{name}]&quot;, {
        file: mapping.token.file,
        line: mapping.token.line,
        col: mapping.token.col,
        cline: mapping.line,
        ccol: mapping.col,
        name: mapping.name || &quot;&quot;
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.jslint.cliDict" id="apidoc.module.utility2.jslint.cliDict">module utility2.jslint.cliDict</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.jslint.cliDict._default" id="apidoc.elem.utility2.jslint.cliDict._default">
        function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>_default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_default = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;file1&gt; &lt;file2&gt; ...
 * will jslint &lt;file1&gt; &lt;file2&gt; ... and print errors to stderr
 */
</span>    // jslint files
    process.argv.slice(2).forEach(function (file) {
        if (file[0] === &quot;-&quot;) {
            return;
        }
        local.jslintAndPrint(
            local.fs.readFileSync(local.path.resolve(file), &quot;utf8&quot;),
            file,
            {
                autofix: process.argv.indexOf(&quot;--autofix&quot;) &gt;= 0,
                conditional: process.argv.indexOf(&quot;--conditional&quot;) &gt;= 0
            }
        );
    });
    // if err occurred, then exit with non-zero code
    process.exit(Boolean(local.jslintResult.errList.length));
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
       local.cliDict._help();
       return;
   }
   if (local.cliDict[process.argv[2]]) {
       local.cliDict[process.argv[2]]();
       return;
   }
   local.cliDict.<span class="apidocCodeKeywordSpan">_default</span>();
};

local.moduleDirname = function (module, pathList) {
/*
* this function will search &lt;pathList&gt; for &lt;module&gt;&apos;s __dirname
*/
   let result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.jslint.cliDict.dir" id="apidoc.elem.utility2.jslint.cliDict.dir">
        function <span class="apidocSignatureSpan">utility2.jslint.cliDict.</span>dir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function () {
<span class="apidocCodeCommentSpan">/*
 * &lt;dir&gt;
 * will jslint files in shallow &lt;dir&gt;
 */
</span>    local.jslintAndPrintDir(process.argv[3], {
        autofix: process.argv.indexOf(&quot;--autofix&quot;) &gt;= 0,
        conditional: process.argv.indexOf(&quot;--conditional&quot;) &gt;= 0
    }, process.exit);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked" id="apidoc.module.utility2.marked">module utility2.marked</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.marked" id="apidoc.elem.utility2.marked.marked">
        function <span class="apidocSignatureSpan">utility2.</span>marked
        <span class="apidocSignatureSpan">(e, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c
(e, n, r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
)+&quot;&lt;/pre&gt;&quot;;throw h}}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer" id="apidoc.elem.utility2.marked.InlineLexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function r(e, t){this.options=t||c.defaults,this.links=
e,this.rules=n.normal,this.renderer=this.options.renderer||new i,this.renderer.options=
this.options;if(!this.links)throw new Error(&quot;Tokens array requires a `links` property.&quot;
);this.options.gfm?this.options.breaks?this.rules=n.breaks:this.rules=n.gfm:this
.options.pedantic&amp;&amp;(this.rules=n.pedantic)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer" id="apidoc.elem.utility2.marked.Lexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function t(t){this.tokens=[],this.tokens.links={},this.options=t||c.
defaults,this.rules=e.normal,this.options.gfm&amp;&amp;(this.options.tables?this.rules=e
.tables:this.rules=e.gfm)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser" id="apidoc.elem.utility2.marked.Parser">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function s
(e){this.tokens=[],this.token=null,this.options=e||c.defaults,this.options.renderer=
this.options.renderer||new i,this.renderer=this.options.renderer,this.renderer.options=
this.options}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer" id="apidoc.elem.utility2.marked.Renderer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function i(e){this.options=e||{}}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.inlineLexer" id="apidoc.elem.utility2.marked.inlineLexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>inlineLexer
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var i=new r(t,n);return i.output(e)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.lexer" id="apidoc.elem.utility2.marked.lexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>lexer
        <span class="apidocSignatureSpan">(e, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, n){var r=new t(n);return r.lex(e)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.options" id="apidoc.elem.utility2.marked.options">
        function <span class="apidocSignatureSpan">utility2.marked.</span>options
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return l(c.defaults,e),c}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.parse" id="apidoc.elem.utility2.marked.parse">
        function <span class="apidocSignatureSpan">utility2.marked.</span>parse
        <span class="apidocSignatureSpan">(e, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c
(e, n, r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.lex(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
)+&quot;&lt;/pre&gt;&quot;;throw h}}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.parser" id="apidoc.elem.utility2.marked.parser">
        function <span class="apidocSignatureSpan">utility2.marked.</span>parser
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var r=new s(t,n);return r.parse
(e)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.setOptions" id="apidoc.elem.utility2.marked.setOptions">
        function <span class="apidocSignatureSpan">utility2.marked.</span>setOptions
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return l(c.defaults,e),c}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.InlineLexer" id="apidoc.module.utility2.marked.InlineLexer">module utility2.marked.InlineLexer</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.InlineLexer" id="apidoc.elem.utility2.marked.InlineLexer.InlineLexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>InlineLexer
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function r(e, t){this.options=t||c.defaults,this.links=
e,this.rules=n.normal,this.renderer=this.options.renderer||new i,this.renderer.options=
this.options;if(!this.links)throw new Error(&quot;Tokens array requires a `links` property.&quot;
);this.options.gfm?this.options.breaks?this.rules=n.breaks:this.rules=n.gfm:this
.options.pedantic&amp;&amp;(this.rules=n.pedantic)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.output" id="apidoc.elem.utility2.marked.InlineLexer.output">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.</span>output
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var i=new r(t,n);return i.output(e)}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};n._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,n._href=/\s*&lt;?([\s\S]*?)&gt;?(?:\s+[&apos;&quot;]([\s\S]*?)[&apos;&quot;])?\s*/
,n.link=a(n.link)(&quot;inside&quot;,n._inside)(&quot;href&quot;,n._href)(),n.reflink=a(n.reflink)(&quot;inside&quot;
,n._inside)(),n.normal=l({},n),n.pedantic=l({},n.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/
,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),n.gfm=l({},n.normal
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.<span class="apidocCodeKeywordSpan">output</span>(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.InlineLexer.prototype" id="apidoc.module.utility2.marked.InlineLexer.prototype">module utility2.marked.InlineLexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.mangle" id="apidoc.elem.utility2.marked.InlineLexer.prototype.mangle">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>mangle
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){if(!this.options.
mangle)return e;var t=&quot;&quot;,n=e.length,r=0,i;for(;r&lt;n;r++)i=e.charCodeAt(r),Math.random
()&gt;.5&amp;&amp;(i=&quot;x&quot;+i.toString(16)),t+=&quot;&amp;#&quot;+i+&quot;;&quot;;return t}</pre></li>
    <li>example use<pre class="apidocCodePre">...
,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),n.gfm=l({},n.normal
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.output(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.<span class="apidocCodeKeywordSpan">mangle</span>(s[1].substring
(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.output" id="apidoc.elem.utility2.marked.InlineLexer.prototype.output">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>output
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};n._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,n._href=/\s*&lt;?([\s\S]*?)&gt;?(?:\s+[&apos;&quot;]([\s\S]*?)[&apos;&quot;])?\s*/
,n.link=a(n.link)(&quot;inside&quot;,n._inside)(&quot;href&quot;,n._href)(),n.reflink=a(n.reflink)(&quot;inside&quot;
,n._inside)(),n.normal=l({},n),n.pedantic=l({},n.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/
,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),n.gfm=l({},n.normal
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.<span class="apidocCodeKeywordSpan">output</span>(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.link(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.outputLink" id="apidoc.elem.utility2.marked.InlineLexer.prototype.outputLink">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>outputLink
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))}</pre></li>
    <li>example use<pre class="apidocCodePre">...
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.<span class="apidocCodeKeywordSpan">outputLink</span>(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.InlineLexer.prototype.smartypants" id="apidoc.elem.utility2.marked.InlineLexer.prototype.smartypants">
        function <span class="apidocSignatureSpan">utility2.marked.InlineLexer.prototype.</span>smartypants
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e}</pre></li>
    <li>example use<pre class="apidocCodePre">...
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.<span class="apidocCodeKeywordSpan">smartypants</span>(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e},r.prototype.mangle=function(e){if(!this.options.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Lexer" id="apidoc.module.utility2.marked.Lexer">module utility2.marked.Lexer</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.Lexer" id="apidoc.elem.utility2.marked.Lexer.Lexer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Lexer
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function t(t){this.tokens=[],this.tokens.links={},this.options=t||c.
defaults,this.rules=e.normal,this.options.gfm&amp;&amp;(this.options.tables?this.rules=e
.tables:this.rules=e.gfm)}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.lex" id="apidoc.elem.utility2.marked.Lexer.lex">
        function <span class="apidocSignatureSpan">utility2.marked.Lexer.</span>lex
        <span class="apidocSignatureSpan">(e, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, n){var r=new t(n);return r.lex(e)}</pre></li>
    <li>example use<pre class="apidocCodePre">...
e,t){return t=t.toLowerCase(),t===&quot;colon&quot;?&quot;:&quot;:t.charAt(0)===&quot;#&quot;?t.charAt(1)===&quot;x&quot;?
String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring
(1)):&quot;&quot;})}function a(e,t){return e=e.source,t=t||&quot;&quot;,function n(r,i){return r?(i=
i.source||i,i=i.replace(/(^|[^\[])\^/g,&quot;$1&quot;),e=e.replace(r,i),n):new RegExp(e,t)
}}function f(){}function l(e){var t=1,n,r;for(;t&lt;arguments.length;t++){n=arguments
[t];for(r in n)Object.prototype.hasOwnProperty.call(n,r)&amp;&amp;(e[r]=n[r])}return e}function c
(e,n,r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.<span class="apidocCodeKeywordSpan">lex</span>(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Lexer.prototype" id="apidoc.module.utility2.marked.Lexer.prototype">module utility2.marked.Lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.prototype.lex" id="apidoc.elem.utility2.marked.Lexer.prototype.lex">
        function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>lex
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return e=
e.replace(/\r\n|\r/g,&quot;\n&quot;).replace(/\t/g,&quot;    &quot;).replace(/\u00a0/g,&quot; &quot;).replace(/\u2424/g
,&quot;\n&quot;),this.token(e,!0)}</pre></li>
    <li>example use<pre class="apidocCodePre">...
e,t){return t=t.toLowerCase(),t===&quot;colon&quot;?&quot;:&quot;:t.charAt(0)===&quot;#&quot;?t.charAt(1)===&quot;x&quot;?
String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring
(1)):&quot;&quot;})}function a(e,t){return e=e.source,t=t||&quot;&quot;,function n(r,i){return r?(i=
i.source||i,i=i.replace(/(^|[^\[])\^/g,&quot;$1&quot;),e=e.replace(r,i),n):new RegExp(e,t)
}}function f(){}function l(e){var t=1,n,r;for(;t&lt;arguments.length;t++){n=arguments
[t];for(r in n)Object.prototype.hasOwnProperty.call(n,r)&amp;&amp;(e[r]=n[r])}return e}function c
(e,n,r){if(r||typeof n==&quot;function&quot;){r||(r=n,n=null),n=l({},c.defaults,n||{});var i=
n.highlight,u,a,f=0;try{u=t.<span class="apidocCodeKeywordSpan">lex</span>(e,n)}catch(h){return r(h)}a=u.length;var p=function(
e){if(e)return n.highlight=i,r(e);var t;try{t=s.parse(u,n)}catch(o){e=o}return n
.highlight=i,e?r(e):r(null,t)};if(!i||i.length&lt;3)return p();delete n.highlight;if(!
a)return p();for(;f&lt;u.length;f++)(function(e){return e.type!==&quot;code&quot;?--a||p():i(
e.text,e.lang,function(t,n){if(t)return p(t);if(n==null||n===e.text)return--a||p
();e.text=n,e.escaped=!0,--a||p()})})(u[f]);return}try{return n&amp;&amp;(n=l({},c.defaults
,n)),s.parse(t.lex(e,n),n)}catch(h){h.message+=&quot;\nPlease report this to https://github.com/chjj/marked.&quot;
;if((n||c.defaults).silent)return&quot;&lt;p&gt;An error occured:&lt;/p&gt;&lt;pre&gt;&quot;+o(h.message+&quot;&quot;,!0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Lexer.prototype.token" id="apidoc.elem.utility2.marked.Lexer.prototype.token">
        function <span class="apidocSignatureSpan">utility2.marked.Lexer.prototype.</span>token
        <span class="apidocSignatureSpan">(t, n, r)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(t, n, r){var t=t.replace(/^ +$/gm
,&quot;&quot;),i,s,o,u,a,f,l,c,h;while(t){if(o=this.rules.newline.exec(t))t=t.substring(o[0
].length),o[0].length&gt;1&amp;&amp;this.tokens.push({type:&quot;space&quot;});if(o=this.rules.code.exec
(t)){t=t.substring(o[0].length),o=o[0].replace(/^ {4}/gm,&quot;&quot;),this.tokens.push({type
:&quot;code&quot;,text:this.options.pedantic?o:o.replace(/\n+$/,&quot;&quot;)});continue}if(o=this.rules
.fences.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:&quot;code&quot;,lang:o
[2],text:o[3]||&quot;&quot;});continue}if(o=this.rules.heading.exec(t)){t=t.substring(o[0]
.length),this.tokens.push({type:&quot;heading&quot;,depth:o[1].length,text:o[2]});continue}
if(n&amp;&amp;(o=this.rules.nptable.exec(t))){t=t.substring(o[0].length),f={type:&quot;table&quot;
,header:o[1].replace(/^ *| *\| *$/g,&quot;&quot;).split(/ *\| */),align:o[2].replace(/^ *|\| *$/g
,&quot;&quot;).split(/ *\| */),cells:o[3].replace(/\n$/,&quot;&quot;).split(&quot;\n&quot;)};for(c=0;c&lt;f.align
.length;c++)/^ *-+: *$/.test(f.align[c])?f.align[c]=&quot;right&quot;:/^ *:-+: *$/.test(f.
align[c])?f.align[c]=&quot;center&quot;:/^ *:-+ *$/.test(f.align[c])?f.align[c]=&quot;left&quot;:f.align
[c]=null;for(c=0;c&lt;f.cells.length;c++)f.cells[c]=f.cells[c].split(/ *\| */);this
.tokens.push(f);continue}if(o=this.rules.lheading.exec(t)){t=t.substring(o[0].length
),this.tokens.push({type:&quot;heading&quot;,depth:o[2]===&quot;=&quot;?1:2,text:o[1]});continue}if(
o=this.rules.hr.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:&quot;hr&quot;}
);continue}if(o=this.rules.blockquote.exec(t)){t=t.substring(o[0].length),this.tokens
.push({type:&quot;blockquote_start&quot;}),o=o[0].replace(/^ *&gt; ?/gm,&quot;&quot;),this.token(o,n,!0
),this.tokens.push({type:&quot;blockquote_end&quot;});continue}if(o=this.rules.list.exec(t
)){t=t.substring(o[0].length),u=o[2],this.tokens.push({type:&quot;list_start&quot;,ordered
:u.length&gt;1}),o=o[0].match(this.rules.item),i=!1,h=o.length,c=0;for(;c&lt;h;c++)f=o
[c],l=f.length,f=f.replace(/^ *([*+-]|\d+\.) +/,&quot;&quot;),~f.indexOf(&quot;\n &quot;)&amp;&amp;(l-=f.length
,f=this.options.pedantic?f.replace(/^ {1,4}/gm,&quot;&quot;):f.replace(new RegExp(&quot;^ {1,&quot;+
l+&quot;}&quot;,&quot;gm&quot;),&quot;&quot;)),this.options.smartLists&amp;&amp;c!==h-1&amp;&amp;(a=e.bullet.exec(o[c+1])[0],u!==
a&amp;&amp;!(u.length&gt;1&amp;&amp;a.length&gt;1)&amp;&amp;(t=o.slice(c+1).join(&quot;\n&quot;)+t,c=h-1)),s=i||/\n\n(?!\s*$)/
.test(f),c!==h-1&amp;&amp;(i=f.charAt(f.length-1)===&quot;\n&quot;,s||(s=i)),this.tokens.push({type
:s?&quot;loose_item_start&quot;:&quot;list_item_start&quot;}),this.token(f,!1,r),this.tokens.push({type
:&quot;list_item_end&quot;});this.tokens.push({type:&quot;list_end&quot;});continue}if(o=this.rules.
html.exec(t)){t=t.substring(o[0].length),this.tokens.push({type:this.options.sanitize?&quot;paragraph&quot;
:&quot;html&quot;,pre:!this.options.sanitizer&amp;&amp;(o[1]===&quot;pre&quot;||o[1]===&quot;script&quot;||o[1]===&quot;style&quot;
),text:o[0]});continue}if(!r&amp;&amp;n&amp;&amp;(o=this.rules.def.exec(t))){t=t.substring(o[0].
length),this.tokens.links[o[1].toLowerCase()]={href:o[2],title:o[3]};continue}if(
n&amp;&amp;(o=this.rules.table.exec(t))){t=t.substring(o[0].length),f={type:&quot;table&quot;,header
:o[1].replace(/^ *| *\| *$/g,&quot;&quot;).split(/ *\| */),align:o[2].replace(/^ *|\| *$/g
,&quot;&quot;).split(/ *\| */),cells:o[3].replace(/(?: *\| *)?\n$/,&quot;&quot;).split(&quot;\n&quot;)};for(c=0
;c&lt;f.align.length;c++)/^ *-+: *$/.test(f.align[c])?f.align[c]=&quot;right&quot;:/^ *:-+: *$/
.test(f.align[c])?f.align[c]=&quot;center&quot;:/^ *:-+ *$/.test(f.align[c])?f.align[c]=&quot;left&quot;
:f.align[c]=null;for(c=0;c&lt;f.cells.length;c++)f.cells[c]=f.cells[c].replace(/^ *\| *| *\| *$/g
,&quot;&quot;).split(/ *\| */);this.tokens.push(f);continue}if(n&amp;&amp;(o=this.rules.paragraph.
exec(t))){t=t.substring(o[0].length),this.tokens.push({type:&quot;paragraph&quot;,text:o[1
].charAt(o[1].length-1)===&quot;\n&quot;?o[1].slice(0,-1):o[1]});c...</pre></li>
    <li>example use<pre class="apidocCodePre">...
                        throw new SyntaxError(&quot;@import not allowed here.&quot;, token.startLine, token.startCol);
                    case Tokens.NAMESPACE_SYM:
                        token = tokenStream.LT(1);
                        this._namespace(false);
                        throw new SyntaxError(&quot;@namespace not allowed here.&quot;, token.startLine, token.startCol);
                    default:
                        tokenStream.get();  //get the last token
                        this._unexpectedToken(tokenStream.<span class="apidocCodeKeywordSpan">token</span>());
                }
            }
    }
} catch (ex) {
    if (ex instanceof SyntaxError &amp;&amp; !this.options.strict) {
        this.fire({
            type:       &quot;error&quot;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Parser" id="apidoc.module.utility2.marked.Parser">module utility2.marked.Parser</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.Parser" id="apidoc.elem.utility2.marked.Parser.Parser">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Parser
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function s
(e){this.tokens=[],this.token=null,this.options=e||c.defaults,this.options.renderer=
this.options.renderer||new i,this.renderer=this.options.renderer,this.renderer.options=
this.options}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.parse" id="apidoc.elem.utility2.marked.Parser.parse">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.</span>parse
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var r=new s(t,n);return r.parse
(e)}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Parser.prototype" id="apidoc.module.utility2.marked.Parser.prototype">module utility2.marked.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.next" id="apidoc.elem.utility2.marked.Parser.prototype.next">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){return this.token=this.tokens.pop()}</pre></li>
    <li>example use<pre class="apidocCodePre">...
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.<span class="apidocCodeKeywordSpan">next</span>();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.parse" id="apidoc.elem.utility2.marked.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){this.inline=new r(e.links,this.options,this.renderer
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.tok();return t}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
};
local.fsRmrfSync = function (pathname) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.parseText" id="apidoc.elem.utility2.marked.Parser.prototype.parseText">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>parseText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)}</pre></li>
    <li>example use<pre class="apidocCodePre">...
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.<span class="apidocCodeKeywordSpan">parseText</span>():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot
;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.peek" id="apidoc.elem.utility2.marked.Parser.prototype.peek">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>peek
        <span class="apidocSignatureSpan">( )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( ){return this.tokens[this.tokens.length-1]||0}</pre></li>
    <li>example use<pre class="apidocCodePre">...

//try to read character set
this._charset();

this._skipCruft();

//try to read imports - may be more than one
while (tokenStream.<span class="apidocCodeKeywordSpan">peek</span>() === Tokens.IMPORT_SYM) {
    this._import();
    this._skipCruft();
}

//try to read namespaces - may be more than one
while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
    this._namespace();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Parser.prototype.tok" id="apidoc.elem.utility2.marked.Parser.prototype.tok">
        function <span class="apidocSignatureSpan">utility2.marked.Parser.prototype.</span>tok
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}}</pre></li>
    <li>example use<pre class="apidocCodePre">...
e,t,n){if(this.options.sanitize){try{var r=decodeURIComponent(u(e)).replace(/[^\w:]/g
,&quot;&quot;).toLowerCase()}catch(i){return&quot;&quot;}if(r.indexOf(&quot;javascript:&quot;)===0||r.indexOf(&quot;vbscript:&quot
;
)===0||r.indexOf(&quot;data:&quot;)===0)return&quot;&quot;}var s=&apos;&lt;a href=&quot;&apos;+e+&apos;&quot;&apos;;return t&amp
;&amp;(s+=&apos; title=&quot;&apos;+
t+&apos;&quot;&apos;),s+=&quot;&gt;&quot;+n+&quot;&lt;/a&gt;&quot;,s},i.prototype.image=function(e,t,n){var r=&apos;&lt;img src=&
quot;&apos;+e+&apos;&quot; alt=&quot;&apos;+
n+&apos;&quot;&apos;;return t&amp;&amp;(r+=&apos; title=&quot;&apos;+t+&apos;&quot;&apos;),r+=this.options.xhtml?&quot;/&gt;&quot
;:&quot;&gt;&quot;,r},i.prototype
.text=function(e){return e},s.parse=function(e,t,n){var r=new s(t,n);return r.parse
(e)},s.prototype.parse=function(e){this.inline=new r(e.links,this.options,this.renderer
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.<span class="apidocCodeKeywordSpan">tok</span>();return t
},s.prototype
.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Renderer" id="apidoc.module.utility2.marked.Renderer">module utility2.marked.Renderer</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.Renderer" id="apidoc.elem.utility2.marked.Renderer.Renderer">
        function <span class="apidocSignatureSpan">utility2.marked.</span>Renderer
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function i(e){this.options=e||{}}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.marked.Renderer.prototype" id="apidoc.module.utility2.marked.Renderer.prototype">module utility2.marked.Renderer.prototype</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.blockquote" id="apidoc.elem.utility2.marked.Renderer.prototype.blockquote">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>blockquote
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;blockquote&gt;\n&quot;+e+&quot;&lt;/blockquote&gt;\n&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.<span class="apidocCodeKeywordSpan">blockquote</span>(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while
(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.br" id="apidoc.elem.utility2.marked.Renderer.prototype.br">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>br
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){return this.options.xhtml?&quot;&lt;br/&gt;&quot;:&quot;&lt;br&gt;&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.<span class="apidocCodeKeywordSpan">br</span>();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.code" id="apidoc.elem.utility2.marked.Renderer.prototype.code">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>code
        <span class="apidocSignatureSpan">( e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( e, t, n){if(this.options.highlight){var r=this.options.highlight(e,t);r!=null&amp;&amp;r!==
e&amp;&amp;(n=!0,e=r)}return t?&apos;&lt;pre&gt;&lt;code class=&quot;&apos;+this.options.langPrefix+o(t,!0)+&apos;&quot;&gt;&apos;+
(n?e:o(e,!0))+&quot;\n&lt;/code&gt;&lt;/pre&gt;\n&quot;:&quot;&lt;pre&gt;&lt;code&gt;&quot;+(n?e:o(e,!0))+&quot;\n&lt;/code&gt;&lt;/pre&gt;&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.tok();return t},s.prototype
.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.<span class="apidocCodeKeywordSpan">code</span>(this.token.text,this.token.lang,this.token.escaped);case&quot
;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.codespan" id="apidoc.elem.utility2.marked.Renderer.prototype.codespan">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>codespan
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;code&gt;&quot;+
e+&quot;&lt;/code&gt;&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.<span class="apidocCodeKeywordSpan">codespan</span>(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.del" id="apidoc.elem.utility2.marked.Renderer.prototype.del">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>del
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;del&gt;&quot;+e+&quot;&lt;/del&gt;&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.<span class="apidocCodeKeywordSpan">del</span>(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.em" id="apidoc.elem.utility2.marked.Renderer.prototype.em">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>em
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;em&gt;&quot;+e+&quot;&lt;/em&gt;&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.<span class="apidocCodeKeywordSpan">em</span>(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.heading" id="apidoc.elem.utility2.marked.Renderer.prototype.heading">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>heading
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){return&quot;&lt;h&quot;+
t+&apos; id=&quot;&apos;+this.options.headerPrefix+n.toLowerCase().replace(/[^\w]+/g,&quot;-&quot;)+&apos;&quot;&gt;&apos;+
e+&quot;&lt;/h&quot;+t+&quot;&gt;\n&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.hr" id="apidoc.elem.utility2.marked.Renderer.prototype.hr">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>hr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(){return this.options.xhtml?&quot;&lt;hr/&gt;\n&quot;:&quot;&lt;hr&gt;\n&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
.text=function(e){return e},s.parse=function(e,t,n){var r=new s(t,n);return r.parse
(e)},s.prototype.parse=function(e){this.inline=new r(e.links,this.options,this.renderer
),this.tokens=e.reverse();var t=&quot;&quot;;while(this.next())t+=this.tok();return t},s.prototype
.next=function(){return this.token=this.tokens.pop()},s.prototype.peek=function(
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.<span class="apidocCodeKeywordSpan">hr</span>();case&quot;heading&quot
;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.html" id="apidoc.elem.utility2.marked.Renderer.prototype.html">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>html
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return e}</pre></li>
    <li>example use<pre class="apidocCodePre">...
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.<span class="apidocCodeKeywordSpan">html</span>(a);case&quot;paragraph
&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
langPrefix:&quot;lang-&quot;,smartypants:!1,headerPrefix:&quot;&quot;,renderer:new i,xhtml:!1},c.Parser=
s,c.parser=s.parse,c.Renderer=i,c.Lexer=t,c.lexer=t.lex,c.InlineLexer=r,c.inlineLexer=
r.output,c.parse=c,typeof module!=&quot;undefined&quot;&amp;&amp;typeof exports==&quot;object&quot;?module.exports=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.image" id="apidoc.elem.utility2.marked.Renderer.prototype.image">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>image
        <span class="apidocSignatureSpan">(e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t, n){var r=&apos;&lt;img src=&quot;&apos;+e+&apos;&quot; alt=&quot;&apos;+
n+&apos;&quot;&apos;;return t&amp;&amp;(r+=&apos; title=&quot;&apos;+t+&apos;&quot;&apos;),r+=this.options.xhtml?&quot;/&gt;&quot;:&quot;&gt;&quot;,r}</pre></li>
    <li>example use<pre class="apidocCodePre">...
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.<span class="apidocCodeKeywordSpan">image</span>(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e},r.prototype.mangle=function(e){if(!this.options.
mangle)return e;var t=&quot;&quot;,n=e.length,r=0,i;for(;r&lt;n;r++)i=e.charCodeAt(r),Math.random
()&gt;.5&amp;&amp;(i=&quot;x&quot;+i.toString(16)),t+=&quot;&amp;#&quot;+i+&quot;;&quot;;return t},i.prototype.code=function(
e,t,n){if(this.options.highlight){var r=this.options.highlight(e,t);r!=null&amp;&amp;r!==
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.link" id="apidoc.elem.utility2.marked.Renderer.prototype.link">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>link
        <span class="apidocSignatureSpan">( e, t, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( e, t, n){if(this.options.sanitize){try{var r=decodeURIComponent(u(e)).replace(/[^\w:]/g
,&quot;&quot;).toLowerCase()}catch(i){return&quot;&quot;}if(r.indexOf(&quot;javascript:&quot;)===0||r.indexOf(&quot;vbscript:&quot;
)===0||r.indexOf(&quot;data:&quot;)===0)return&quot;&quot;}var s=&apos;&lt;a href=&quot;&apos;+e+&apos;&quot;&apos;;return t&amp;&amp;(s+=&apos; title=&quot;&apos;+
t+&apos;&quot;&apos;),s+=&quot;&gt;&quot;+n+&quot;&lt;/a&gt;&quot;,s}</pre></li>
    <li>example use<pre class="apidocCodePre">...
,{escape:a(n.escape)(&quot;])&quot;,&quot;~|])&quot;)(),url:/^(https?:\/\/[^\s&lt;]+[^&lt;.,:;&quot;&apos;)\]\s])/,del
:/^~~(?=\S)([\s\S]*?\S)~~/,text:a(n.text)(&quot;]|&quot;,&quot;~]|&quot;)(&quot;|&quot;,&quot;|https?://|&quot;)()}),n.breaks=
l({},n.gfm,{br:a(n.br)(&quot;{2,}&quot;,&quot;*&quot;)(),text:a(n.gfm.text)(&quot;{2,}&quot;,&quot;*&quot;)()}),r.rules=
n,r.output=function(e,t,n){var i=new r(t,n);return i.output(e)},r.prototype.output=
function(e){var t=&quot;&quot;,n,r,i,s;while(e){if(s=this.rules.escape.exec(e)){e=e.substring
(s[0].length),t+=s[1];continue}if(s=this.rules.autolink.exec(e)){e=e.substring(s
[0].length),s[2]===&quot;@&quot;?(r=s[1].charAt(6)===&quot;:&quot;?this.mangle(s[1].substring(7)):this
.mangle(s[1]),i=this.mangle(&quot;mailto:&quot;)+r):(r=o(s[1]),i=r),t+=this.renderer.<span class="apidocCodeKeywordSpan">link</span
>(
i,null,r);continue}if(!this.inLink&amp;&amp;(s=this.rules.url.exec(e))){e=e.substring(s[0
].length),r=o(s[1]),i=r,t+=this.renderer.link(i,null,r);continue}if(s=this.rules
.tag.exec(e)){!this.inLink&amp;&amp;/^&lt;a /i.test(s[0])?this.inLink=!0:this.inLink&amp;&amp;/^&lt;\/a&gt;/i
.test(s[0])&amp;&amp;(this.inLink=!1),e=e.substring(s[0].length),t+=this.options.sanitize?
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.list" id="apidoc.elem.utility2.marked.Renderer.prototype.list">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>list
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){var n=t?&quot;ol&quot;:&quot;ul&quot;;return&quot;&lt;&quot;+n+&quot;&gt;\n&quot;+e+&quot;&lt;/&quot;+n+&quot;&gt;\n&quot;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.<span class="apidocCodeKeywordSpan">list</span>(t,u);case&quot;list_item_start
&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.listitem" id="apidoc.elem.utility2.marked.Renderer.prototype.listitem">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>listitem
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;li&gt;&quot;+e+&quot;&lt;/li&gt;\n&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.<span class="apidocCodeKeywordSpan">listitem</span>(t);case&quot;loose_item_start&quot
;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.paragraph(this.inline.output(this.token.text));case&quot;text&quot;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.paragraph" id="apidoc.elem.utility2.marked.Renderer.prototype.paragraph">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>paragraph
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;p&gt;&quot;+e+&quot;&lt;/p&gt;\n&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
.output(this.token.text):this.token.text;return this.renderer.html(a);case&quot;paragraph&quot;
:return this.renderer.<span class="apidocCodeKeywordSpan">paragraph</span>(this.inline.output(this.token.text));case&quot;text&quot
;:
return this.renderer.paragraph(this.parseText())}},f.exec=f,c.options=c.setOptions=
function(e){return l(c.defaults,e),c},c.defaults={gfm:!0,tables:!0,breaks:!1,pedantic
:!1,sanitize:!1,sanitizer:null,mangle:!0,smartLists:!1,silent:!1,highlight:null,
langPrefix:&quot;lang-&quot;,smartypants:!1,headerPrefix:&quot;&quot;,renderer:new i,xhtml:!1},c.Parser=
s,c.parser=s.parse,c.Renderer=i,c.Lexer=t,c.lexer=t.lex,c.InlineLexer=r,c.inlineLexer=
r.output,c.parse=c,typeof module!=&quot;undefined&quot;&amp;&amp;typeof exports==&quot;object&quot;?module.exports=
c:typeof define==&quot;function&quot;&amp;&amp;define.amd?define(function(){return c}):this.marked=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.strong" id="apidoc.elem.utility2.marked.Renderer.prototype.strong">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>strong
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return&quot;&lt;strong&gt;&quot;+e+&quot;&lt;/strong&gt;&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
this.options.sanitizer?this.options.sanitizer(s[0]):o(s[0]):s[0];continue}if(s=this
.rules.link.exec(e)){e=e.substring(s[0].length),this.inLink=!0,t+=this.outputLink
(s,{href:s[2],title:s[3]}),this.inLink=!1;continue}if((s=this.rules.reflink.exec
(e))||(s=this.rules.nolink.exec(e))){e=e.substring(s[0].length),n=(s[2]||s[1]).replace
(/\s+/g,&quot; &quot;),n=this.links[n.toLowerCase()];if(!n||!n.href){t+=s[0].charAt(0),e=s
[0].substring(1)+e;continue}this.inLink=!0,t+=this.outputLink(s,n),this.inLink=!1
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.<span class="apidocCodeKeywordSpan">strong</span>(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.text(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.table" id="apidoc.elem.utility2.marked.Renderer.prototype.table">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>table
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){return&quot;&lt;table&gt;\n&lt;thead&gt;\n&quot;+
e+&quot;&lt;/thead&gt;\n&quot;+&quot;&lt;tbody&gt;\n&quot;+t+&quot;&lt;/tbody&gt;\n&quot;+&quot;&lt;/table&gt;\n&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.<span class="apidocCodeKeywordSpan">table</span>(e,t);case&quot;blockquote_start
&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
.parseText():this.tok();return this.renderer.listitem(t);case&quot;loose_item_start&quot;:
var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.tok();return this.renderer
.listitem(t);case&quot;html&quot;:var a=!this.token.pre&amp;&amp;!this.options.pedantic?this.inline
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.tablecell" id="apidoc.elem.utility2.marked.Renderer.prototype.tablecell">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablecell
        <span class="apidocSignatureSpan">(e, t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e, t){var n=t.header?&quot;th&quot;
:&quot;td&quot;,r=t.align?&quot;&lt;&quot;+n+&apos; style=&quot;text-align:&apos;+t.align+&apos;&quot;&gt;&apos;:&quot;&lt;&quot;+n+&quot;&gt;&quot;;return r+e+&quot;&lt;/&quot;+
n+&quot;&gt;\n&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
){return this.tokens[this.tokens.length-1]||0},s.prototype.parseText=function(){
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.<span class="apidocCodeKeywordSpan">tablecell</span>(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.tablerow(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.tablerow" id="apidoc.elem.utility2.marked.Renderer.prototype.tablerow">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>tablerow
        <span class="apidocSignatureSpan">( e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function( e){return&quot;&lt;tr&gt;\n&quot;+e+&quot;&lt;/tr&gt;\n&quot;}</pre></li>
    <li>example use<pre class="apidocCodePre">...
var e=this.token.text;while(this.peek().type===&quot;text&quot;)e+=&quot;\n&quot;+this.next().text;return this
.inline.output(e)},s.prototype.tok=function(){switch(this.token.type){case&quot;space&quot;
:return&quot;&quot;;case&quot;hr&quot;:return this.renderer.hr();case&quot;heading&quot;:return this.renderer.
heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case&quot;code&quot;
:return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case&quot;table&quot;
:var e=&quot;&quot;,t=&quot;&quot;,n,r,i,s,o;i=&quot;&quot;;for(n=0;n&lt;this.token.header.length;n++)s={header:!0
,align:this.token.align[n]},i+=this.renderer.tablecell(this.inline.output(this.token
.header[n]),{header:!0,align:this.token.align[n]});e+=this.renderer.<span class="apidocCodeKeywordSpan">tablerow</span>(i);
for(n=0;n&lt;this.token.cells.length;n++){r=this.token.cells[n],i=&quot;&quot;;for(o=0;o&lt;r.length
;o++)i+=this.renderer.tablecell(this.inline.output(r[o]),{header:!1,align:this.token
.align[o]});t+=this.renderer.tablerow(i)}return this.renderer.table(e,t);case&quot;blockquote_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;blockquote_end&quot;)t+=this.tok();return this.renderer
.blockquote(t);case&quot;list_start&quot;:var t=&quot;&quot;,u=this.token.ordered;while(this.next().
type!==&quot;list_end&quot;)t+=this.tok();return this.renderer.list(t,u);case&quot;list_item_start&quot;
:var t=&quot;&quot;;while(this.next().type!==&quot;list_item_end&quot;)t+=this.token.type===&quot;text&quot;?this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.marked.Renderer.prototype.text" id="apidoc.elem.utility2.marked.Renderer.prototype.text">
        function <span class="apidocSignatureSpan">utility2.marked.Renderer.prototype.</span>text
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function(e){return e}</pre></li>
    <li>example use<pre class="apidocCodePre">...
;continue}if(s=this.rules.strong.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.strong(this.output(s[2]||s[1]));continue}if(s=this.rules.em.exec(e)){e=e.substring
(s[0].length),t+=this.renderer.em(this.output(s[2]||s[1]));continue}if(s=this.rules
.code.exec(e)){e=e.substring(s[0].length),t+=this.renderer.codespan(o(s[2],!0));
continue}if(s=this.rules.br.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.br();continue}if(s=this.rules.del.exec(e)){e=e.substring(s[0].length),t+=this.renderer
.del(this.output(s[1]));continue}if(s=this.rules.text.exec(e)){e=e.substring(s[0
].length),t+=this.renderer.<span class="apidocCodeKeywordSpan">text</span>(o(this.smartypants(s[0])));continue}if(e)throw new
Error(&quot;Infinite loop on byte: &quot;+e.charCodeAt(0))}return t},r.prototype.outputLink=
function(e,t){var n=o(t.href),r=t.title?o(t.title):null;return e[0].charAt(0)!==&quot;!&quot;?
this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,o(e[1]))},r.prototype
.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,&quot;\u2014&quot;
).replace(/--/g,&quot;\u2013&quot;).replace(/(^|[-\u2014/(\[{&quot;\s])&apos;/g,&quot;$1\u2018&quot;).replace(/&apos;/g
,&quot;\u2019&quot;).replace(/(^|[-\u2014/(\[{\u2018\s])&quot;/g,&quot;$1\u201c&quot;).replace(/&quot;/g,&quot;\u201d&quot;
).replace(/\.{3}/g,&quot;\u2026&quot;):e},r.prototype.mangle=function(e){if(!this.options.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.puppeteer" id="apidoc.module.utility2.puppeteer">module utility2.puppeteer</a></h1>






    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.assert" id="apidoc.elem.utility2.puppeteer.assert">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assert
        <span class="apidocSignatureSpan">(...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ok(...args) {
  innerOk(ok, args.length, ...args);
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
   key = &apos;0123456789abcdef0123456789abcdef&apos;;
   mode = undefined;
   local.cryptoAesXxxCbcRawEncrypt({
       data,
       key,
       mode
   }, function (err, data) {
       console.<span class="apidocCodeKeywordSpan">assert</span>(!err, err);
       local.cryptoAesXxxCbcRawDecrypt({
           data,
           key,
           mode
       }, console.log);
   });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.assertOrThrow" id="apidoc.elem.utility2.puppeteer.assertOrThrow">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>assertOrThrow
        <span class="apidocSignatureSpan">(passed, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assertOrThrow = function (passed, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will throw err.&lt;msg&gt; if &lt;passed&gt; is falsy
 */
</span>    if (passed) {
        return;
    }
    throw (
        (
            msg
            &amp;&amp; typeof msg.message === &quot;string&quot;
            &amp;&amp; typeof msg.stack === &quot;string&quot;
        )
        // if msg is err, then leave as is
        ? msg
        : new Error(
            typeof msg === &quot;string&quot;
            // if msg is a string, then leave as is
            ? msg
            // else JSON.stringify msg
            : JSON.stringify(msg, undefined, 4)
        )
    );
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
        argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.<span class="apidocCodeKeywordSpan">assertOrThrow</span>(undefined, new Error(
        &quot;cliRun - cannot parse comment in COMMAND &quot;
        + key
        + &quot;:\nnew RegExp(&quot;
        + JSON.stringify(opt.rgxComment.source)
        + &quot;).exec(&quot; + JSON.stringify(str).replace((
            /\\\\/g
        ), &quot;\u0000&quot;).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.cliRun" id="apidoc.elem.utility2.puppeteer.cliRun">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>cliRun
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cliRun = function (opt) {
<span class="apidocCodeCommentSpan">/*
 * this function will run cli with given &lt;opt&gt;
 */
</span>    local.cliDict._eval = local.cliDict._eval || function () {
    /*
     * &lt;code&gt;
     * will eval &lt;code&gt;
     */
        globalThis.local = local;
        local.vm.runInThisContext(process.argv[3]);
    };
    local.cliDict._help = local.cliDict._help || function () {
    /*
     *
     * will print help
     */
        let commandList;
        let file;
        let packageJson;
        let str;
        let strDict;
        commandList = [
            {
                argList: &quot;&lt;arg2&gt;  ...&quot;,
                description: &quot;usage:&quot;,
                command: [
                    &quot;&lt;arg1&gt;&quot;
                ]
            }, {
                argList: &quot;&apos;console.log(\&quot;hello world\&quot;)&apos;&quot;,
                description: &quot;example:&quot;,
                command: [
                    &quot;--eval&quot;
                ]
            }
        ];
        file = __filename.replace((
            /.*\//
        ), &quot;&quot;);
        opt = Object.assign({}, opt);
        packageJson = require(&quot;./package.json&quot;);
        // validate comment
        opt.rgxComment = opt.rgxComment || (
            /\)\u0020\{\n(?:|\u0020{4})\/\*\n(?:\u0020|\u0020{5})\*((?:\u0020&lt;[^&gt;]*?&gt;|\u0020\.\.\.)*?)\n(?:\u0020|\u0020{5})\*\u0020
(will\u0020.*?\S)\n(?:\u0020|\u0020{5})\*\/\n(?:\u0020{4}|\u0020{8})\S/
        );
        strDict = {};
        Object.keys(local.cliDict).sort().forEach(function (key, ii) {
            if (key[0] === &quot;_&quot; &amp;&amp; key !== &quot;_default&quot;) {
                return;
            }
            str = String(local.cliDict[key]);
            if (key === &quot;_default&quot;) {
                key = &quot;&quot;;
            }
            strDict[str] = strDict[str] || (ii + 2);
            ii = strDict[str];
            if (commandList[ii]) {
                commandList[ii].command.push(key);
                return;
            }
            try {
                commandList[ii] = opt.rgxComment.exec(str);
                commandList[ii] = {
                    argList: local.coalesce(commandList[ii][1], &quot;&quot;).trim(),
                    command: [
                        key
                    ],
                    description: commandList[ii][2]
                };
            } catch (ignore) {
                local.assertOrThrow(undefined, new Error(
                    &quot;cliRun - cannot parse comment in COMMAND &quot;
                    + key
                    + &quot;:\nnew RegExp(&quot;
                    + JSON.stringify(opt.rgxComment.source)
                    + &quot;).exec(&quot; + JSON.stringify(str).replace((
                        /\\\\/g
                    ), &quot;\u0000&quot;).replace((
                        /\\n/g
                    ), &quot;\\n\\\n&quot;).replace((
                        /\u0000/g
                    ), &quot;\\\\&quot;) + &quot;);&quot;
                ));
            }
        });
        str = &quot;&quot;;
        str += packageJson.name + &quot; (&quot; + packageJson.version + &quot;)\n\n&quot;;
        str += commandList.filter(function (elem) {
            return elem;
        }).map(function (elem, ii) {
            elem.command = elem.command.filter(function (elem) {
                return elem;
            });
            switch (ii) {
            case 0:
            case 1:
                elem.argList = [
                    elem.argList
                ];
                break;
            default:
                elem.argList = elem.argList.split(&quot; &quot;);
                elem.description = (
                    &quot;# COMMAND &quot;
                    + (elem.command[0] || &quot;&lt;none&gt;&quot;) + &quot;\n# &quot;
                    + elem.description
                );
            }
            return (
                elem.description + &quot;\n  &quot; + file
                + &quot;  &quo...</pre></li>
    <li>example use<pre class="apidocCodePre">...
        dir: process.argv[2],
        modulePathList: module.paths
    }));
};

// run the cli
if (module === require.main &amp;&amp; !globalThis.utility2_rollup) {
    local.<span class="apidocCodeKeywordSpan">cliRun</span>();
}
}());
}());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.coalesce" id="apidoc.elem.utility2.puppeteer.coalesce">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>coalesce
        <span class="apidocSignatureSpan">(...argList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coalesce = function (...argList) {
<span class="apidocCodeCommentSpan">/*
 * this function will coalesce null, undefined, or &quot;&quot; in &lt;argList&gt;
 */
</span>    let arg;
    let ii;
    ii = 0;
    while (ii &lt; argList.length) {
        arg = argList[ii];
        if (arg !== null &amp;&amp; arg !== undefined &amp;&amp; arg !== &quot;&quot;) {
            break;
        }
        ii += 1;
    }
    return arg;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
if (commandList[ii]) {
    commandList[ii].command.push(key);
    return;
}
try {
    commandList[ii] = opt.rgxComment.exec(str);
    commandList[ii] = {
        argList: local.<span class="apidocCodeKeywordSpan">coalesce</span>(commandList[ii][1], &quot;&quot;).trim(),
        command: [
            key
        ],
        description: commandList[ii][2]
    };
} catch (ignore) {
    local.assertOrThrow(undefined, new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.events" id="apidoc.elem.utility2.puppeteer.events">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>events
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.fsReadFileOrDefaultSync" id="apidoc.elem.utility2.puppeteer.fsReadFileOrDefaultSync">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsReadFileOrDefaultSync
        <span class="apidocSignatureSpan">(pathname, type, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsReadFileOrDefaultSync = function (pathname, type, dflt) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync-read &lt;pathname&gt; with given &lt;type&gt; and &lt;dflt&gt;
 */
</span>    let fs;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return dflt;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to read pathname
    try {
        return (
            type === &quot;json&quot;
            ? JSON.parse(fs.readFileSync(pathname, &quot;utf8&quot;))
            : fs.readFileSync(pathname, type)
        );
    } catch (ignore) {
        return dflt;
    }
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            &quot;ignore&quot;, &quot;ignore&quot;, 2
        ]
    });
}
if (globalThis.utility2_rollup || local.env.npm_config_mode_start) {
    // init assets index.html
    local.assetsDict[&quot;/index.html&quot;] = (
        local.<span class="apidocCodeKeywordSpan">fsReadFileOrDefaultSync</span>(&quot;index.html&quot;, &quot;utf8&quot;, &quot
;&quot;)
        || local.assetsDict[&quot;/index.rollup.html&quot;] || &quot;&quot;
    );
    local.assetsDict[&quot;/&quot;] = local.assetsDict[&quot;/index.html&quot;];
    local.assetsDict[&quot;/assets.app.js&quot;] = local.fs.readFileSync(
        __filename,
        &quot;utf8&quot;
    ).replace((
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.fsRmrfSync" id="apidoc.elem.utility2.puppeteer.fsRmrfSync">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsRmrfSync
        <span class="apidocSignatureSpan">(pathname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsRmrfSync = function (pathname) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync &quot;rm -rf&quot; &lt;pathname&gt;
 */
</span>    let child_process;
    // do nothing if module does not exist
    try {
        child_process = require(&quot;child_process&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    if (process.platform !== &quot;win32&quot;) {
        child_process.spawnSync(&quot;rm&quot;, [
            &quot;-rf&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, 2
            ]
        });
        return;
    }
    try {
        child_process.spawnSync(&quot;rd&quot;, [
            &quot;/s&quot;, &quot;/q&quot;, pathname
        ], {
            stdio: [
                &quot;ignore&quot;, 1, &quot;ignore&quot;
            ]
        });
    } catch (ignore) {}
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
            return &quot;image/jpeg&quot;;
        default:
            return file;
        }
    }
};
const removeFolder = function (dir, onError) {
    local.<span class="apidocCodeKeywordSpan">fsRmrfSync</span>(dir);
    onError();
};
removeFolder.sync = local.fsRmrfSync;
const removeRecursive = removeFolder;
let EventEmitter = require(&apos;events&apos;);
let URL = require(&apos;url&apos;);
// let WebSocket = require(&apos;ws&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.fsWriteFileWithMkdirpSync" id="apidoc.elem.utility2.puppeteer.fsWriteFileWithMkdirpSync">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>fsWriteFileWithMkdirpSync
        <span class="apidocSignatureSpan">(pathname, data, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsWriteFileWithMkdirpSync = function (pathname, data, msg) {
<span class="apidocCodeCommentSpan">/*
 * this function will sync write &lt;data&gt; to &lt;pathname&gt; with &quot;mkdir -p&quot;
 */
</span>    let fs;
    let success;
    // do nothing if module does not exist
    try {
        fs = require(&quot;fs&quot;);
    } catch (ignore) {
        return;
    }
    pathname = require(&quot;path&quot;).resolve(pathname);
    // try to write pathname
    try {
        fs.writeFileSync(pathname, data);
        success = true;
    } catch (ignore) {
        // mkdir -p
        fs.mkdirSync(require(&quot;path&quot;).dirname(pathname), {
            recursive: true
        });
        // re-write pathname
        fs.writeFileSync(pathname, data);
        success = true;
    }
    if (success &amp;&amp; msg) {
        console.error(msg.replace(&quot;{{pathname}}&quot;, pathname));
    }
    return success;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    || local.env.npm_config_mode_test_case
    !== &quot;testCase_buildApidoc_default&quot;
) {
    onError(undefined, opt);
    return;
}
// save apidoc.html
local.<span class="apidocCodeKeywordSpan">fsWriteFileWithMkdirpSync</span>(
    &quot;tmp/build/apidoc.html&quot;,
    local.apidocCreate(local.objectAssignDefault(opt, {
        blacklistDict: local,
        require: require2
    })),
    &quot;wrote file apidoc - {{pathname}}&quot;
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.identity" id="apidoc.elem.utility2.puppeteer.identity">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>identity
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identity = function (val) {
<span class="apidocCodeCommentSpan">/*
 * this function will return &lt;val&gt;
 */
</span>    return val;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
local.cliDict.help = local.cliDict.help || local.cliDict._help;
local.cliDict._interactive = local.cliDict._interactive || function () {
/*
 *
 * will start interactive-mode
 */
    globalThis.local = local;
    local.<span class="apidocCodeKeywordSpan">identity</span>(local.replStart || require(&quot;repl&quot;).start)({
        useGlobal: true
    });
};
local.cliDict[&quot;--interactive&quot;] = (
    local.cliDict[&quot;--interactive&quot;]
    || local.cliDict._interactive
);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.nop" id="apidoc.elem.utility2.puppeteer.nop">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>nop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nop = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...


// run shared js-env code - function
(function () {
let process;
let require;
// hack-jslint
local.<span class="apidocCodeKeywordSpan">nop</span>(require);
globalThis.__coverageInclude__ = local.coalesce(
globalThis.__coverageInclude__,
{}
);
// mock builtins
process = local.process || {
cwd: function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.objectAssignDefault" id="apidoc.elem.utility2.puppeteer.objectAssignDefault">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>objectAssignDefault
        <span class="apidocSignatureSpan">(tgt = {}, src = {}, depth = 0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectAssignDefault = function (tgt = {}, src = {}, depth = 0) {
<span class="apidocCodeCommentSpan">/*
 * this function will if items from &lt;tgt&gt; are null, undefined, or &quot;&quot;,
 * then overwrite them with items from &lt;src&gt;
 */
</span>    let recurse;
    recurse = function (tgt, src, depth) {
        Object.entries(src).forEach(function ([
            key, bb
        ]) {
            let aa;
            aa = tgt[key];
            if (aa === undefined || aa === null || aa === &quot;&quot;) {
                tgt[key] = bb;
                return;
            }
            if (
                depth !== 0
                &amp;&amp; typeof aa === &quot;object&quot; &amp;&amp; aa &amp;&amp; !Array.isArray(aa)
                &amp;&amp; typeof bb === &quot;object&quot; &amp;&amp; bb &amp;&amp; !Array.isArray(bb)
            ) {
                recurse(aa, bb, depth - 1);
            }
        });
    };
    recurse(tgt, src, depth | 0);
    return tgt;
}</pre></li>
    <li>example use<pre class="apidocCodePre">...
    return str;
};
// init opt
opt.dir = local.moduleDirname(
    opt.dir,
    opt.modulePathList || require(&quot;module&quot;).paths
);
local.<span class="apidocCodeKeywordSpan">objectAssignDefault</span>(opt, {
    env: {
        npm_package_description: &quot;&quot;
    },
    packageJson: JSON.parse(readExample(&quot;package.json&quot;)),
    require: function (file) {
        return local.tryCatchOnError(function () {
            return require(file);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerLaunch" id="apidoc.elem.utility2.puppeteer.puppeteerLaunch">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>puppeteerLaunch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">puppeteerLaunch = function () { [native code] }</pre></li>
    <li>example use<pre class="apidocCodePre">...
    local.timeoutDefault,
    new Error(
        &quot;timeout - &quot; + local.timeoutDefault + &quot; ms - &quot;
        + testName
    )
);
// create puppeteer browser
local.<span class="apidocCodeKeywordSpan">puppeteerLaunch</span>({
    args: [
        &quot;--headless&quot;,
        &quot;--incognito&quot;,
        &quot;--no-sandbox&quot;,
        &quot;--remote-debugging-port=0&quot;
    ],
    dumpio: !opt.modeSilent,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.stream" id="apidoc.elem.utility2.puppeteer.stream">
        function <span class="apidocSignatureSpan">utility2.puppeteer.</span>stream
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stream(opts) {
  EE.call(this, opts);
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.utility2.puppeteer.puppeteerApi" id="apidoc.module.utility2.puppeteer.puppeteerApi">module utility2.puppeteer.puppeteerApi</a></h1>


    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Accessibility" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Accessibility">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Accessibility
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Accessibility {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._client = client;
  }

  /**
   * @param {{interestingOnly?: boolean, root?: ?Puppeteer.ElementHandle}=} options
   * @return {!Promise&lt;!SerializedAXNode&gt;}
   */
  async snapshot(options = {}) {
    const {
      interestingOnly = true,
      root = null,
    } = options;
    const {nodes} = await this._client.send(&apos;Accessibility.getFullAXTree&apos;);
    let backendNodeId = null;
    if (root) {
      const {node} = await this._client.send(&apos;DOM.describeNode&apos;, {objectId: root._remoteObject.objectId});
      backendNodeId = node.backendNodeId;
    }
    const defaultRoot = AXNode.createTree(nodes);
    let needle = defaultRoot;
    if (backendNodeId) {
      needle = defaultRoot.find(node =&gt; node._payload.backendDOMNodeId === backendNodeId);
      if (!needle)
        return null;
    }
    if (!interestingOnly)
      return serializeTree(needle)[0];

    /** @type {!Set&lt;!AXNode&gt;} */
    const interestingNodes = new Set();
    collectInterestingNodes(interestingNodes, defaultRoot, false);
    if (!interestingNodes.has(needle))
      return null;
    return serializeTree(needle, interestingNodes)[0];
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Browser" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Browser">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Browser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Browser extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.Connection} connection
   * @param {!Array&lt;string&gt;} contextIds
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {?Puppeteer.ChildProcess} process
   * @param {function()=} closeCallback
   */
</span>  static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {
    const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);
    await connection.send(&apos;Target.setDiscoverTargets&apos;, {discover: true});
    return browser;
  }

  /**
   * @param {!Puppeteer.Connection} connection
   * @param {!Array&lt;string&gt;} contextIds
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {?Puppeteer.ChildProcess} process
   * @param {(function():Promise)=} closeCallback
   */
  constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {
    super();
    this._ignoreHTTPSErrors = ignoreHTTPSErrors;
    this._defaultViewport = defaultViewport;
    this._process = process;
    this._screenshotTaskQueue = new TaskQueue();
    this._connection = connection;
    this._closeCallback = closeCallback || new Function();

    this._defaultContext = new BrowserContext(this._connection, this, null);
    /** @type {Map&lt;string, BrowserContext&gt;} */
    this._contexts = new Map();
    for (const contextId of contextIds)
      this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));

    /** @type {Map&lt;string, Target&gt;} */
    this._targets = new Map();
    this._connection.on(Events.Connection.Disconnected, () =&gt; this.emit(Events.Browser.Disconnected));
    this._connection.on(&apos;Target.targetCreated&apos;, this._targetCreated.bind(this));
    this._connection.on(&apos;Target.targetDestroyed&apos;, this._targetDestroyed.bind(this));
    this._connection.on(&apos;Target.targetInfoChanged&apos;, this._targetInfoChanged.bind(this));
  }

  /**
   * @return {?Puppeteer.ChildProcess}
   */
  process() {
    return this._process;
  }

  /**
   * @return {!Promise&lt;!BrowserContext&gt;}
   */
  async createIncognitoBrowserContext() {
    const {browserContextId} = await this._connection.send(&apos;Target.createBrowserContext&apos;);
    const context = new BrowserContext(this._connection, this, browserContextId);
    this._contexts.set(browserContextId, context);
    return context;
  }

  /**
   * @return {!Array&lt;!BrowserContext&gt;}
   */
  browserContexts() {
    return [this._defaultContext, ...Array.from(this._contexts.values())];
  }

  /**
   * @return {!BrowserContext}
   */
  defaultBrowserContext() {
    return this._defaultContext;
  }

  /**
   * @param {?string} contextId
   */
  async _disposeContext(contextId) {
    await this._connection.send(&apos;Target.disposeBrowserContext&apos;, {browserContextId: contextId || undefined});
    this._contexts.delete(contextId);
  }

  /**
   * @param {!Protocol.Target.targetCreatedPayload} event
   */
  async _targetCreated(event) {
    const targetInfo = event.targetInfo;
    const {browserContextId} = targetInfo;
    const context = (browserContextId &amp;&amp; this._contexts.has(browserContextId)) ? this._contexts.get(browserContextId) : this._defaultContext
;

    const target = new Target(targetInfo, context, () =&gt; this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this
._defaultViewport, this._screenshotTaskQueue);
    assert(!this._targets.has(event.targetInfo.targetId), &apos;Target should not exist before targetCreated&apos;);
    this._targets.set(event.targetInfo.targetId, target);

    if (await target._initializedPromise) {
      this.emit(Events.Browser.TargetCreated, target);
      context.emit(Events.BrowserContext.TargetCreated, target);
    }
  }

  /**
   * @param {{targetId: string}} event
   */
  async _targetDestroyed(event) {
    const target = this._targets.get(e...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.BrowserContext" id="apidoc.elem.utility2.puppeteer.puppeteerApi.BrowserContext">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>BrowserContext
        <span class="apidocSignatureSpan">(connection, browser, contextId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class BrowserContext extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.Connection} connection
   * @param {!Browser} browser
   * @param {?string} contextId
   */
</span>  constructor(connection, browser, contextId) {
    super();
    this._connection = connection;
    this._browser = browser;
    this._id = contextId;
  }

  /**
   * @return {!Array&lt;!Target&gt;} target
   */
  targets() {
    return this._browser.targets().filter(target =&gt; target.browserContext() === this);
  }

  /**
   * @param {function(!Target):boolean} predicate
   * @param {{timeout?: number}=} options
   * @return {!Promise&lt;!Target&gt;}
   */
  waitForTarget(predicate, options) {
    return this._browser.waitForTarget(target =&gt; target.browserContext() === this &amp;&amp; predicate(target), options);
  }

  /**
   * @return {!Promise&lt;!Array&lt;!Puppeteer.Page&gt;&gt;}
   */
  async pages() {
    const pages = await Promise.all(
        this.targets()
            .filter(target =&gt; target.type() === &apos;page&apos;)
            .map(target =&gt; target.page())
    );
    return pages.filter(page =&gt; !!page);
  }

  /**
   * @return {boolean}
   */
  isIncognito() {
    return !!this._id;
  }

  /**
   * @param {string} origin
   * @param {!Array&lt;string&gt;} permissions
   */
  async overridePermissions(origin, permissions) {
    const webPermissionToProtocol = new Map([
      [&apos;geolocation&apos;, &apos;geolocation&apos;],
      [&apos;midi&apos;, &apos;midi&apos;],
      [&apos;notifications&apos;, &apos;notifications&apos;],
      [&apos;push&apos;, &apos;push&apos;],
      [&apos;camera&apos;, &apos;videoCapture&apos;],
      [&apos;microphone&apos;, &apos;audioCapture&apos;],
      [&apos;background-sync&apos;, &apos;backgroundSync&apos;],
      [&apos;ambient-light-sensor&apos;, &apos;sensors&apos;],
      [&apos;accelerometer&apos;, &apos;sensors&apos;],
      [&apos;gyroscope&apos;, &apos;sensors&apos;],
      [&apos;magnetometer&apos;, &apos;sensors&apos;],
      [&apos;accessibility-events&apos;, &apos;accessibilityEvents&apos;],
      [&apos;clipboard-read&apos;, &apos;clipboardRead&apos;],
      [&apos;clipboard-write&apos;, &apos;clipboardWrite&apos;],
      [&apos;payment-handler&apos;, &apos;paymentHandler&apos;],
      // chrome-specific permissions we have.
      [&apos;midi-sysex&apos;, &apos;midiSysex&apos;],
    ]);
    permissions = permissions.map(permission =&gt; {
      const protocolPermission = webPermissionToProtocol.get(permission);
      if (!protocolPermission)
        throw new Error(&apos;Unknown permission: &apos; + permission);
      return protocolPermission;
    });
    await this._connection.send(&apos;Browser.grantPermissions&apos;, {origin, browserContextId: this._id || undefined, permissions});
  }

  async clearPermissionOverrides() {
    await this._connection.send(&apos;Browser.resetPermissions&apos;, {browserContextId: this._id || undefined});
  }

  /**
   * @return {!Promise&lt;!Puppeteer.Page&gt;}
   */
  newPage() {
    return this._browser._createPageInContext(this._id);
  }

  /**
   * @return {!Browser}
   */
  browser() {
    return this._browser;
  }

  async close() {
    assert(this._id, &apos;Non-incognito profiles cannot be closed!&apos;);
    await this._browser._disposeContext(this._id);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.CDPSession" id="apidoc.elem.utility2.puppeteer.puppeteerApi.CDPSession">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>CDPSession
        <span class="apidocSignatureSpan">(connection, targetType, sessionId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class CDPSession extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Connection} connection
   * @param {string} targetType
   * @param {string} sessionId
   */
</span>  constructor(connection, targetType, sessionId) {
    super();
    /** @type {!Map&lt;number, {resolve: function, reject: function, error: !Error, method: string}&gt;}*/
    this._callbacks = new Map();
    this._connection = connection;
    this._targetType = targetType;
    this._sessionId = sessionId;
  }

  /**
   * @param {string} method
   * @param {!Object=} params
   * @return {!Promise&lt;?Object&gt;}
   */
  send(method, params = {}) {
    if (!this._connection)
      return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been
closed.`));
    const id = this._connection._rawSend({sessionId: this._sessionId, method, params});
    return new Promise((resolve, reject) =&gt; {
      this._callbacks.set(id, {resolve, reject, error: new Error(), method});
    });
  }

  /**
   * @param {{id?: number, method: string, params: Object, error: {message: string, data: any}, result?: *}} object
   */
  _onMessage(object) {
    if (object.id &amp;&amp; this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error)
        callback.reject(createProtocolError(callback.error, callback.method, object));
      else
        callback.resolve(object.result);
    } else {
      assert(!object.id);
      this.emit(object.method, object.params);
    }
  }

  async detach() {
    if (!this._connection)
      throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
    await this._connection.send(&apos;Target.detachFromTarget&apos;,  {sessionId: this._sessionId});
  }

  _onClosed() {
    for (const callback of this._callbacks.values())
      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
    this._callbacks.clear();
    this._connection = null;
    this.emit(Events.CDPSession.Disconnected);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ConsoleMessage" id="apidoc.elem.utility2.puppeteer.puppeteerApi.ConsoleMessage">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ConsoleMessage
        <span class="apidocSignatureSpan">(type, text, args, location = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ConsoleMessage {
<span class="apidocCodeCommentSpan">  /**
   * @param {string} type
   * @param {string} text
   * @param {!Array&lt;!Puppeteer.JSHandle&gt;} args
   * @param {ConsoleMessage.Location} location
   */
</span>  constructor(type, text, args, location = {}) {
    this._type = type;
    this._text = text;
    this._args = args;
    this._location = location;
  }

  /**
   * @return {string}
   */
  type() {
    return this._type;
  }

  /**
   * @return {string}
   */
  text() {
    return this._text;
  }

  /**
   * @return {!Array&lt;!Puppeteer.JSHandle&gt;}
   */
  args() {
    return this._args;
  }

  /**
   * @return {Object}
   */
  location() {
    return this._location;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Coverage" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Coverage">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Coverage
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Coverage {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._jsCoverage = new JSCoverage(client);
    this._cssCoverage = new CSSCoverage(client);
  }

  /**
   * @param {!{resetOnNavigation?: boolean, reportAnonymousScripts?: boolean}} options
   */
  async startJSCoverage(options) {
    return await this._jsCoverage.start(options);
  }

  /**
   * @return {!Promise&lt;!Array&lt;!CoverageEntry&gt;&gt;}
   */
  async stopJSCoverage() {
    return await this._jsCoverage.stop();
  }

  /**
   * @param {{resetOnNavigation?: boolean}=} options
   */
  async startCSSCoverage(options) {
    return await this._cssCoverage.start(options);
  }

  /**
   * @return {!Promise&lt;!Array&lt;!CoverageEntry&gt;&gt;}
   */
  async stopCSSCoverage() {
    return await this._cssCoverage.stop();
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Dialog" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Dialog">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Dialog
        <span class="apidocSignatureSpan">(string|undefined)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Dialog {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {string} type
   * @param {string} message
   * @param {(string|undefined)} defaultValue
   */
</span>  constructor(client, type, message, defaultValue = &apos;&apos;) {
    this._client = client;
    this._type = type;
    this._message = message;
    this._handled = false;
    this._defaultValue = defaultValue;
  }

  /**
   * @return {string}
   */
  type() {
    return this._type;
  }

  /**
   * @return {string}
   */
  message() {
    return this._message;
  }

  /**
   * @return {string}
   */
  defaultValue() {
    return this._defaultValue;
  }

  /**
   * @param {string=} promptText
   */
  async accept(promptText) {
    assert(!this._handled, &apos;Cannot accept dialog which is already handled!&apos;);
    this._handled = true;
    await this._client.send(&apos;Page.handleJavaScriptDialog&apos;, {
      accept: true,
      promptText: promptText
    });
  }

  async dismiss() {
    assert(!this._handled, &apos;Cannot dismiss dialog which is already handled!&apos;);
    this._handled = true;
    await this._client.send(&apos;Page.handleJavaScriptDialog&apos;, {
      accept: false
    });
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ElementHandle" id="apidoc.elem.utility2.puppeteer.puppeteerApi.ElementHandle">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ElementHandle
        <span class="apidocSignatureSpan">(context, client, remoteObject, page, frameManager)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ElementHandle extends JSHandle {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.ExecutionContext} context
   * @param {!Puppeteer.CDPSession} client
   * @param {!Protocol.Runtime.RemoteObject} remoteObject
   * @param {!Puppeteer.Page} page
   * @param {!Puppeteer.FrameManager} frameManager
   */
</span>  constructor(context, client, remoteObject, page, frameManager) {
    super(context, client, remoteObject);
    this._client = client;
    this._remoteObject = remoteObject;
    this._page = page;
    this._frameManager = frameManager;
    this._disposed = false;
  }

  /**
   * @override
   * @return {?ElementHandle}
   */
  asElement() {
    return this;
  }

  /**
   * @return {!Promise&lt;?Puppeteer.Frame&gt;}
   */
  async contentFrame() {
    const nodeInfo = await this._client.send(&apos;DOM.describeNode&apos;, {
      objectId: this._remoteObject.objectId
    });
    if (typeof nodeInfo.node.frameId !== &apos;string&apos;)
      return null;
    return this._frameManager.frame(nodeInfo.node.frameId);
  }

  async _scrollIntoViewIfNeeded() {
    const error = await this.executionContext().evaluate(async(element, pageJavascriptEnabled) =&gt; {
      if (!element.isConnected)
        return &apos;Node is detached from document&apos;;
      if (element.nodeType !== Node.ELEMENT_NODE)
        return &apos;Node is not of type HTMLElement&apos;;
      // force-scroll if page&apos;s javascript is disabled.
      if (!pageJavascriptEnabled) {
        element.scrollIntoView({block: &apos;center&apos;, inline: &apos;center&apos;, behavior: &apos;instant&apos;});
        return false;
      }
      const visibleRatio = await new Promise(resolve =&gt; {
        const observer = new IntersectionObserver(entries =&gt; {
          resolve(entries[0].intersectionRatio);
          observer.disconnect();
        });
        observer.observe(element);
      });
      if (visibleRatio !== 1.0)
        element.scrollIntoView({block: &apos;center&apos;, inline: &apos;center&apos;, behavior: &apos;instant&apos;});
      return false;
    }, this, this._page._javascriptEnabled);
    if (error)
      throw new Error(error);
  }

  /**
   * @return {!Promise&lt;!{x: number, y: number}&gt;}
   */
  async _clickablePoint() {
    const [result, layoutMetrics] = await Promise.all([
      this._client.send(&apos;DOM.getContentQuads&apos;, {
        objectId: this._remoteObject.objectId
      }).catch(debugError),
      this._client.send(&apos;Page.getLayoutMetrics&apos;),
    ]);
    if (!result || !result.quads.length)
      throw new Error(&apos;Node is either not visible or not an HTMLElement&apos;);
    // Filter out quads that have too small area to click into.
    const {clientWidth, clientHeight} = layoutMetrics.layoutViewport;
    const quads = result.quads.map(quad =&gt; this._fromProtocolQuad(quad)).map(quad =&gt; this._intersectQuadWithViewport(quad, clientWidth
, clientHeight)).filter(quad =&gt; computeQuadArea(quad) &gt; 1);
    if (!quads.length)
      throw new Error(&apos;Node is either not visible or not an HTMLElement&apos;);
    // Return the middle point of the first quad.
    const quad = quads[0];
    let x = 0;
    let y = 0;
    for (const point of quad) {
      x += point.x;
      y += point.y;
    }
    return {
      x: x / 4,
      y: y / 4
    };
  }

  /**
   * @return {!Promise&lt;void|Protocol.DOM.getBoxModelReturnValue&gt;}
   */
  _getBoxModel() {
    return this._client.send(&apos;DOM.getBoxModel&apos;, {
      objectId: this._remoteObject.objectId
    }).catch(error =&gt; debugError(error));
  }

  /**
   * @param {!Array&lt;number&gt;} quad
   * @return {!Array&lt;{x: number, y: number}&gt;}
   */
  _fromProtocolQuad(quad) {
    return [
      {x: quad[0], y: quad[1]},
      {x: quad[2], y: quad[3]},
      {x: quad[4], y: quad[5]},
      {x: quad[6], y: quad[7]}
    ];
  }

  /**
   * @param {!Array&lt;{x: number, y: number}&gt;} quad
   * @param {number} width
   * @param {number} height
   * @return {!Array&lt;{x: number, y: number}&gt;}
   */
  _intersectQuadWithViewport(quad,...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.ExecutionContext" id="apidoc.elem.utility2.puppeteer.puppeteerApi.ExecutionContext">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>ExecutionContext
        <span class="apidocSignatureSpan">(client, contextPayload, world)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExecutionContext {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Protocol.Runtime.ExecutionContextDescription} contextPayload
   * @param {?Puppeteer.DOMWorld} world
   */
</span>  constructor(client, contextPayload, world) {
    this._client = client;
    this._world = world;
    this._contextId = contextPayload.id;
  }

  /**
   * @return {?Puppeteer.Frame}
   */
  frame() {
    return this._world ? this._world.frame() : null;
  }

  /**
   * @param {Function|string} pageFunction
   * @param {...*} args
   * @return {!Promise&lt;*&gt;}
   */
  async evaluate(pageFunction, ...args) {
    return await this._evaluateInternal(true /* returnByValue */, pageFunction, ...args);
  }

  /**
   * @param {Function|string} pageFunction
   * @param {...*} args
   * @return {!Promise&lt;!JSHandle&gt;}
   */
  async evaluateHandle(pageFunction, ...args) {
    return this._evaluateInternal(false /* returnByValue */, pageFunction, ...args);
  }

  /**
   * @param {boolean} returnByValue
   * @param {Function|string} pageFunction
   * @param {...*} args
   * @return {!Promise&lt;*&gt;}
   */
  async _evaluateInternal(returnByValue, pageFunction, ...args) {
    const suffix = `//# sourceURL=${EVALUATION_SCRIPT_URL}`;

    if (helper.isString(pageFunction)) {
      const contextId = this._contextId;
      const expression = /** @type {string} */ (pageFunction);
      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + &apos;\n&apos; + suffix;
      const {exceptionDetails, result: remoteObject} = await this._client.send(&apos;Runtime.evaluate&apos;, {
        expression: expressionWithSourceUrl,
        contextId,
        returnByValue,
        awaitPromise: true,
        userGesture: true
      }).catch(rewriteError);
      if (exceptionDetails)
        throw new Error(&apos;Evaluation failed: &apos; + helper.getExceptionMessage(exceptionDetails));
      return returnByValue ? helper.valueFromRemoteObject(remoteObject) : createJSHandle(this, remoteObject);
    }

    if (typeof pageFunction !== &apos;function&apos;)
      throw new Error(`Expected to get |string| or |function| as the first argument, but got &quot;${pageFunction}&quot; instead.`);

    let functionText = pageFunction.toString();
    // hack-coverage - un-instrument
    functionText = functionText.replace((/\b__cov_.*?\+\+/g), &quot;0&quot;);
    try {
      new Function(&apos;(&apos; + functionText + &apos;)&apos;);
    } catch (e1) {
      // This means we might have a function shorthand. Try another
      // time prefixing &apos;function &apos;.
      if (functionText.startsWith(&apos;async &apos;))
        functionText = &apos;async function &apos; + functionText.substring(&apos;async &apos;.length);
      else
        functionText = &apos;function &apos; + functionText;
      try {
        new Function(&apos;(&apos; + functionText  + &apos;)&apos;);
      } catch (e2) {
        // We tried hard to serialize, but there&apos;s a weird beast here.
        throw new Error(&apos;Passed function is not well-serializable!&apos;);
      }
    }
    let callFunctionOnPromise;
    try {
      callFunctionOnPromise = this._client.send(&apos;Runtime.callFunctionOn&apos;, {
        functionDeclaration: functionText + &apos;\n&apos; + suffix + &apos;\n&apos;,
        executionContextId: this._contextId,
        arguments: args.map(convertArgument.bind(this)),
        returnByValue,
        awaitPromise: true,
        userGesture: true
      });
    } catch (err) {
      if (err instanceof TypeError &amp;&amp; err.message.startsWith(&apos;Converting circular structure to JSON&apos;))
        err.message += &apos; Are you passing a nested JSHandle?&apos;;
      throw err;
    }
    const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
    if (exceptionDetails)
      throw new Error(&apos;Evaluation failed: &apos; + helper.getExceptionMessage(exceptionDetails));
    return returnByValue ? helper.valueFromRemoteObject(remoteObject) : crea...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.FileChooser" id="apidoc.elem.utility2.puppeteer.puppeteerApi.FileChooser">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>FileChooser
        <span class="apidocSignatureSpan">(client, event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FileChooser {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {!Protocol.Page.fileChooserOpenedPayload} event
   */
</span>  constructor(client, event) {
    this._client = client;
    this._multiple = event.mode !== &apos;selectSingle&apos;;
    this._handled = false;
  }

  /**
   * @return {boolean}
   */
  isMultiple() {
    return this._multiple;
  }

  /**
   * @param {!Array&lt;string&gt;} filePaths
   * @return {!Promise}
   */
  async accept(filePaths) {
    assert(!this._handled, &apos;Cannot accept FileChooser which is already handled!&apos;);
    this._handled = true;
    const files = filePaths.map(filePath =&gt; path.resolve(filePath));
    await this._client.send(&apos;Page.handleFileChooser&apos;, {
      action: &apos;accept&apos;,
      files,
    });
  }

  /**
   * @return {!Promise}
   */
  async cancel() {
    assert(!this._handled, &apos;Cannot cancel FileChooser which is already handled!&apos;);
    this._handled = true;
    await this._client.send(&apos;Page.handleFileChooser&apos;, {
      action: &apos;cancel&apos;,
    });
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Frame" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Frame">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Frame
        <span class="apidocSignatureSpan">(frameManager, client, parentFrame, frameId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Frame {
<span class="apidocCodeCommentSpan">  /**
   * @param {!FrameManager} frameManager
   * @param {!Puppeteer.CDPSession} client
   * @param {?Frame} parentFrame
   * @param {string} frameId
   */
</span>  constructor(frameManager, client, parentFrame, frameId) {
    this._frameManager = frameManager;
    this._client = client;
    this._parentFrame = parentFrame;
    this._url = &apos;&apos;;
    this._id = frameId;
    this._detached = false;

    this._loaderId = &apos;&apos;;
    /** @type {!Set&lt;string&gt;} */
    this._lifecycleEvents = new Set();
    /** @type {!DOMWorld} */
    this._mainWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);
    /** @type {!DOMWorld} */
    this._secondaryWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);

    /** @type {!Set&lt;!Frame&gt;} */
    this._childFrames = new Set();
    if (this._parentFrame)
      this._parentFrame._childFrames.add(this);
  }

  /**
   * @param {string} url
   * @param {!{referer?: string, timeout?: number, waitUntil?: string|!Array&lt;string&gt;}=} options
   * @return {!Promise&lt;?Puppeteer.Response&gt;}
   */
  async goto(url, options) {
    return await this._frameManager.navigateFrame(this, url, options);
  }

  /**
   * @param {!{timeout?: number, waitUntil?: string|!Array&lt;string&gt;}=} options
   * @return {!Promise&lt;?Puppeteer.Response&gt;}
   */
  async waitForNavigation(options) {
    return await this._frameManager.waitForFrameNavigation(this, options);
  }

  /**
   * @return {!Promise&lt;!ExecutionContext&gt;}
   */
  executionContext() {
    return this._mainWorld.executionContext();
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;!Puppeteer.JSHandle&gt;}
   */
  async evaluateHandle(pageFunction, ...args) {
    return this._mainWorld.evaluateHandle(pageFunction, ...args);
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;*&gt;}
   */
  async evaluate(pageFunction, ...args) {
    return this._mainWorld.evaluate(pageFunction, ...args);
  }

  /**
   * @param {string} selector
   * @return {!Promise&lt;?Puppeteer.ElementHandle&gt;}
   */
  async $(selector) {
    return this._mainWorld.$(selector);
  }

  /**
   * @param {string} expression
   * @return {!Promise&lt;!Array&lt;!Puppeteer.ElementHandle&gt;&gt;}
   */
  async $x(expression) {
    return this._mainWorld.$x(expression);
  }

  /**
   * @param {string} selector
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;(!Object|undefined)&gt;}
   */
  async $eval(selector, pageFunction, ...args) {
    return this._mainWorld.$eval(selector, pageFunction, ...args);
  }

  /**
   * @param {string} selector
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;(!Object|undefined)&gt;}
   */
  async $$eval(selector, pageFunction, ...args) {
    return this._mainWorld.$$eval(selector, pageFunction, ...args);
  }

  /**
   * @param {string} selector
   * @return {!Promise&lt;!Array&lt;!Puppeteer.ElementHandle&gt;&gt;}
   */
  async $$(selector) {
    return this._mainWorld.$$(selector);
  }

  /**
   * @return {!Promise&lt;String&gt;}
   */
  async content() {
    return this._secondaryWorld.content();
  }

  /**
   * @param {string} html
   * @param {!{timeout?: number, waitUntil?: string|!Array&lt;string&gt;}=} options
   */
  async setContent(html, options = {}) {
    return this._secondaryWorld.setContent(html, options);
  }

  /**
   * @return {string}
   */
  name() {
    return this._name || &apos;&apos;;
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {?Frame}
   */
  parentFrame() {
    return this._parentFrame;
  }

  /**
   * @return {!Array.&lt;!Frame&gt;}
   */
  childFrames() {
    return Array.from(this._childFrames);
  }

  /**
   * @return {boolean}
   */
  isDetached() {
    return this._detached;
  }

  /**
   * @param {!{url?: string,...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.JSHandle" id="apidoc.elem.utility2.puppeteer.puppeteerApi.JSHandle">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>JSHandle
        <span class="apidocSignatureSpan">(context, client, remoteObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class JSHandle {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.ExecutionContext} context
   * @param {!Puppeteer.CDPSession} client
   * @param {!Protocol.Runtime.RemoteObject} remoteObject
   */
</span>  constructor(context, client, remoteObject) {
    this._context = context;
    this._client = client;
    this._remoteObject = remoteObject;
    this._disposed = false;
  }

  /**
   * @return {!Puppeteer.ExecutionContext}
   */
  executionContext() {
    return this._context;
  }

  /**
   * @param {string} propertyName
   * @return {!Promise&lt;?JSHandle&gt;}
   */
  async getProperty(propertyName) {
    const objectHandle = await this._context.evaluateHandle((object, propertyName) =&gt; {
      const result = {__proto__: null};
      result[propertyName] = object[propertyName];
      return result;
    }, this, propertyName);
    const properties = await objectHandle.getProperties();
    const result = properties.get(propertyName) || null;
    await objectHandle.dispose();
    return result;
  }

  /**
   * @return {!Promise&lt;!Map&lt;string, !JSHandle&gt;&gt;}
   */
  async getProperties() {
    const response = await this._client.send(&apos;Runtime.getProperties&apos;, {
      objectId: this._remoteObject.objectId,
      ownProperties: true
    });
    const result = new Map();
    for (const property of response.result) {
      if (!property.enumerable)
        continue;
      result.set(property.name, createJSHandle(this._context, property.value));
    }
    return result;
  }

  /**
   * @return {!Promise&lt;?Object&gt;}
   */
  async jsonValue() {
    if (this._remoteObject.objectId) {
      const response = await this._client.send(&apos;Runtime.callFunctionOn&apos;, {
        functionDeclaration: &apos;function() { return this; }&apos;,
        objectId: this._remoteObject.objectId,
        returnByValue: true,
        awaitPromise: true,
      });
      return helper.valueFromRemoteObject(response.result);
    }
    return helper.valueFromRemoteObject(this._remoteObject);
  }

  /**
   * @return {?Puppeteer.ElementHandle}
   */
  asElement() {
    return null;
  }

  async dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    await helper.releaseObject(this._client, this._remoteObject);
  }

  /**
   * @override
   * @return {string}
   */
  toString() {
    if (this._remoteObject.objectId) {
      const type =  this._remoteObject.subtype || this._remoteObject.type;
      return &apos;JSHandle@&apos; + type;
    }
    return &apos;JSHandle:&apos; + helper.valueFromRemoteObject(this._remoteObject);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Keyboard" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Keyboard">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Keyboard
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Keyboard {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._client = client;
    this._modifiers = 0;
    this._pressedKeys = new Set();
  }

  /**
   * @param {string} key
   * @param {{text?: string}=} options
   */
  async down(key, options = { text: undefined }) {
    const description = this._keyDescriptionForString(key);

    const autoRepeat = this._pressedKeys.has(description.code);
    this._pressedKeys.add(description.code);
    this._modifiers |= this._modifierBit(description.key);

    const text = options.text === undefined ? description.text : options.text;
    await this._client.send(&apos;Input.dispatchKeyEvent&apos;, {
      type: text ? &apos;keyDown&apos; : &apos;rawKeyDown&apos;,
      modifiers: this._modifiers,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      key: description.key,
      text: text,
      unmodifiedText: text,
      autoRepeat,
      location: description.location,
      isKeypad: description.location === 3
    });
  }

  /**
   * @param {string} key
   * @return {number}
   */
  _modifierBit(key) {
    if (key === &apos;Alt&apos;)
      return 1;
    if (key === &apos;Control&apos;)
      return 2;
    if (key === &apos;Meta&apos;)
      return 4;
    if (key === &apos;Shift&apos;)
      return 8;
    return 0;
  }

  /**
   * @param {string} keyString
   * @return {KeyDescription}
   */
  _keyDescriptionForString(keyString) {
    const shift = this._modifiers &amp; 8;
    const description = {
      key: &apos;&apos;,
      keyCode: 0,
      code: &apos;&apos;,
      text: &apos;&apos;,
      location: 0
    };

    const definition = keyDefinitions[keyString];
    assert(definition, `Unknown key: &quot;${keyString}&quot;`);

    if (definition.key)
      description.key = definition.key;
    if (shift &amp;&amp; definition.shiftKey)
      description.key = definition.shiftKey;

    if (definition.keyCode)
      description.keyCode = definition.keyCode;
    if (shift &amp;&amp; definition.shiftKeyCode)
      description.keyCode = definition.shiftKeyCode;

    if (definition.code)
      description.code = definition.code;

    if (definition.location)
      description.location = definition.location;

    if (description.key.length === 1)
      description.text = description.key;

    if (definition.text)
      description.text = definition.text;
    if (shift &amp;&amp; definition.shiftText)
      description.text = definition.shiftText;

    // if any modifiers besides shift are pressed, no text should be sent
    if (this._modifiers &amp; ~8)
      description.text = &apos;&apos;;

    return description;
  }

  /**
   * @param {string} key
   */
  async up(key) {
    const description = this._keyDescriptionForString(key);

    this._modifiers &amp;= ~this._modifierBit(description.key);
    this._pressedKeys.delete(description.code);
    await this._client.send(&apos;Input.dispatchKeyEvent&apos;, {
      type: &apos;keyUp&apos;,
      modifiers: this._modifiers,
      key: description.key,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      location: description.location
    });
  }

  /**
   * @param {string} char
   */
  async sendCharacter(char) {
    await this._client.send(&apos;Input.insertText&apos;, {text: char});
  }

  /**
   * @param {string} text
   * @param {{delay: (number|undefined)}=} options
   */
  async type(text, options) {
    let delay = 0;
    if (options &amp;&amp; options.delay)
      delay = options.delay;
    for (const char of text) {
      if (keyDefinitions[char])
        await this.press(char, {delay});
      else
        await this.sendCharacter(char);
      if (delay)
        await new Promise(f =&gt; setTimeout(f, delay));
    }
  }

  /**
   * @param {string} key
   * @param {!{delay?: number, text?: string}=} options
   */
  async press(key, options = {}) {
    const {delay = null} = options;
    await this.down(key, options);
    if (delay !== null)
      await new Promise(f =&gt; se...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Mouse" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Mouse">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Mouse
        <span class="apidocSignatureSpan">(client, keyboard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Mouse {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {!Keyboard} keyboard
   */
</span>  constructor(client, keyboard) {
    this._client = client;
    this._keyboard = keyboard;
    this._x = 0;
    this._y = 0;
    /** @type {&apos;none&apos;|&apos;left&apos;|&apos;right&apos;|&apos;middle&apos;} */
    this._button = &apos;none&apos;;
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {!{steps?: number}=} options
   */
  async move(x, y, options = {}) {
    const {steps = 1} = options;
    const fromX = this._x, fromY = this._y;
    this._x = x;
    this._y = y;
    for (let i = 1; i &lt;= steps; i++) {
      await this._client.send(&apos;Input.dispatchMouseEvent&apos;, {
        type: &apos;mouseMoved&apos;,
        button: this._button,
        x: fromX + (this._x - fromX) * (i / steps),
        y: fromY + (this._y - fromY) * (i / steps),
        modifiers: this._keyboard._modifiers
      });
    }
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {!{delay?: number, button?: &quot;left&quot;|&quot;right&quot;|&quot;middle&quot;, clickCount?: number}=} options
   */
  async click(x, y, options = {}) {
    const {delay = null} = options;
    if (delay !== null) {
      await Promise.all([
        this.move(x, y),
        this.down(options),
      ]);
      await new Promise(f =&gt; setTimeout(f, delay));
      await this.up(options);
    } else {
      await Promise.all([
        this.move(x, y),
        this.down(options),
        this.up(options),
      ]);
    }
  }

  /**
   * @param {!{button?: &quot;left&quot;|&quot;right&quot;|&quot;middle&quot;, clickCount?: number}=} options
   */
  async down(options = {}) {
    const {button = &apos;left&apos;, clickCount = 1} = options;
    this._button = button;
    await this._client.send(&apos;Input.dispatchMouseEvent&apos;, {
      type: &apos;mousePressed&apos;,
      button,
      x: this._x,
      y: this._y,
      modifiers: this._keyboard._modifiers,
      clickCount
    });
  }

  /**
   * @param {!{button?: &quot;left&quot;|&quot;right&quot;|&quot;middle&quot;, clickCount?: number}=} options
   */
  async up(options = {}) {
    const {button = &apos;left&apos;, clickCount = 1} = options;
    this._button = &apos;none&apos;;
    await this._client.send(&apos;Input.dispatchMouseEvent&apos;, {
      type: &apos;mouseReleased&apos;,
      button,
      x: this._x,
      y: this._y,
      modifiers: this._keyboard._modifiers,
      clickCount
    });
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Page" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Page">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Page
        <span class="apidocSignatureSpan">(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Page extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Puppeteer.Target} target
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue
   * @return {!Promise&lt;!Page&gt;}
   */
</span>  static async create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
    const page = new Page(client, target, ignoreHTTPSErrors, screenshotTaskQueue);
    await page._initialize();
    if (defaultViewport)
      await page.setViewport(defaultViewport);
    return page;
  }

  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Puppeteer.Target} target
   * @param {boolean} ignoreHTTPSErrors
   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue
   */
  constructor(client, target, ignoreHTTPSErrors, screenshotTaskQueue) {
    super();
    this._closed = false;
    this._client = client;
    this._target = target;
    this._keyboard = new Keyboard(client);
    this._mouse = new Mouse(client, this._keyboard);
    this._timeoutSettings = new TimeoutSettings();
    this._touchscreen = new Touchscreen(client, this._keyboard);
    this._accessibility = new Accessibility(client);
    /** @type {!FrameManager} */
    this._frameManager = new FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
    this._emulationManager = new EmulationManager(client);
    this._tracing = new Tracing(client);
    /** @type {!Map&lt;string, Function&gt;} */
    this._pageBindings = new Map();
    this._coverage = new Coverage(client);
    this._javascriptEnabled = true;
    /** @type {?Puppeteer.Viewport} */
    this._viewport = null;

    this._screenshotTaskQueue = screenshotTaskQueue;

    /** @type {!Map&lt;string, Worker&gt;} */
    this._workers = new Map();
    client.on(&apos;Target.attachedToTarget&apos;, event =&gt; {
      if (event.targetInfo.type !== &apos;worker&apos;) {
        // If we don&apos;t detach from service workers, they will never die.
        client.send(&apos;Target.detachFromTarget&apos;, {
          sessionId: event.sessionId
        }).catch(debugError);
        return;
      }
      const session = Connection.fromSession(client).session(event.sessionId);
      const worker = new Worker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this
));
      this._workers.set(event.sessionId, worker);
      this.emit(Events.Page.WorkerCreated, worker);
    });
    client.on(&apos;Target.detachedFromTarget&apos;, event =&gt; {
      const worker = this._workers.get(event.sessionId);
      if (!worker)
        return;
      this.emit(Events.Page.WorkerDestroyed, worker);
      this._workers.delete(event.sessionId);
    });

    this._frameManager.on(Events.FrameManager.FrameAttached, event =&gt; this.emit(Events.Page.FrameAttached, event));
    this._frameManager.on(Events.FrameManager.FrameDetached, event =&gt; this.emit(Events.Page.FrameDetached, event));
    this._frameManager.on(Events.FrameManager.FrameNavigated, event =&gt; this.emit(Events.Page.FrameNavigated, event));

    const networkManager = this._frameManager.networkManager();
    networkManager.on(Events.NetworkManager.Request, event =&gt; this.emit(Events.Page.Request, event));
    networkManager.on(Events.NetworkManager.Response, event =&gt; this.emit(Events.Page.Response, event));
    networkManager.on(Events.NetworkManager.RequestFailed, event =&gt; this.emit(Events.Page.RequestFailed, event));
    networkManager.on(Events.NetworkManager.RequestFinished, event =&gt; this.emit(Events.Page.RequestFinished, event));
    this._fileChooserInterceptionIsDisabled = false;
    this._fileChooserInterceptors = new Set();

    client.on(&apos;Page.domContentEventFired&apos;, event =&gt; this.emit(Events.Page.DOMContentLoaded));
    client.on(&apos;Page.loadEventFired&apos;, event =&gt; this.emit(Events.Page.Load));
    client.on(&apos;Runtime.consoleAPICalled&apos;, event =&gt; this._onConsoleAPI(event));
    client.on(&apos...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Puppeteer" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Puppeteer">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Puppeteer
        <span class="apidocSignatureSpan">(projectRoot, preferredRevision, isPuppeteerCore)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class {
<span class="apidocCodeCommentSpan">  /**
   * @param {string} projectRoot
   * @param {string} preferredRevision
   * @param {boolean} isPuppeteerCore
   */
</span>  constructor(projectRoot, preferredRevision, isPuppeteerCore) {
    this._projectRoot = projectRoot;
    this._launcher = new Launcher(projectRoot, preferredRevision, isPuppeteerCore);
  }

  /**
   * @param {!(Launcher.LaunchOptions &amp; Launcher.ChromeArgOptions &amp; Launcher.BrowserOptions)=} options
   * @return {!Promise&lt;!Puppeteer.Browser&gt;}
   */
  launch(options) {
    return this._launcher.launch(options);
  }

  /**
   * @param {!(Launcher.BrowserOptions &amp; {browserWSEndpoint?: string, browserURL?: string, transport?: !Puppeteer.ConnectionTransport
})} options
   * @return {!Promise&lt;!Puppeteer.Browser&gt;}
   */
  connect(options) {
    return this._launcher.connect(options);
  }

  /**
   * @return {string}
   */
  executablePath() {
    return this._launcher.executablePath();
  }

  /**
   * @return {Object}
   */
  get devices() {
    return DeviceDescriptors;
  }

  /**
   * @return {Object}
   */
  get errors() {
    return Errors;
  }

  /**
   * @param {!Launcher.ChromeArgOptions=} options
   * @return {!Array&lt;string&gt;}
   */
  defaultArgs(options) {
    return this._launcher.defaultArgs(options);
  }

  /**
   * @param {!BrowserFetcher.Options=} options
   * @return {!BrowserFetcher}
   */
  createBrowserFetcher(options) {
    return new BrowserFetcher(this._projectRoot, options);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Request" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Request">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Request
        <span class="apidocSignatureSpan">(client, frame, interceptionId, allowInterception, event, redirectChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Request {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {?Puppeteer.Frame} frame
   * @param {string} interceptionId
   * @param {boolean} allowInterception
   * @param {!Protocol.Network.requestWillBeSentPayload} event
   * @param {!Array&lt;!Request&gt;} redirectChain
   */
</span>  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {
    this._client = client;
    this._requestId = event.requestId;
    this._isNavigationRequest = event.requestId === event.loaderId &amp;&amp; event.type === &apos;Document&apos;;
    this._interceptionId = interceptionId;
    this._allowInterception = allowInterception;
    this._interceptionHandled = false;
    this._response = null;
    this._failureText = null;

    this._url = event.request.url;
    this._resourceType = event.type.toLowerCase();
    this._method = event.request.method;
    this._postData = event.request.postData;
    this._headers = {};
    this._frame = frame;
    this._redirectChain = redirectChain;
    for (const key of Object.keys(event.request.headers))
      this._headers[key.toLowerCase()] = event.request.headers[key];

    this._fromMemoryCache = false;
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {string}
   */
  resourceType() {
    return this._resourceType;
  }

  /**
   * @return {string}
   */
  method() {
    return this._method;
  }

  /**
   * @return {string|undefined}
   */
  postData() {
    return this._postData;
  }

  /**
   * @return {!Object}
   */
  headers() {
    return this._headers;
  }

  /**
   * @return {?Response}
   */
  response() {
    return this._response;
  }

  /**
   * @return {?Puppeteer.Frame}
   */
  frame() {
    return this._frame;
  }

  /**
   * @return {boolean}
   */
  isNavigationRequest() {
    return this._isNavigationRequest;
  }

  /**
   * @return {!Array&lt;!Request&gt;}
   */
  redirectChain() {
    return this._redirectChain.slice();
  }

  /**
   * @return {?{errorText: string}}
   */
  failure() {
    if (!this._failureText)
      return null;
    return {
      errorText: this._failureText
    };
  }

  /**
   * @param {!{url?: string, method?:string, postData?: string, headers?: !Object}} overrides
   */
  async continue(overrides = {}) {
    // Request interception is not supported for data: urls.
    if (this._url.startsWith(&apos;data:&apos;))
      return;
    assert(this._allowInterception, &apos;Request Interception is not enabled!&apos;);
    assert(!this._interceptionHandled, &apos;Request is already handled!&apos;);
    const {
      url,
      method,
      postData,
      headers
    } = overrides;
    this._interceptionHandled = true;
    await this._client.send(&apos;Fetch.continueRequest&apos;, {
      requestId: this._interceptionId,
      url,
      method,
      postData,
      headers: headers ? headersArray(headers) : undefined,
    }).catch(error =&gt; {
      // In certain cases, protocol will return error if the request was already canceled
      // or the page was closed. We should tolerate these errors.
      debugError(error);
    });
  }

  /**
   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response
   */
  async respond(response) {
    // Mocking responses for dataURL requests is not currently supported.
    if (this._url.startsWith(&apos;data:&apos;))
      return;
    assert(this._allowInterception, &apos;Request Interception is not enabled!&apos;);
    assert(!this._interceptionHandled, &apos;Request is already handled!&apos;);
    this._interceptionHandled = true;

    const responseBody = response.body &amp;&amp; helper.isString(response.body) ? Buffer.from(/** @type {string} */(response.body)) : /** @
type {?Buffer} */(response.body || null);

    /** @type {!Object&lt;string, string&gt;} */
    const responseHeaders = {};
    if (response.headers) {
      for (const header of Object.keys(response.headers))
        responseHeaders[header.toLowerCase()] = response.headers[header];
    }...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Response" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Response">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Response
        <span class="apidocSignatureSpan">(client, request, responsePayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Response {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   * @param {!Request} request
   * @param {!Protocol.Network.Response} responsePayload
   */
</span>  constructor(client, request, responsePayload) {
    this._client = client;
    this._request = request;
    this._contentPromise = null;

    this._bodyLoadedPromise = new Promise(fulfill =&gt; {
      this._bodyLoadedPromiseFulfill = fulfill;
    });

    this._remoteAddress = {
      ip: responsePayload.remoteIPAddress,
      port: responsePayload.remotePort,
    };
    this._status = responsePayload.status;
    this._statusText = responsePayload.statusText;
    this._url = request.url();
    this._fromDiskCache = !!responsePayload.fromDiskCache;
    this._fromServiceWorker = !!responsePayload.fromServiceWorker;
    this._headers = {};
    for (const key of Object.keys(responsePayload.headers))
      this._headers[key.toLowerCase()] = responsePayload.headers[key];
    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
  }

  /**
   * @return {{ip: string, port: number}}
   */
  remoteAddress() {
    return this._remoteAddress;
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {boolean}
   */
  ok() {
    return this._status === 0 || (this._status &gt;= 200 &amp;&amp; this._status &lt;= 299);
  }

  /**
   * @return {number}
   */
  status() {
    return this._status;
  }

  /**
   * @return {string}
   */
  statusText() {
    return this._statusText;
  }

  /**
   * @return {!Object}
   */
  headers() {
    return this._headers;
  }

  /**
   * @return {?SecurityDetails}
   */
  securityDetails() {
    return this._securityDetails;
  }

  /**
   * @return {!Promise&lt;!Buffer&gt;}
   */
  buffer() {
    if (!this._contentPromise) {
      this._contentPromise = this._bodyLoadedPromise.then(async error =&gt; {
        if (error)
          throw error;
        const response = await this._client.send(&apos;Network.getResponseBody&apos;, {
          requestId: this._request._requestId
        });
        return Buffer.from(response.body, response.base64Encoded ? &apos;base64&apos; : &apos;utf8&apos;);
      });
    }
    return this._contentPromise;
  }

  /**
   * @return {!Promise&lt;string&gt;}
   */
  async text() {
    const content = await this.buffer();
    return content.toString(&apos;utf8&apos;);
  }

  /**
   * @return {!Promise&lt;!Object&gt;}
   */
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }

  /**
   * @return {!Request}
   */
  request() {
    return this._request;
  }

  /**
   * @return {boolean}
   */
  fromCache() {
    return this._fromDiskCache || this._request._fromMemoryCache;
  }

  /**
   * @return {boolean}
   */
  fromServiceWorker() {
    return this._fromServiceWorker;
  }

  /**
   * @return {?Puppeteer.Frame}
   */
  frame() {
    return this._request.frame();
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.SecurityDetails" id="apidoc.elem.utility2.puppeteer.puppeteerApi.SecurityDetails">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>SecurityDetails
        <span class="apidocSignatureSpan">(securityPayload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SecurityDetails {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Protocol.Network.SecurityDetails} securityPayload
   */
</span>  constructor(securityPayload) {
    this._subjectName = securityPayload[&apos;subjectName&apos;];
    this._issuer = securityPayload[&apos;issuer&apos;];
    this._validFrom = securityPayload[&apos;validFrom&apos;];
    this._validTo = securityPayload[&apos;validTo&apos;];
    this._protocol = securityPayload[&apos;protocol&apos;];
  }

  /**
   * @return {string}
   */
  subjectName() {
    return this._subjectName;
  }

  /**
   * @return {string}
   */
  issuer() {
    return this._issuer;
  }

  /**
   * @return {number}
   */
  validFrom() {
    return this._validFrom;
  }

  /**
   * @return {number}
   */
  validTo() {
    return this._validTo;
  }

  /**
   * @return {string}
   */
  protocol() {
    return this._protocol;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Target" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Target">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Target
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Target {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Protocol.Target.TargetInfo} targetInfo
   * @param {!Puppeteer.BrowserContext} browserContext
   * @param {!function():!Promise&lt;!Puppeteer.CDPSession&gt;} sessionFactory
   * @param {boolean} ignoreHTTPSErrors
   * @param {?Puppeteer.Viewport} defaultViewport
   * @param {!Puppeteer.TaskQueue} screenshotTaskQueue
   */
</span>  constructor(targetInfo, browserContext, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
    this._targetInfo = targetInfo;
    this._browserContext = browserContext;
    this._targetId = targetInfo.targetId;
    this._sessionFactory = sessionFactory;
    this._ignoreHTTPSErrors = ignoreHTTPSErrors;
    this._defaultViewport = defaultViewport;
    this._screenshotTaskQueue = screenshotTaskQueue;
    /** @type {?Promise&lt;!Puppeteer.Page&gt;} */
    this._pagePromise = null;
    /** @type {?Promise&lt;!Worker&gt;} */
    this._workerPromise = null;
    this._initializedPromise = new Promise(fulfill =&gt; this._initializedCallback = fulfill).then(async success =&gt; {
      if (!success)
        return false;
      const opener = this.opener();
      if (!opener || !opener._pagePromise || this.type() !== &apos;page&apos;)
        return true;
      const openerPage = await opener._pagePromise;
      if (!openerPage.listenerCount(Events.Page.Popup))
        return true;
      const popupPage = await this.page();
      openerPage.emit(Events.Page.Popup, popupPage);
      return true;
    });
    this._isClosedPromise = new Promise(fulfill =&gt; this._closedCallback = fulfill);
    this._isInitialized = this._targetInfo.type !== &apos;page&apos; || this._targetInfo.url !== &apos;&apos;;
    if (this._isInitialized)
      this._initializedCallback(true);
  }

  /**
   * @return {!Promise&lt;!Puppeteer.CDPSession&gt;}
   */
  createCDPSession() {
    return this._sessionFactory();
  }

  /**
   * @return {!Promise&lt;?Page&gt;}
   */
  async page() {
    if ((this._targetInfo.type === &apos;page&apos; || this._targetInfo.type === &apos;background_page&apos;) &amp;&amp; !this._pagePromise) {
      this._pagePromise = this._sessionFactory()
          .then(client =&gt; Page.create(client, this, this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue));
    }
    return this._pagePromise;
  }

  /**
   * @return {!Promise&lt;?Worker&gt;}
   */
  async worker() {
    if (this._targetInfo.type !== &apos;service_worker&apos; &amp;&amp; this._targetInfo.type !== &apos;shared_worker&apos;)
      return null;
    if (!this._workerPromise) {
      this._workerPromise = this._sessionFactory().then(async client =&gt; {
        // Top level workers have a fake page wrapping the actual worker.
        const [targetAttached] = await Promise.all([
          new Promise(x =&gt; client.once(&apos;Target.attachedToTarget&apos;, x)),
          client.send(&apos;Target.setAutoAttach&apos;, {autoAttach: true, waitForDebuggerOnStart: false, flatten: true}),
        ]);
        const session = Connection.fromSession(client).session(targetAttached.sessionId);
        // TODO(einbinder): Make workers send their console logs.
        return new Worker(session, this._targetInfo.url, () =&gt; {} /* consoleAPICalled */, () =&gt; {} /* exceptionThrown */);
      });
    }
    return this._workerPromise;
  }

  /**
   * @return {string}
   */
  url() {
    return this._targetInfo.url;
  }

  /**
   * @return {&quot;page&quot;|&quot;background_page&quot;|&quot;service_worker&quot;|&quot;shared_worker&quot;|&quot;other&quot;|&quot;browser&quot;}
   */
  type() {
    const type = this._targetInfo.type;
    if (type === &apos;page&apos; || type === &apos;background_page&apos; || type === &apos;service_worker&apos; || type === &apos;shared_worker&apos; || type === &apos;browser
&apos;)
      return type;
    return &apos;other&apos;;
  }

  /**
   * @return {!Puppeteer.Browser}
   */
  browser() {
    return this._browserContext.browser();
  }

  /**
   * @return {!Puppeteer.BrowserContext}
   */
  browserContext() {...</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.TimeoutError" id="apidoc.elem.utility2.puppeteer.puppeteerApi.TimeoutError">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>TimeoutError
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TimeoutError extends CustomError {}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Touchscreen" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Touchscreen">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Touchscreen
        <span class="apidocSignatureSpan">(client, keyboard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Touchscreen {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {Keyboard} keyboard
   */
</span>  constructor(client, keyboard) {
    this._client = client;
    this._keyboard = keyboard;
  }

  /**
   * @param {number} x
   * @param {number} y
   */
  async tap(x, y) {
    // Touches appear to be lost during the first frame after navigation.
    // This waits a frame before sending the tap.
    // @see https://crbug.com/613219
    await this._client.send(&apos;Runtime.evaluate&apos;, {
      expression: &apos;new Promise(x =&gt; requestAnimationFrame(() =&gt; requestAnimationFrame(x)))&apos;,
      awaitPromise: true
    });

    const touchPoints = [{x: Math.round(x), y: Math.round(y)}];
    await this._client.send(&apos;Input.dispatchTouchEvent&apos;, {
      type: &apos;touchStart&apos;,
      touchPoints,
      modifiers: this._keyboard._modifiers
    });
    await this._client.send(&apos;Input.dispatchTouchEvent&apos;, {
      type: &apos;touchEnd&apos;,
      touchPoints: [],
      modifiers: this._keyboard._modifiers
    });
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Tracing" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Tracing">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Tracing
        <span class="apidocSignatureSpan">(client)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Tracing {
<span class="apidocCodeCommentSpan">  /**
   * @param {!Puppeteer.CDPSession} client
   */
</span>  constructor(client) {
    this._client = client;
    this._recording = false;
    this._path = &apos;&apos;;
  }

  /**
   * @param {!{path?: string, screenshots?: boolean, categories?: !Array&lt;string&gt;}} options
   */
  async start(options = {}) {
    assert(!this._recording, &apos;Cannot start recording trace while already recording trace.&apos;);

    const defaultCategories = [
      &apos;-*&apos;, &apos;devtools.timeline&apos;, &apos;v8.execute&apos;, &apos;disabled-by-default-devtools.timeline&apos;,
      &apos;disabled-by-default-devtools.timeline.frame&apos;, &apos;toplevel&apos;,
      &apos;blink.console&apos;, &apos;blink.user_timing&apos;, &apos;latencyInfo&apos;, &apos;disabled-by-default-devtools.timeline.stack&apos;,
      &apos;disabled-by-default-v8.cpu_profiler&apos;, &apos;disabled-by-default-v8.cpu_profiler.hires&apos;
    ];
    const {
      path = null,
      screenshots = false,
      categories = defaultCategories,
    } = options;

    if (screenshots)
      categories.push(&apos;disabled-by-default-devtools.screenshot&apos;);

    this._path = path;
    this._recording = true;
    await this._client.send(&apos;Tracing.start&apos;, {
      transferMode: &apos;ReturnAsStream&apos;,
      categories: categories.join(&apos;,&apos;)
    });
  }

  /**
   * @return {!Promise&lt;!Buffer&gt;}
   */
  async stop() {
    let fulfill;
    const contentPromise = new Promise(x =&gt; fulfill = x);
    this._client.once(&apos;Tracing.tracingComplete&apos;, event =&gt; {
      helper.readProtocolStream(this._client, event.stream, this._path).then(fulfill);
    });
    await this._client.send(&apos;Tracing.end&apos;);
    this._recording = false;
    return contentPromise;
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.elem.utility2.puppeteer.puppeteerApi.Worker" id="apidoc.elem.utility2.puppeteer.puppeteerApi.Worker">
        function <span class="apidocSignatureSpan">utility2.puppeteer.puppeteerApi.</span>Worker
        <span class="apidocSignatureSpan">(string, !Array&lt;!JSHandle&gt;, Protocol.Runtime.StackTrace=)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Worker extends EventEmitter {
<span class="apidocCodeCommentSpan">  /**
   * @param {Puppeteer.CDPSession} client
   * @param {string} url
   * @param {function(string, !Array&lt;!JSHandle&gt;, Protocol.Runtime.StackTrace=):void} consoleAPICalled
   * @param {function(!Protocol.Runtime.ExceptionDetails):void} exceptionThrown
   */
</span>  constructor(client, url, consoleAPICalled, exceptionThrown) {
    super();
    this._client = client;
    this._url = url;
    this._executionContextPromise = new Promise(x =&gt; this._executionContextCallback = x);
    /** @type {function(!Protocol.Runtime.RemoteObject):!JSHandle} */
    let jsHandleFactory;
    this._client.once(&apos;Runtime.executionContextCreated&apos;, async event =&gt; {
      jsHandleFactory = remoteObject =&gt; new JSHandle(executionContext, client, remoteObject);
      const executionContext = new ExecutionContext(client, event.context, null);
      this._executionContextCallback(executionContext);
    });
    // This might fail if the target is closed before we recieve all execution contexts.
    this._client.send(&apos;Runtime.enable&apos;, {}).catch(debugError);

    this._client.on(&apos;Runtime.consoleAPICalled&apos;, event =&gt; consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace
));
    this._client.on(&apos;Runtime.exceptionThrown&apos;, exception =&gt; exceptionThrown(exception.exceptionDetails));
  }

  /**
   * @return {string}
   */
  url() {
    return this._url;
  }

  /**
   * @return {!Promise&lt;ExecutionContext&gt;}
   */
  async executionContext() {
    return this._executionContextPromise;
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;*&gt;}
   */
  async evaluate(pageFunction, ...args) {
    return (await this._executionContextPromise).evaluate(pageFunction, ...args);
  }

  /**
   * @param {Function|string} pageFunction
   * @param {!Array&lt;*&gt;} args
   * @return {!Promise&lt;!JSHandle&gt;}
   */
  async evaluateHandle(pageFunction, ...args) {
    return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);
  }
}</pre></li>
    <li>example use<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
